<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="R for Data Science" />
<meta property="og:url" content="https://r4ds.had.co.nz/" />
<meta property="og:image" content="https://r4ds.had.co.nz/cover.png" />
<meta property="og:description" content="This book will teach you how to do data science with R: You’ll learn how to get your data into R, get it into the most useful structure, transform it, visualise it and model it. In this book, you will find a practicum of skills for data science. Just as a chemist learns how to clean test tubes and stock a lab, you’ll learn how to clean data and draw plots—and many other things besides. These are the skills that allow data science to happen, and here you will find the best practices for doing each of these things with R. You’ll learn how to use the grammar of graphics, literate programming, and reproducible research to save time. You’ll also learn how to manage cognitive resources to facilitate discoveries when wrangling, visualising, and exploring data." />

<meta name="author" content="Garrett Grolemund" />
<meta name="author" content="Hadley Wickham" />


<meta name="description" content="This book will teach you how to do data science with R: You’ll learn how to get your data into R, get it into the most useful structure, transform it, visualise it and model it. In this book, you will find a practicum of skills for data science. Just as a chemist learns how to clean test tubes and stock a lab, you’ll learn how to clean data and draw plots—and many other things besides. These are the skills that allow data science to happen, and here you will find the best practices for doing each of these things with R. You’ll learn how to use the grammar of graphics, literate programming, and reproducible research to save time. You’ll also learn how to manage cognitive resources to facilitate discoveries when wrangling, visualising, and exploring data.">

<title>R for Data Science</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  window.PagedConfig = {
    before: () => {
      return new Promise((resolve, reject) => {
        var script = document.createElement("script");
        script.type = "text/javascript";
        var src = "true";
        if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
        if (location.protocol !== "file:" && /^https?:/.test(src))
          src = src.replace(/^https?:/, '');
        script.src = src;
        window.MathJax = {
          AuthorInit: () => {
            MathJax.Hub.Register.StartupHook("Begin", () => {
              MathJax.Hub.Queue(resolve);
            });
          }
        };
        document.getElementsByTagName("head")[0].appendChild(script);
      });
    }
  };
</script>

<link href="_main_files/paged-0.1.2/css/default-fonts.css" rel="stylesheet" />
<link href="_main_files/paged-0.1.2/css/default-page.css" rel="stylesheet" />
<link href="_main_files/paged-0.1.2/css/default.css" rel="stylesheet" />
<script src="_main_files/paged-0.1.2/js/config.js"></script>
<script src="_main_files/paged-0.1.2/js/paged.js"></script>
<script src="_main_files/paged-0.1.2/js/hooks.js"></script>
<script src="_main_files/htmlwidgets-1.3/htmlwidgets.js"></script>
<link href="_main_files/str_view-0.1.0/str_view.css" rel="stylesheet" />
<script src="_main_files/str_view-binding-1.3.1/str_view.js"></script>
<script src="_main_files/jquery-1.12.4/jquery.min.js"></script>
<link href="_main_files/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="_main_files/leaflet-1.3.1/leaflet.js"></script>
<link href="_main_files/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="_main_files/Proj4Leaflet-1.0.1/proj4-compressed.js"></script>
<script src="_main_files/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="_main_files/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="_main_files/leaflet-binding-2.0.0/leaflet.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">R for Data Science</h1>
<h2 class="author">Garrett Grolemund</h2>
<h2 class="author">Hadley Wickham</h2>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<h1 class="toc-title">Contents</h1>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li><a href="#what-you-will-learn"><span class="toc-section-number">1.1</span> What you will learn</a></li>
<li><a href="#how-this-book-is-organised"><span class="toc-section-number">1.2</span> How this book is organised</a></li>
<li><a href="#what-you-wont-learn"><span class="toc-section-number">1.3</span> What you won’t learn</a><ul>
<li><a href="#big-data"><span class="toc-section-number">1.3.1</span> Big data</a></li>
<li><a href="#python-julia-and-friends"><span class="toc-section-number">1.3.2</span> Python, Julia, and friends</a></li>
<li><a href="#non-rectangular-data"><span class="toc-section-number">1.3.3</span> Non-rectangular data</a></li>
<li><a href="#hypothesis-confirmation"><span class="toc-section-number">1.3.4</span> Hypothesis confirmation</a></li>
</ul></li>
<li><a href="#prerequisites"><span class="toc-section-number">1.4</span> Prerequisites</a><ul>
<li><a href="#r"><span class="toc-section-number">1.4.1</span> R</a></li>
<li><a href="#rstudio"><span class="toc-section-number">1.4.2</span> RStudio</a></li>
<li><a href="#the-tidyverse"><span class="toc-section-number">1.4.3</span> The tidyverse</a></li>
<li><a href="#other-packages"><span class="toc-section-number">1.4.4</span> Other packages</a></li>
</ul></li>
<li><a href="#running-r-code"><span class="toc-section-number">1.5</span> Running R code</a></li>
<li><a href="#getting-help-and-learning-more"><span class="toc-section-number">1.6</span> Getting help and learning more</a></li>
</ul></li>
<li class="part"><span><b>I Explore</b></span></li>
<li><a href="#explore-intro"><span class="toc-section-number">2</span> Introduction</a></li>
<li><a href="#data-visualisation"><span class="toc-section-number">3</span> Data visualisation</a><ul>
<li><a href="#introduction-1"><span class="toc-section-number">3.1</span> Introduction</a><ul>
<li><a href="#prerequisites-1"><span class="toc-section-number">3.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#first-steps"><span class="toc-section-number">3.2</span> First steps</a><ul>
<li><a href="#the-mpg-data-frame"><span class="toc-section-number">3.2.1</span> The <code>mpg</code> data frame</a></li>
<li><a href="#creating-a-ggplot"><span class="toc-section-number">3.2.2</span> Creating a ggplot</a></li>
<li><a href="#a-graphing-template"><span class="toc-section-number">3.2.3</span> A graphing template</a></li>
<li><a href="#exercises"><span class="toc-section-number">3.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#aesthetic-mappings"><span class="toc-section-number">3.3</span> Aesthetic mappings</a><ul>
<li><a href="#exercises-1"><span class="toc-section-number">3.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#common-problems"><span class="toc-section-number">3.4</span> Common problems</a></li>
<li><a href="#facets"><span class="toc-section-number">3.5</span> Facets</a><ul>
<li><a href="#exercises-2"><span class="toc-section-number">3.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#geometric-objects"><span class="toc-section-number">3.6</span> Geometric objects</a><ul>
<li><a href="#exercises-3"><span class="toc-section-number">3.6.1</span> Exercises</a></li>
</ul></li>
<li><a href="#statistical-transformations"><span class="toc-section-number">3.7</span> Statistical transformations</a><ul>
<li><a href="#exercises-4"><span class="toc-section-number">3.7.1</span> Exercises</a></li>
</ul></li>
<li><a href="#position-adjustments"><span class="toc-section-number">3.8</span> Position adjustments</a><ul>
<li><a href="#exercises-5"><span class="toc-section-number">3.8.1</span> Exercises</a></li>
</ul></li>
<li><a href="#coordinate-systems"><span class="toc-section-number">3.9</span> Coordinate systems</a><ul>
<li><a href="#exercises-6"><span class="toc-section-number">3.9.1</span> Exercises</a></li>
</ul></li>
<li><a href="#the-layered-grammar-of-graphics"><span class="toc-section-number">3.10</span> The layered grammar of graphics</a></li>
</ul></li>
<li><a href="#workflow-basics"><span class="toc-section-number">4</span> Workflow: basics</a><ul>
<li><a href="#coding-basics"><span class="toc-section-number">4.1</span> Coding basics</a></li>
<li><a href="#whats-in-a-name"><span class="toc-section-number">4.2</span> What’s in a name?</a></li>
<li><a href="#calling-functions"><span class="toc-section-number">4.3</span> Calling functions</a></li>
<li><a href="#practice"><span class="toc-section-number">4.4</span> Practice</a></li>
</ul></li>
<li><a href="#transform"><span class="toc-section-number">5</span> Data transformation</a><ul>
<li><a href="#introduction-2"><span class="toc-section-number">5.1</span> Introduction</a><ul>
<li><a href="#prerequisites-2"><span class="toc-section-number">5.1.1</span> Prerequisites</a></li>
<li><a href="#nycflights13"><span class="toc-section-number">5.1.2</span> nycflights13</a></li>
<li><a href="#dplyr-basics"><span class="toc-section-number">5.1.3</span> dplyr basics</a></li>
</ul></li>
<li><a href="#filter-rows-with-filter"><span class="toc-section-number">5.2</span> Filter rows with <code>filter()</code></a><ul>
<li><a href="#comparisons"><span class="toc-section-number">5.2.1</span> Comparisons</a></li>
<li><a href="#logical-operators"><span class="toc-section-number">5.2.2</span> Logical operators</a></li>
<li><a href="#missing-values"><span class="toc-section-number">5.2.3</span> Missing values</a></li>
<li><a href="#exercises-7"><span class="toc-section-number">5.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#arrange-rows-with-arrange"><span class="toc-section-number">5.3</span> Arrange rows with <code>arrange()</code></a><ul>
<li><a href="#exercises-8"><span class="toc-section-number">5.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#select"><span class="toc-section-number">5.4</span> Select columns with <code>select()</code></a><ul>
<li><a href="#exercises-9"><span class="toc-section-number">5.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#add-new-variables-with-mutate"><span class="toc-section-number">5.5</span> Add new variables with <code>mutate()</code></a><ul>
<li><a href="#mutate-funs"><span class="toc-section-number">5.5.1</span> Useful creation functions</a></li>
<li><a href="#exercises-10"><span class="toc-section-number">5.5.2</span> Exercises</a></li>
</ul></li>
<li><a href="#grouped-summaries-with-summarise"><span class="toc-section-number">5.6</span> Grouped summaries with <code>summarise()</code></a><ul>
<li><a href="#combining-multiple-operations-with-the-pipe"><span class="toc-section-number">5.6.1</span> Combining multiple operations with the pipe</a></li>
<li><a href="#missing-values-1"><span class="toc-section-number">5.6.2</span> Missing values</a></li>
<li><a href="#counts"><span class="toc-section-number">5.6.3</span> Counts</a></li>
<li><a href="#summarise-funs"><span class="toc-section-number">5.6.4</span> Useful summary functions</a></li>
<li><a href="#grouping-by-multiple-variables"><span class="toc-section-number">5.6.5</span> Grouping by multiple variables</a></li>
<li><a href="#ungrouping"><span class="toc-section-number">5.6.6</span> Ungrouping</a></li>
<li><a href="#exercises-11"><span class="toc-section-number">5.6.7</span> Exercises</a></li>
</ul></li>
<li><a href="#grouped-mutates-and-filters"><span class="toc-section-number">5.7</span> Grouped mutates (and filters)</a><ul>
<li><a href="#exercises-12"><span class="toc-section-number">5.7.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#workflow-scripts"><span class="toc-section-number">6</span> Workflow: scripts</a><ul>
<li><a href="#running-code"><span class="toc-section-number">6.1</span> Running code</a></li>
<li><a href="#rstudio-diagnostics"><span class="toc-section-number">6.2</span> RStudio diagnostics</a></li>
<li><a href="#practice-1"><span class="toc-section-number">6.3</span> Practice</a></li>
</ul></li>
<li><a href="#exploratory-data-analysis"><span class="toc-section-number">7</span> Exploratory Data Analysis</a><ul>
<li><a href="#introduction-3"><span class="toc-section-number">7.1</span> Introduction</a><ul>
<li><a href="#prerequisites-3"><span class="toc-section-number">7.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#questions"><span class="toc-section-number">7.2</span> Questions</a></li>
<li><a href="#variation"><span class="toc-section-number">7.3</span> Variation</a><ul>
<li><a href="#visualising-distributions"><span class="toc-section-number">7.3.1</span> Visualising distributions</a></li>
<li><a href="#typical-values"><span class="toc-section-number">7.3.2</span> Typical values</a></li>
<li><a href="#unusual-values"><span class="toc-section-number">7.3.3</span> Unusual values</a></li>
<li><a href="#exercises-13"><span class="toc-section-number">7.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#missing-values-2"><span class="toc-section-number">7.4</span> Missing values</a><ul>
<li><a href="#exercises-14"><span class="toc-section-number">7.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#covariation"><span class="toc-section-number">7.5</span> Covariation</a><ul>
<li><a href="#cat-cont"><span class="toc-section-number">7.5.1</span> A categorical and continuous variable</a></li>
<li><a href="#two-categorical-variables"><span class="toc-section-number">7.5.2</span> Two categorical variables</a></li>
<li><a href="#two-continuous-variables"><span class="toc-section-number">7.5.3</span> Two continuous variables</a></li>
</ul></li>
<li><a href="#patterns-and-models"><span class="toc-section-number">7.6</span> Patterns and models</a></li>
<li><a href="#ggplot2-calls"><span class="toc-section-number">7.7</span> ggplot2 calls</a></li>
<li><a href="#learning-more"><span class="toc-section-number">7.8</span> Learning more</a></li>
</ul></li>
<li><a href="#workflow-projects"><span class="toc-section-number">8</span> Workflow: projects</a><ul>
<li><a href="#what-is-real"><span class="toc-section-number">8.1</span> What is real?</a></li>
<li><a href="#where-does-your-analysis-live"><span class="toc-section-number">8.2</span> Where does your analysis live?</a></li>
<li><a href="#paths-and-directories"><span class="toc-section-number">8.3</span> Paths and directories</a></li>
<li><a href="#rstudio-projects"><span class="toc-section-number">8.4</span> RStudio projects</a></li>
<li><a href="#summary"><span class="toc-section-number">8.5</span> Summary</a></li>
</ul></li>
<li class="part"><span><b>II Wrangle</b></span></li>
<li><a href="#wrangle-intro"><span class="toc-section-number">9</span> Introduction</a></li>
<li><a href="#tibbles"><span class="toc-section-number">10</span> Tibbles</a><ul>
<li><a href="#introduction-4"><span class="toc-section-number">10.1</span> Introduction</a><ul>
<li><a href="#prerequisites-4"><span class="toc-section-number">10.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#tibbles"><span class="toc-section-number">10.2</span> Creating tibbles</a></li>
<li><a href="#tibbles-vs.data.frame"><span class="toc-section-number">10.3</span> Tibbles vs. data.frame</a><ul>
<li><a href="#printing"><span class="toc-section-number">10.3.1</span> Printing</a></li>
<li><a href="#subsetting"><span class="toc-section-number">10.3.2</span> Subsetting</a></li>
</ul></li>
<li><a href="#interacting-with-older-code"><span class="toc-section-number">10.4</span> Interacting with older code</a></li>
<li><a href="#exercises-18"><span class="toc-section-number">10.5</span> Exercises</a></li>
</ul></li>
<li><a href="#data-import"><span class="toc-section-number">11</span> Data import</a><ul>
<li><a href="#introduction-5"><span class="toc-section-number">11.1</span> Introduction</a><ul>
<li><a href="#prerequisites-5"><span class="toc-section-number">11.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#getting-started"><span class="toc-section-number">11.2</span> Getting started</a><ul>
<li><a href="#compared-to-base-r"><span class="toc-section-number">11.2.1</span> Compared to base R</a></li>
<li><a href="#exercises-19"><span class="toc-section-number">11.2.2</span> Exercises</a></li>
</ul></li>
<li><a href="#parsing-a-vector"><span class="toc-section-number">11.3</span> Parsing a vector</a><ul>
<li><a href="#numbers"><span class="toc-section-number">11.3.1</span> Numbers</a></li>
<li><a href="#readr-strings"><span class="toc-section-number">11.3.2</span> Strings</a></li>
<li><a href="#readr-factors"><span class="toc-section-number">11.3.3</span> Factors</a></li>
<li><a href="#readr-datetimes"><span class="toc-section-number">11.3.4</span> Dates, date-times, and times</a></li>
<li><a href="#exercises-20"><span class="toc-section-number">11.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#parsing-a-file"><span class="toc-section-number">11.4</span> Parsing a file</a><ul>
<li><a href="#strategy"><span class="toc-section-number">11.4.1</span> Strategy</a></li>
<li><a href="#problems"><span class="toc-section-number">11.4.2</span> Problems</a></li>
<li><a href="#other-strategies"><span class="toc-section-number">11.4.3</span> Other strategies</a></li>
</ul></li>
<li><a href="#writing-to-a-file"><span class="toc-section-number">11.5</span> Writing to a file</a></li>
<li><a href="#other-types-of-data"><span class="toc-section-number">11.6</span> Other types of data</a></li>
</ul></li>
<li><a href="#tidy-data"><span class="toc-section-number">12</span> Tidy data</a><ul>
<li><a href="#introduction-6"><span class="toc-section-number">12.1</span> Introduction</a><ul>
<li><a href="#prerequisites-6"><span class="toc-section-number">12.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#tidy-data-1"><span class="toc-section-number">12.2</span> Tidy data</a><ul>
<li><a href="#exercises-21"><span class="toc-section-number">12.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#spreading-and-gathering"><span class="toc-section-number">12.3</span> Spreading and gathering</a><ul>
<li><a href="#gathering"><span class="toc-section-number">12.3.1</span> Gathering</a></li>
<li><a href="#spreading"><span class="toc-section-number">12.3.2</span> Spreading</a></li>
<li><a href="#exercises-22"><span class="toc-section-number">12.3.3</span> Exercises</a></li>
</ul></li>
<li><a href="#separating-and-uniting"><span class="toc-section-number">12.4</span> Separating and uniting</a><ul>
<li><a href="#separate"><span class="toc-section-number">12.4.1</span> Separate</a></li>
<li><a href="#unite"><span class="toc-section-number">12.4.2</span> Unite</a></li>
<li><a href="#exercises-23"><span class="toc-section-number">12.4.3</span> Exercises</a></li>
</ul></li>
<li><a href="#missing-values-3"><span class="toc-section-number">12.5</span> Missing values</a><ul>
<li><a href="#exercises-24"><span class="toc-section-number">12.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#case-study"><span class="toc-section-number">12.6</span> Case Study</a><ul>
<li><a href="#exercises-25"><span class="toc-section-number">12.6.1</span> Exercises</a></li>
</ul></li>
<li><a href="#non-tidy-data"><span class="toc-section-number">12.7</span> Non-tidy data</a></li>
</ul></li>
<li><a href="#relational-data"><span class="toc-section-number">13</span> Relational data</a><ul>
<li><a href="#introduction-7"><span class="toc-section-number">13.1</span> Introduction</a><ul>
<li><a href="#prerequisites-7"><span class="toc-section-number">13.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#nycflights13-relational"><span class="toc-section-number">13.2</span> nycflights13</a><ul>
<li><a href="#exercises-26"><span class="toc-section-number">13.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#keys"><span class="toc-section-number">13.3</span> Keys</a><ul>
<li><a href="#exercises-27"><span class="toc-section-number">13.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#mutating-joins"><span class="toc-section-number">13.4</span> Mutating joins</a><ul>
<li><a href="#understanding-joins"><span class="toc-section-number">13.4.1</span> Understanding joins</a></li>
<li><a href="#inner-join"><span class="toc-section-number">13.4.2</span> Inner join</a></li>
<li><a href="#outer-join"><span class="toc-section-number">13.4.3</span> Outer joins</a></li>
<li><a href="#join-matches"><span class="toc-section-number">13.4.4</span> Duplicate keys</a></li>
<li><a href="#join-by"><span class="toc-section-number">13.4.5</span> Defining the key columns</a></li>
<li><a href="#exercises-28"><span class="toc-section-number">13.4.6</span> Exercises</a></li>
<li><a href="#other-implementations"><span class="toc-section-number">13.4.7</span> Other implementations</a></li>
</ul></li>
<li><a href="#filtering-joins"><span class="toc-section-number">13.5</span> Filtering joins</a><ul>
<li><a href="#exercises-29"><span class="toc-section-number">13.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#join-problems"><span class="toc-section-number">13.6</span> Join problems</a></li>
<li><a href="#set-operations"><span class="toc-section-number">13.7</span> Set operations</a></li>
</ul></li>
<li><a href="#strings"><span class="toc-section-number">14</span> Strings</a><ul>
<li><a href="#introduction-8"><span class="toc-section-number">14.1</span> Introduction</a><ul>
<li><a href="#prerequisites-8"><span class="toc-section-number">14.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#string-basics"><span class="toc-section-number">14.2</span> String basics</a><ul>
<li><a href="#string-length"><span class="toc-section-number">14.2.1</span> String length</a></li>
<li><a href="#combining-strings"><span class="toc-section-number">14.2.2</span> Combining strings</a></li>
<li><a href="#subsetting-strings"><span class="toc-section-number">14.2.3</span> Subsetting strings</a></li>
<li><a href="#locales"><span class="toc-section-number">14.2.4</span> Locales</a></li>
<li><a href="#exercises-30"><span class="toc-section-number">14.2.5</span> Exercises</a></li>
</ul></li>
<li><a href="#matching-patterns-with-regular-expressions"><span class="toc-section-number">14.3</span> Matching patterns with regular expressions</a><ul>
<li><a href="#basic-matches"><span class="toc-section-number">14.3.1</span> Basic matches</a></li>
<li><a href="#anchors"><span class="toc-section-number">14.3.2</span> Anchors</a></li>
<li><a href="#character-classes-and-alternatives"><span class="toc-section-number">14.3.3</span> Character classes and alternatives</a></li>
<li><a href="#repetition"><span class="toc-section-number">14.3.4</span> Repetition</a></li>
<li><a href="#grouping-and-backreferences"><span class="toc-section-number">14.3.5</span> Grouping and backreferences</a></li>
</ul></li>
<li><a href="#tools"><span class="toc-section-number">14.4</span> Tools</a><ul>
<li><a href="#detect-matches"><span class="toc-section-number">14.4.1</span> Detect matches</a></li>
<li><a href="#extract-matches"><span class="toc-section-number">14.4.2</span> Extract matches</a></li>
<li><a href="#grouped-matches"><span class="toc-section-number">14.4.3</span> Grouped matches</a></li>
<li><a href="#replacing-matches"><span class="toc-section-number">14.4.4</span> Replacing matches</a></li>
<li><a href="#splitting"><span class="toc-section-number">14.4.5</span> Splitting</a></li>
<li><a href="#find-matches"><span class="toc-section-number">14.4.6</span> Find matches</a></li>
</ul></li>
<li><a href="#other-types-of-pattern"><span class="toc-section-number">14.5</span> Other types of pattern</a><ul>
<li><a href="#exercises-41"><span class="toc-section-number">14.5.1</span> Exercises</a></li>
</ul></li>
<li><a href="#other-uses-of-regular-expressions"><span class="toc-section-number">14.6</span> Other uses of regular expressions</a></li>
<li><a href="#stringi"><span class="toc-section-number">14.7</span> stringi</a><ul>
<li><a href="#exercises-42"><span class="toc-section-number">14.7.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#factors"><span class="toc-section-number">15</span> Factors</a><ul>
<li><a href="#introduction-9"><span class="toc-section-number">15.1</span> Introduction</a><ul>
<li><a href="#prerequisites-9"><span class="toc-section-number">15.1.1</span> Prerequisites</a></li>
<li><a href="#learning-more-1"><span class="toc-section-number">15.1.2</span> Learning more</a></li>
</ul></li>
<li><a href="#creating-factors"><span class="toc-section-number">15.2</span> Creating factors</a></li>
<li><a href="#general-social-survey"><span class="toc-section-number">15.3</span> General Social Survey</a><ul>
<li><a href="#exercise"><span class="toc-section-number">15.3.1</span> Exercise</a></li>
</ul></li>
<li><a href="#modifying-factor-order"><span class="toc-section-number">15.4</span> Modifying factor order</a><ul>
<li><a href="#exercises-43"><span class="toc-section-number">15.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#modifying-factor-levels"><span class="toc-section-number">15.5</span> Modifying factor levels</a><ul>
<li><a href="#exercises-44"><span class="toc-section-number">15.5.1</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#dates-and-times"><span class="toc-section-number">16</span> Dates and times</a><ul>
<li><a href="#introduction-10"><span class="toc-section-number">16.1</span> Introduction</a><ul>
<li><a href="#prerequisites-10"><span class="toc-section-number">16.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#creating-datetimes"><span class="toc-section-number">16.2</span> Creating date/times</a><ul>
<li><a href="#from-strings"><span class="toc-section-number">16.2.1</span> From strings</a></li>
<li><a href="#from-individual-components"><span class="toc-section-number">16.2.2</span> From individual components</a></li>
<li><a href="#from-other-types"><span class="toc-section-number">16.2.3</span> From other types</a></li>
<li><a href="#exercises-45"><span class="toc-section-number">16.2.4</span> Exercises</a></li>
</ul></li>
<li><a href="#date-time-components"><span class="toc-section-number">16.3</span> Date-time components</a><ul>
<li><a href="#getting-components"><span class="toc-section-number">16.3.1</span> Getting components</a></li>
<li><a href="#rounding"><span class="toc-section-number">16.3.2</span> Rounding</a></li>
<li><a href="#setting-components"><span class="toc-section-number">16.3.3</span> Setting components</a></li>
<li><a href="#exercises-46"><span class="toc-section-number">16.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#time-spans"><span class="toc-section-number">16.4</span> Time spans</a><ul>
<li><a href="#durations"><span class="toc-section-number">16.4.1</span> Durations</a></li>
<li><a href="#periods"><span class="toc-section-number">16.4.2</span> Periods</a></li>
<li><a href="#intervals"><span class="toc-section-number">16.4.3</span> Intervals</a></li>
<li><a href="#summary-1"><span class="toc-section-number">16.4.4</span> Summary</a></li>
<li><a href="#exercises-47"><span class="toc-section-number">16.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#time-zones"><span class="toc-section-number">16.5</span> Time zones</a></li>
</ul></li>
<li class="part"><span><b>III Program</b></span></li>
<li><a href="#program-intro"><span class="toc-section-number">17</span> Introduction</a><ul>
<li><a href="#learning-more-2"><span class="toc-section-number">17.1</span> Learning more</a></li>
</ul></li>
<li><a href="#pipes"><span class="toc-section-number">18</span> Pipes</a><ul>
<li><a href="#introduction-11"><span class="toc-section-number">18.1</span> Introduction</a><ul>
<li><a href="#prerequisites-11"><span class="toc-section-number">18.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#piping-alternatives"><span class="toc-section-number">18.2</span> Piping alternatives</a><ul>
<li><a href="#intermediate-steps"><span class="toc-section-number">18.2.1</span> Intermediate steps</a></li>
<li><a href="#overwrite-the-original"><span class="toc-section-number">18.2.2</span> Overwrite the original</a></li>
<li><a href="#function-composition"><span class="toc-section-number">18.2.3</span> Function composition</a></li>
<li><a href="#use-the-pipe"><span class="toc-section-number">18.2.4</span> Use the pipe</a></li>
</ul></li>
<li><a href="#when-not-to-use-the-pipe"><span class="toc-section-number">18.3</span> When not to use the pipe</a></li>
<li><a href="#other-tools-from-magrittr"><span class="toc-section-number">18.4</span> Other tools from magrittr</a></li>
</ul></li>
<li><a href="#functions"><span class="toc-section-number">19</span> Functions</a><ul>
<li><a href="#introduction-12"><span class="toc-section-number">19.1</span> Introduction</a><ul>
<li><a href="#prerequisites-12"><span class="toc-section-number">19.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#when-should-you-write-a-function"><span class="toc-section-number">19.2</span> When should you write a function?</a><ul>
<li><a href="#practice-2"><span class="toc-section-number">19.2.1</span> Practice</a></li>
</ul></li>
<li><a href="#functions-are-for-humans-and-computers"><span class="toc-section-number">19.3</span> Functions are for humans and computers</a><ul>
<li><a href="#exercises-48"><span class="toc-section-number">19.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#conditional-execution"><span class="toc-section-number">19.4</span> Conditional execution</a><ul>
<li><a href="#conditions"><span class="toc-section-number">19.4.1</span> Conditions</a></li>
<li><a href="#multiple-conditions"><span class="toc-section-number">19.4.2</span> Multiple conditions</a></li>
<li><a href="#code-style"><span class="toc-section-number">19.4.3</span> Code style</a></li>
<li><a href="#exercises-49"><span class="toc-section-number">19.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#function-arguments"><span class="toc-section-number">19.5</span> Function arguments</a><ul>
<li><a href="#choosing-names"><span class="toc-section-number">19.5.1</span> Choosing names</a></li>
<li><a href="#checking-values"><span class="toc-section-number">19.5.2</span> Checking values</a></li>
<li><a href="#dot-dot-dot"><span class="toc-section-number">19.5.3</span> Dot-dot-dot (…)</a></li>
<li><a href="#lazy-evaluation"><span class="toc-section-number">19.5.4</span> Lazy evaluation</a></li>
<li><a href="#exercises-50"><span class="toc-section-number">19.5.5</span> Exercises</a></li>
</ul></li>
<li><a href="#return-values"><span class="toc-section-number">19.6</span> Return values</a><ul>
<li><a href="#explicit-return-statements"><span class="toc-section-number">19.6.1</span> Explicit return statements</a></li>
<li><a href="#writing-pipeable-functions"><span class="toc-section-number">19.6.2</span> Writing pipeable functions</a></li>
</ul></li>
<li><a href="#environment"><span class="toc-section-number">19.7</span> Environment</a></li>
</ul></li>
<li><a href="#vectors"><span class="toc-section-number">20</span> Vectors</a><ul>
<li><a href="#introduction-13"><span class="toc-section-number">20.1</span> Introduction</a><ul>
<li><a href="#prerequisites-13"><span class="toc-section-number">20.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#vector-basics"><span class="toc-section-number">20.2</span> Vector basics</a></li>
<li><a href="#important-types-of-atomic-vector"><span class="toc-section-number">20.3</span> Important types of atomic vector</a><ul>
<li><a href="#logical"><span class="toc-section-number">20.3.1</span> Logical</a></li>
<li><a href="#numeric"><span class="toc-section-number">20.3.2</span> Numeric</a></li>
<li><a href="#character"><span class="toc-section-number">20.3.3</span> Character</a></li>
<li><a href="#missing-values-4"><span class="toc-section-number">20.3.4</span> Missing values</a></li>
<li><a href="#exercises-51"><span class="toc-section-number">20.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#using-atomic-vectors"><span class="toc-section-number">20.4</span> Using atomic vectors</a><ul>
<li><a href="#coercion"><span class="toc-section-number">20.4.1</span> Coercion</a></li>
<li><a href="#test-functions"><span class="toc-section-number">20.4.2</span> Test functions</a></li>
<li><a href="#scalars-and-recycling-rules"><span class="toc-section-number">20.4.3</span> Scalars and recycling rules</a></li>
<li><a href="#naming-vectors"><span class="toc-section-number">20.4.4</span> Naming vectors</a></li>
<li><a href="#vector-subsetting"><span class="toc-section-number">20.4.5</span> Subsetting</a></li>
<li><a href="#exercises-52"><span class="toc-section-number">20.4.6</span> Exercises</a></li>
</ul></li>
<li><a href="#lists"><span class="toc-section-number">20.5</span> Recursive vectors (lists)</a><ul>
<li><a href="#visualising-lists"><span class="toc-section-number">20.5.1</span> Visualising lists</a></li>
<li><a href="#subsetting-1"><span class="toc-section-number">20.5.2</span> Subsetting</a></li>
<li><a href="#lists-of-condiments"><span class="toc-section-number">20.5.3</span> Lists of condiments</a></li>
<li><a href="#exercises-53"><span class="toc-section-number">20.5.4</span> Exercises</a></li>
</ul></li>
<li><a href="#attributes"><span class="toc-section-number">20.6</span> Attributes</a></li>
<li><a href="#augmented-vectors"><span class="toc-section-number">20.7</span> Augmented vectors</a><ul>
<li><a href="#factors-1"><span class="toc-section-number">20.7.1</span> Factors</a></li>
<li><a href="#dates-and-date-times"><span class="toc-section-number">20.7.2</span> Dates and date-times</a></li>
<li><a href="#tibbles-1"><span class="toc-section-number">20.7.3</span> Tibbles</a></li>
<li><a href="#exercises-54"><span class="toc-section-number">20.7.4</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#iteration"><span class="toc-section-number">21</span> Iteration</a><ul>
<li><a href="#introduction-14"><span class="toc-section-number">21.1</span> Introduction</a><ul>
<li><a href="#prerequisites-14"><span class="toc-section-number">21.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#for-loops"><span class="toc-section-number">21.2</span> For loops</a><ul>
<li><a href="#exercises-55"><span class="toc-section-number">21.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#for-loop-variations"><span class="toc-section-number">21.3</span> For loop variations</a><ul>
<li><a href="#modifying-an-existing-object"><span class="toc-section-number">21.3.1</span> Modifying an existing object</a></li>
<li><a href="#looping-patterns"><span class="toc-section-number">21.3.2</span> Looping patterns</a></li>
<li><a href="#unknown-output-length"><span class="toc-section-number">21.3.3</span> Unknown output length</a></li>
<li><a href="#unknown-sequence-length"><span class="toc-section-number">21.3.4</span> Unknown sequence length</a></li>
<li><a href="#exercises-56"><span class="toc-section-number">21.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#for-loops-vs.functionals"><span class="toc-section-number">21.4</span> For loops vs. functionals</a><ul>
<li><a href="#exercises-57"><span class="toc-section-number">21.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#the-map-functions"><span class="toc-section-number">21.5</span> The map functions</a><ul>
<li><a href="#shortcuts"><span class="toc-section-number">21.5.1</span> Shortcuts</a></li>
<li><a href="#base-r"><span class="toc-section-number">21.5.2</span> Base R</a></li>
<li><a href="#exercises-58"><span class="toc-section-number">21.5.3</span> Exercises</a></li>
</ul></li>
<li><a href="#dealing-with-failure"><span class="toc-section-number">21.6</span> Dealing with failure</a></li>
<li><a href="#mapping-over-multiple-arguments"><span class="toc-section-number">21.7</span> Mapping over multiple arguments</a><ul>
<li><a href="#invoking-different-functions"><span class="toc-section-number">21.7.1</span> Invoking different functions</a></li>
</ul></li>
<li><a href="#walk"><span class="toc-section-number">21.8</span> Walk</a></li>
<li><a href="#other-patterns-of-for-loops"><span class="toc-section-number">21.9</span> Other patterns of for loops</a><ul>
<li><a href="#predicate-functions"><span class="toc-section-number">21.9.1</span> Predicate functions</a></li>
<li><a href="#reduce-and-accumulate"><span class="toc-section-number">21.9.2</span> Reduce and accumulate</a></li>
<li><a href="#exercises-59"><span class="toc-section-number">21.9.3</span> Exercises</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV Model</b></span></li>
<li><a href="#model-intro"><span class="toc-section-number">22</span> Introduction</a><ul>
<li><a href="#hypothesis-generation-vs.hypothesis-confirmation"><span class="toc-section-number">22.1</span> Hypothesis generation vs. hypothesis confirmation</a></li>
</ul></li>
<li><a href="#model-basics"><span class="toc-section-number">23</span> Model basics</a><ul>
<li><a href="#introduction-15"><span class="toc-section-number">23.1</span> Introduction</a><ul>
<li><a href="#prerequisites-15"><span class="toc-section-number">23.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#a-simple-model"><span class="toc-section-number">23.2</span> A simple model</a><ul>
<li><a href="#exercises-60"><span class="toc-section-number">23.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#visualising-models"><span class="toc-section-number">23.3</span> Visualising models</a><ul>
<li><a href="#predictions"><span class="toc-section-number">23.3.1</span> Predictions</a></li>
<li><a href="#residuals"><span class="toc-section-number">23.3.2</span> Residuals</a></li>
<li><a href="#exercises-61"><span class="toc-section-number">23.3.3</span> Exercises</a></li>
</ul></li>
<li><a href="#formulas-and-model-families"><span class="toc-section-number">23.4</span> Formulas and model families</a><ul>
<li><a href="#categorical-variables"><span class="toc-section-number">23.4.1</span> Categorical variables</a></li>
<li><a href="#interactions-continuous-and-categorical"><span class="toc-section-number">23.4.2</span> Interactions (continuous and categorical)</a></li>
<li><a href="#interactions-two-continuous"><span class="toc-section-number">23.4.3</span> Interactions (two continuous)</a></li>
<li><a href="#transformations"><span class="toc-section-number">23.4.4</span> Transformations</a></li>
<li><a href="#exercises-62"><span class="toc-section-number">23.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#missing-values-5"><span class="toc-section-number">23.5</span> Missing values</a></li>
<li><a href="#other-model-families"><span class="toc-section-number">23.6</span> Other model families</a></li>
</ul></li>
<li><a href="#model-building"><span class="toc-section-number">24</span> Model building</a><ul>
<li><a href="#introduction-16"><span class="toc-section-number">24.1</span> Introduction</a><ul>
<li><a href="#prerequisites-16"><span class="toc-section-number">24.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#diamond-prices"><span class="toc-section-number">24.2</span> Why are low quality diamonds more expensive?</a><ul>
<li><a href="#price-and-carat"><span class="toc-section-number">24.2.1</span> Price and carat</a></li>
<li><a href="#a-more-complicated-model"><span class="toc-section-number">24.2.2</span> A more complicated model</a></li>
<li><a href="#exercises-63"><span class="toc-section-number">24.2.3</span> Exercises</a></li>
</ul></li>
<li><a href="#what-affects-the-number-of-daily-flights"><span class="toc-section-number">24.3</span> What affects the number of daily flights?</a><ul>
<li><a href="#day-of-week"><span class="toc-section-number">24.3.1</span> Day of week</a></li>
<li><a href="#seasonal-saturday-effect"><span class="toc-section-number">24.3.2</span> Seasonal Saturday effect</a></li>
<li><a href="#computed-variables"><span class="toc-section-number">24.3.3</span> Computed variables</a></li>
<li><a href="#time-of-year-an-alternative-approach"><span class="toc-section-number">24.3.4</span> Time of year: an alternative approach</a></li>
<li><a href="#exercises-64"><span class="toc-section-number">24.3.5</span> Exercises</a></li>
</ul></li>
<li><a href="#learning-more-about-models"><span class="toc-section-number">24.4</span> Learning more about models</a></li>
</ul></li>
<li><a href="#many-models"><span class="toc-section-number">25</span> Many models</a><ul>
<li><a href="#introduction-17"><span class="toc-section-number">25.1</span> Introduction</a><ul>
<li><a href="#prerequisites-17"><span class="toc-section-number">25.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#gapminder"><span class="toc-section-number">25.2</span> gapminder</a><ul>
<li><a href="#nested-data"><span class="toc-section-number">25.2.1</span> Nested data</a></li>
<li><a href="#list-columns"><span class="toc-section-number">25.2.2</span> List-columns</a></li>
<li><a href="#unnesting"><span class="toc-section-number">25.2.3</span> Unnesting</a></li>
<li><a href="#model-quality"><span class="toc-section-number">25.2.4</span> Model quality</a></li>
<li><a href="#exercises-65"><span class="toc-section-number">25.2.5</span> Exercises</a></li>
</ul></li>
<li><a href="#list-columns-1"><span class="toc-section-number">25.3</span> List-columns</a></li>
<li><a href="#creating-list-columns"><span class="toc-section-number">25.4</span> Creating list-columns</a><ul>
<li><a href="#with-nesting"><span class="toc-section-number">25.4.1</span> With nesting</a></li>
<li><a href="#from-vectorised-functions"><span class="toc-section-number">25.4.2</span> From vectorised functions</a></li>
<li><a href="#from-multivalued-summaries"><span class="toc-section-number">25.4.3</span> From multivalued summaries</a></li>
<li><a href="#from-a-named-list"><span class="toc-section-number">25.4.4</span> From a named list</a></li>
<li><a href="#exercises-66"><span class="toc-section-number">25.4.5</span> Exercises</a></li>
</ul></li>
<li><a href="#simplifying-list-columns"><span class="toc-section-number">25.5</span> Simplifying list-columns</a><ul>
<li><a href="#list-to-vector"><span class="toc-section-number">25.5.1</span> List to vector</a></li>
<li><a href="#unnesting-1"><span class="toc-section-number">25.5.2</span> Unnesting</a></li>
<li><a href="#exercises-67"><span class="toc-section-number">25.5.3</span> Exercises</a></li>
</ul></li>
<li><a href="#making-tidy-data-with-broom"><span class="toc-section-number">25.6</span> Making tidy data with broom</a></li>
</ul></li>
<li class="part"><span><b>V Communicate</b></span></li>
<li><a href="#communicate-intro"><span class="toc-section-number">26</span> Introduction</a></li>
<li><a href="#r-markdown"><span class="toc-section-number">27</span> R Markdown</a><ul>
<li><a href="#introduction-18"><span class="toc-section-number">27.1</span> Introduction</a><ul>
<li><a href="#prerequisites-18"><span class="toc-section-number">27.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#r-markdown-basics"><span class="toc-section-number">27.2</span> R Markdown basics</a><ul>
<li><a href="#exercises-68"><span class="toc-section-number">27.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#text-formatting-with-markdown"><span class="toc-section-number">27.3</span> Text formatting with Markdown</a><ul>
<li><a href="#exercises-69"><span class="toc-section-number">27.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#code-chunks"><span class="toc-section-number">27.4</span> Code chunks</a><ul>
<li><a href="#chunk-name"><span class="toc-section-number">27.4.1</span> Chunk name</a></li>
<li><a href="#chunk-options"><span class="toc-section-number">27.4.2</span> Chunk options</a></li>
<li><a href="#table"><span class="toc-section-number">27.4.3</span> Table</a></li>
<li><a href="#caching"><span class="toc-section-number">27.4.4</span> Caching</a></li>
<li><a href="#global-options"><span class="toc-section-number">27.4.5</span> Global options</a></li>
<li><a href="#inline-code"><span class="toc-section-number">27.4.6</span> Inline code</a></li>
<li><a href="#exercises-70"><span class="toc-section-number">27.4.7</span> Exercises</a></li>
</ul></li>
<li><a href="#troubleshooting"><span class="toc-section-number">27.5</span> Troubleshooting</a></li>
<li><a href="#yaml-header"><span class="toc-section-number">27.6</span> YAML header</a><ul>
<li><a href="#parameters"><span class="toc-section-number">27.6.1</span> Parameters</a></li>
<li><a href="#bibliographies-and-citations"><span class="toc-section-number">27.6.2</span> Bibliographies and Citations</a></li>
</ul></li>
<li><a href="#learning-more-3"><span class="toc-section-number">27.7</span> Learning more</a></li>
</ul></li>
<li><a href="#graphics-for-communication"><span class="toc-section-number">28</span> Graphics for communication</a><ul>
<li><a href="#introduction-19"><span class="toc-section-number">28.1</span> Introduction</a><ul>
<li><a href="#prerequisites-19"><span class="toc-section-number">28.1.1</span> Prerequisites</a></li>
</ul></li>
<li><a href="#label"><span class="toc-section-number">28.2</span> Label</a><ul>
<li><a href="#exercises-71"><span class="toc-section-number">28.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#annotations"><span class="toc-section-number">28.3</span> Annotations</a><ul>
<li><a href="#exercises-72"><span class="toc-section-number">28.3.1</span> Exercises</a></li>
</ul></li>
<li><a href="#scales"><span class="toc-section-number">28.4</span> Scales</a><ul>
<li><a href="#axis-ticks-and-legend-keys"><span class="toc-section-number">28.4.1</span> Axis ticks and legend keys</a></li>
<li><a href="#legend-layout"><span class="toc-section-number">28.4.2</span> Legend layout</a></li>
<li><a href="#replacing-a-scale"><span class="toc-section-number">28.4.3</span> Replacing a scale</a></li>
<li><a href="#exercises-73"><span class="toc-section-number">28.4.4</span> Exercises</a></li>
</ul></li>
<li><a href="#zooming"><span class="toc-section-number">28.5</span> Zooming</a></li>
<li><a href="#themes"><span class="toc-section-number">28.6</span> Themes</a></li>
<li><a href="#saving-your-plots"><span class="toc-section-number">28.7</span> Saving your plots</a><ul>
<li><a href="#figure-sizing"><span class="toc-section-number">28.7.1</span> Figure sizing</a></li>
<li><a href="#other-important-options"><span class="toc-section-number">28.7.2</span> Other important options</a></li>
</ul></li>
<li><a href="#learning-more-4"><span class="toc-section-number">28.8</span> Learning more</a></li>
</ul></li>
<li><a href="#r-markdown-formats"><span class="toc-section-number">29</span> R Markdown formats</a><ul>
<li><a href="#introduction-20"><span class="toc-section-number">29.1</span> Introduction</a></li>
<li><a href="#output-options"><span class="toc-section-number">29.2</span> Output options</a></li>
<li><a href="#documents"><span class="toc-section-number">29.3</span> Documents</a></li>
<li><a href="#notebooks"><span class="toc-section-number">29.4</span> Notebooks</a></li>
<li><a href="#presentations"><span class="toc-section-number">29.5</span> Presentations</a></li>
<li><a href="#dashboards"><span class="toc-section-number">29.6</span> Dashboards</a></li>
<li><a href="#interactivity"><span class="toc-section-number">29.7</span> Interactivity</a><ul>
<li><a href="#htmlwidgets"><span class="toc-section-number">29.7.1</span> htmlwidgets</a></li>
<li><a href="#shiny"><span class="toc-section-number">29.7.2</span> Shiny</a></li>
</ul></li>
<li><a href="#websites"><span class="toc-section-number">29.8</span> Websites</a></li>
<li><a href="#other-formats"><span class="toc-section-number">29.9</span> Other formats</a></li>
<li><a href="#learning-more-5"><span class="toc-section-number">29.10</span> Learning more</a></li>
</ul></li>
<li><a href="#r-markdown-workflow"><span class="toc-section-number">30</span> R Markdown workflow</a></li>
</ul>
</div>
</div>

<!--chapter:end:index.rmd-->
<div id="introduction" class="section level1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p>Data science is an exciting discipline that allows you to turn raw data into understanding, insight, and knowledge. The goal of “R for Data Science” is to help you learn the most important tools in R that will allow you to do data science. After reading this book, you’ll have the tools to tackle a wide variety of data science challenges, using the best parts of R.</p>
<div id="what-you-will-learn" class="section level2">
<h2><span class="header-section-number">1.1</span> What you will learn</h2>
<p>Data science is a huge field, and there’s no way you can master it by reading a single book. The goal of this book is to give you a solid foundation in the most important tools. Our model of the tools needed in a typical data science project looks something like this:</p>
<p><img src="diagrams/data-science.png" width="75%" style="display: block; margin: auto;" /></p>
<p>First you must <strong>import</strong> your data into R. This typically means that you take data stored in a file, database, or web API, and load it into a data frame in R. If you can’t get your data into R, you can’t do data science on it!</p>
<p>Once you’ve imported your data, it is a good idea to <strong>tidy</strong> it. Tidying your data means storing it in a consistent form that matches the semantics of the dataset with the way it is stored. In brief, when your data is tidy, each column is a variable, and each row is an observation. Tidy data is important because the consistent structure lets you focus your struggle on questions about the data, not fighting to get the data into the right form for different functions.</p>
<p>Once you have tidy data, a common first step is to <strong>transform</strong> it. Transformation includes narrowing in on observations of interest (like all people in one city, or all data from the last year), creating new variables that are functions of existing variables (like computing speed from distance and time), and calculating a set of summary statistics (like counts or means). Together, tidying and transforming are called <strong>wrangling</strong>, because getting your data in a form that’s natural to work with often feels like a fight!</p>
<p>Once you have tidy data with the variables you need, there are two main engines of knowledge generation: visualisation and modelling. These have complementary strengths and weaknesses so any real analysis will iterate between them many times.</p>
<p><strong>Visualisation</strong> is a fundamentally human activity. A good visualisation will show you things that you did not expect, or raise new questions about the data. A good visualisation might also hint that you’re asking the wrong question, or you need to collect different data. Visualisations can surprise you, but don’t scale particularly well because they require a human to interpret them.</p>
<p><strong>Models</strong> are complementary tools to visualisation. Once you have made your questions sufficiently precise, you can use a model to answer them. Models are a fundamentally mathematical or computational tool, so they generally scale well. Even when they don’t, it’s usually cheaper to buy more computers than it is to buy more brains! But every model makes assumptions, and by its very nature a model cannot question its own assumptions. That means a model cannot fundamentally surprise you.</p>
<p>The last step of data science is <strong>communication</strong>, an absolutely critical part of any data analysis project. It doesn’t matter how well your models and visualisation have led you to understand the data unless you can also communicate your results to others.</p>
<p>Surrounding all these tools is <strong>programming</strong>. Programming is a cross-cutting tool that you use in every part of the project. You don’t need to be an expert programmer to be a data scientist, but learning more about programming pays off because becoming a better programmer allows you to automate common tasks, and solve new problems with greater ease.</p>
<p>You’ll use these tools in every data science project, but for most projects they’re not enough. There’s a rough 80-20 rule at play; you can tackle about 80% of every project using the tools that you’ll learn in this book, but you’ll need other tools to tackle the remaining 20%. Throughout this book we’ll point you to resources where you can learn more.</p>
</div>
<div id="how-this-book-is-organised" class="section level2">
<h2><span class="header-section-number">1.2</span> How this book is organised</h2>
<p>The previous description of the tools of data science is organised roughly according to the order in which you use them in an analysis (although of course you’ll iterate through them multiple times). In our experience, however, this is not the best way to learn them:</p>
<ul>
<li><p>Starting with data ingest and tidying is sub-optimal because 80% of the time
it’s routine and boring, and the other 20% of the time it’s weird and
frustrating. That’s a bad place to start learning a new subject! Instead,
we’ll start with visualisation and transformation of data that’s already been
imported and tidied. That way, when you ingest and tidy your own data, your
motivation will stay high because you know the pain is worth it.</p></li>
<li><p>Some topics are best explained with other tools. For example, we believe that
it’s easier to understand how models work if you already know about
visualisation, tidy data, and programming.</p></li>
<li><p>Programming tools are not necessarily interesting in their own right,
but do allow you to tackle considerably more challenging problems. We’ll
give you a selection of programming tools in the middle of the book, and
then you’ll see how they can combine with the data science tools to tackle
interesting modelling problems.</p></li>
</ul>
<p>Within each chapter, we try and stick to a similar pattern: start with some motivating examples so you can see the bigger picture, and then dive into the details. Each section of the book is paired with exercises to help you practice what you’ve learned. While it’s tempting to skip the exercises, there’s no better way to learn than practicing on real problems.</p>
</div>
<div id="what-you-wont-learn" class="section level2">
<h2><span class="header-section-number">1.3</span> What you won’t learn</h2>
<p>There are some important topics that this book doesn’t cover. We believe it’s important to stay ruthlessly focused on the essentials so you can get up and running as quickly as possible. That means this book can’t cover every important topic.</p>
<div id="big-data" class="section level3">
<h3><span class="header-section-number">1.3.1</span> Big data</h3>
<p>This book proudly focuses on small, in-memory datasets. This is the right place to start because you can’t tackle big data unless you have experience with small data. The tools you learn in this book will easily handle hundreds of megabytes of data, and with a little care you can typically use them to work with 1-2 Gb of data. If you’re routinely working with larger data (10-100 Gb, say), you should learn more about data.table<span id="fn1" class="footnote" data-pagedown-footnote-number="1" style="white-space: pre-line;"><a href="https://github.com/Rdatatable/data.table" class="uri">https://github.com/Rdatatable/data.table</a></span>. This book doesn’t teach data.table because it has a very concise interface which makes it harder to learn since it offers fewer linguistic cues. But if you’re working with large data, the performance payoff is worth the extra effort required to learn it.</p>
<p>If your data is bigger than this, carefully consider if your big data problem might actually be a small data problem in disguise. While the complete data might be big, often the data needed to answer a specific question is small. You might be able to find a subset, subsample, or summary that fits in memory and still allows you to answer the question that you’re interested in. The challenge here is finding the right small data, which often requires a lot of iteration.</p>
<p>Another possibility is that your big data problem is actually a large number of small data problems. Each individual problem might fit in memory, but you have millions of them. For example, you might want to fit a model to each person in your dataset. That would be trivial if you had just 10 or 100 people, but instead you have a million. Fortunately each problem is independent of the others (a setup that is sometimes called embarrassingly parallel), so you just need a system (like Hadoop or Spark) that allows you to send different datasets to different computers for processing. Once you’ve figured out how to answer the question for a single subset using the tools described in this book, you learn new tools like sparklyr, rhipe, and ddr to solve it for the full dataset.</p>
</div>
<div id="python-julia-and-friends" class="section level3">
<h3><span class="header-section-number">1.3.2</span> Python, Julia, and friends</h3>
<p>In this book, you won’t learn anything about Python, Julia, or any other programming language useful for data science. This isn’t because we think these tools are bad. They’re not! And in practice, most data science teams use a mix of languages, often at least R and Python.</p>
<p>However, we strongly believe that it’s best to master one tool at a time. You will get better faster if you dive deep, rather than spreading yourself thinly over many topics. This doesn’t mean you should only know one thing, just that you’ll generally learn faster if you stick to one thing at a time. You should strive to learn new things throughout your career, but make sure your understanding is solid before you move on to the next interesting thing.</p>
<p>We think R is a great place to start your data science journey because it is an environment designed from the ground up to support data science. R is not just a programming language, but it is also an interactive environment for doing data science. To support interaction, R is a much more flexible language than many of its peers. This flexibility comes with its downsides, but the big upside is how easy it is to evolve tailored grammars for specific parts of the data science process. These mini languages help you think about problems as a data scientist, while supporting fluent interaction between your brain and the computer.</p>
</div>
<div id="non-rectangular-data" class="section level3">
<h3><span class="header-section-number">1.3.3</span> Non-rectangular data</h3>
<p>This book focuses exclusively on rectangular data: collections of values that are each associated with a variable and an observation. There are lots of datasets that do not naturally fit in this paradigm: including images, sounds, trees, and text. But rectangular data frames are extremely common in science and industry, and we believe that they are a great place to start your data science journey.</p>
</div>
<div id="hypothesis-confirmation" class="section level3">
<h3><span class="header-section-number">1.3.4</span> Hypothesis confirmation</h3>
<p>It’s possible to divide data analysis into two camps: hypothesis generation and hypothesis confirmation (sometimes called confirmatory analysis). The focus of this book is unabashedly on hypothesis generation, or data exploration. Here you’ll look deeply at the data and, in combination with your subject knowledge, generate many interesting hypotheses to help explain why the data behaves the way it does. You evaluate the hypotheses informally, using your scepticism to challenge the data in multiple ways.</p>
<p>The complement of hypothesis generation is hypothesis confirmation. Hypothesis confirmation is hard for two reasons:</p>
<ol style="list-style-type: decimal">
<li><p>You need a precise mathematical model in order to generate falsifiable
predictions. This often requires considerable statistical sophistication.</p></li>
<li><p>You can only use an observation once to confirm a hypothesis. As soon as
you use it more than once you’re back to doing exploratory analysis.
This means to do hypothesis confirmation you need to “preregister”
(write out in advance) your analysis plan, and not deviate from it
even when you have seen the data. We’ll talk a little about some
strategies you can use to make this easier in <a href="#model-intro">modelling</a>.</p></li>
</ol>
<p>It’s common to think about modelling as a tool for hypothesis confirmation, and visualisation as a tool for hypothesis generation. But that’s a false dichotomy: models are often used for exploration, and with a little care you can use visualisation for confirmation. The key difference is how often do you look at each observation: if you look only once, it’s confirmation; if you look more than once, it’s exploration.</p>
</div>
</div>
<div id="prerequisites" class="section level2">
<h2><span class="header-section-number">1.4</span> Prerequisites</h2>
<p>We’ve made a few assumptions about what you already know in order to get the most out of this book. You should be generally numerically literate, and it’s helpful if you have some programming experience already. If you’ve never programmed before, you might find Hands on Programming with R<span id="fn2" class="footnote" data-pagedown-footnote-number="2" style="white-space: pre-line;"><a href="http://amzn.com/1449359019" class="uri">http://amzn.com/1449359019</a></span> by Garrett to be a useful adjunct to this book.</p>
<p>There are four things you need to run the code in this book: R, RStudio, a collection of R packages called the <strong>tidyverse</strong>, and a handful of other packages. Packages are the fundamental units of reproducible R code. They include reusable functions, the documentation that describes how to use them, and sample data.</p>
<div id="r" class="section level3">
<h3><span class="header-section-number">1.4.1</span> R</h3>
<p>To download R, go to CRAN, the <strong>c</strong>omprehensive <strong>R</strong> <strong>a</strong>rchive <strong>n</strong>etwork. CRAN is composed of a set of mirror servers distributed around the world and is used to distribute R and R packages. Don’t try and pick a mirror that’s close to you: instead use the cloud mirror, <a href="https://cloud.r-project.org" class="uri">https://cloud.r-project.org</a>, which automatically figures it out for you.</p>
<p>A new major version of R comes out once a year, and there are 2-3 minor releases each year. It’s a good idea to update regularly. Upgrading can be a bit of a hassle, especially for major versions, which require you to reinstall all your packages, but putting it off only makes it worse.</p>
</div>
<div id="rstudio" class="section level3">
<h3><span class="header-section-number">1.4.2</span> RStudio</h3>
<p>RStudio is an integrated development environment, or IDE, for R programming. Download and install it from <a href="http://www.rstudio.com/download" class="uri">http://www.rstudio.com/download</a>. RStudio is updated a couple of times a year. When a new version is available, RStudio will let you know. It’s a good idea to upgrade regularly so you can take advantage of the latest and greatest features. For this book, make sure you have RStudio 1.0.0.</p>
<p>When you start RStudio, you’ll see two key regions in the interface:</p>
<p><img src="diagrams/rstudio-console.png" width="75%" style="display: block; margin: auto;" /></p>
<p>For now, all you need to know is that you type R code in the console pane, and press enter to run it. You’ll learn more as we go along!</p>
</div>
<div id="the-tidyverse" class="section level3">
<h3><span class="header-section-number">1.4.3</span> The tidyverse</h3>
<p>You’ll also need to install some R packages. An R <strong>package</strong> is a collection of functions, data, and documentation that extends the capabilities of base R. Using packages is key to the successful use of R. The majority of the packages that you will learn in this book are part of the so-called tidyverse. The packages in the tidyverse share a common philosophy of data and R programming, and are designed to work together naturally.</p>
<p>You can install the complete tidyverse with a single line of code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;tidyverse&quot;</span>)</code></pre>
<p>On your own computer, type that line of code in the console, and then press enter to run it. R will download the packages from CRAN and install them on to your computer. If you have problems installing, make sure that you are connected to the internet, and that <a href="https://cloud.r-project.org/" class="uri">https://cloud.r-project.org/</a> isn’t blocked by your firewall or proxy.</p>
<p>You will not be able to use the functions, objects, and help files in a package until you load it with <code>library()</code>. Once you have installed a package, you can load it with the <code>library()</code> function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="co">#&gt; ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ──</span>
<span class="co">#&gt; ✔ ggplot2 3.1.0     ✔ purrr   0.2.5</span>
<span class="co">#&gt; ✔ tibble  2.0.1     ✔ dplyr   0.7.8</span>
<span class="co">#&gt; ✔ tidyr   0.8.2     ✔ stringr 1.3.1</span>
<span class="co">#&gt; ✔ readr   1.3.1     ✔ forcats 0.3.0</span>
<span class="co">#&gt; ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ──</span>
<span class="co">#&gt; ✖ dplyr::filter() masks stats::filter()</span>
<span class="co">#&gt; ✖ dplyr::lag()    masks stats::lag()</span></code></pre>
<p>This tells you that tidyverse is loading the ggplot2, tibble, tidyr, readr, purrr, and dplyr packages. These are considered to be the <strong>core</strong> of the tidyverse because you’ll use them in almost every analysis.</p>
<p>Packages in the tidyverse change fairly frequently. You can see if updates are available, and optionally install them, by running <code>tidyverse_update()</code>.</p>
</div>
<div id="other-packages" class="section level3">
<h3><span class="header-section-number">1.4.4</span> Other packages</h3>
<p>There are many other excellent packages that are not part of the tidyverse, because they solve problems in a different domain, or are designed with a different set of underlying principles. This doesn’t make them better or worse, just different. In other words, the complement to the tidyverse is not the messyverse, but many other universes of interrelated packages. As you tackle more data science projects with R, you’ll learn new packages and new ways of thinking about data.</p>
<p>In this book we’ll use three data packages from outside the tidyverse:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&quot;nycflights13&quot;</span>, <span class="st">&quot;gapminder&quot;</span>, <span class="st">&quot;Lahman&quot;</span>))</code></pre>
<p>These packages provide data on airline flights, world development, and baseball that we’ll use to illustrate key data science ideas.</p>
</div>
</div>
<div id="running-r-code" class="section level2">
<h2><span class="header-section-number">1.5</span> Running R code</h2>
<p>The previous section showed you a couple of examples of running R code. Code in the book looks like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] 3</span>
<span class="co">#&gt; [1] 3</span></code></pre>
<p>If you run the same code in your local console, it will look like this:</p>
<pre><code>&gt; 1 + 2
[1] 3</code></pre>
<p>There are two main differences. In your console, you type after the <code>&gt;</code>, called the <strong>prompt</strong>; we don’t show the prompt in the book. In the book, output is commented out with <code>#&gt;</code>; in your console it appears directly after your code. These two differences mean that if you’re working with an electronic version of the book, you can easily copy code out of the book and into the console.</p>
<p>Throughout the book we use a consistent set of conventions to refer to code:</p>
<ul>
<li><p>Functions are in a code font and followed by parentheses, like <code>sum()</code>,
or <code>mean()</code>.</p></li>
<li><p>Other R objects (like data or function arguments) are in a code font,
without parentheses, like <code>flights</code> or <code>x</code>.</p></li>
<li><p>If we want to make it clear what package an object comes from, we’ll use
the package name followed by two colons, like <code>dplyr::mutate()</code>, or<br />
<code>nycflights13::flights</code>. This is also valid R code.</p></li>
</ul>
</div>
<div id="getting-help-and-learning-more" class="section level2">
<h2><span class="header-section-number">1.6</span> Getting help and learning more</h2>
<p>This book is not an island; there is no single resource that will allow you to master R. As you start to apply the techniques described in this book to your own data you will soon find questions that I do not answer. This section describes a few tips on how to get help, and to help you keep learning.</p>
<p>If you get stuck, start with Google. Typically adding “R” to a query is enough to restrict it to relevant results: if the search isn’t useful, it often means that there aren’t any R-specific results available. Google is particularly useful for error messages. If you get an error message and you have no idea what it means, try googling it! Chances are that someone else has been confused by it in the past, and there will be help somewhere on the web. (If the error message isn’t in English, run <code>Sys.setenv(LANGUAGE = &quot;en&quot;)</code> and re-run the code; you’re more likely to find help for English error messages.)</p>
<p>If Google doesn’t help, try stackoverflow<span id="fn3" class="footnote" data-pagedown-footnote-number="3" style="white-space: pre-line;"><a href="http://stackoverflow.com" class="uri">http://stackoverflow.com</a></span>. Start by spending a little time searching for an existing answer, including <code>[R]</code> to restrict your search to questions and answers that use R. If you don’t find anything useful, prepare a minimal reproducible example or <strong>reprex</strong>. A good reprex makes it easier for other people to help you, and often you’ll figure out the problem yourself in the course of making it.</p>
<p>There are three things you need to include to make your example reproducible: required packages, data, and code.</p>
<ol style="list-style-type: decimal">
<li><p><strong>Packages</strong> should be loaded at the top of the script, so it’s easy to
see which ones the example needs. This is a good time to check that you’re
using the latest version of each package; it’s possible you’ve discovered
a bug that’s been fixed since you installed the package. For packages
in the tidyverse, the easiest way to check is to run <code>tidyverse_update()</code>.</p></li>
<li><p>The easiest way to include <strong>data</strong> in a question is to use <code>dput()</code> to
generate the R code to recreate it. For example, to recreate the <code>mtcars</code>
dataset in R, I’d perform the following steps:</p>
<ol style="list-style-type: decimal">
<li>Run <code>dput(mtcars)</code> in R</li>
<li>Copy the output</li>
<li>In my reproducible script, type <code>mtcars &lt;-</code> then paste.</li>
</ol>
<p>Try and find the smallest subset of your data that still reveals
the problem.</p></li>
<li><p>Spend a little bit of time ensuring that your <strong>code</strong> is easy for others to
read:</p>
<ul>
<li><p>Make sure you’ve used spaces and your variable names are concise, yet
informative.</p></li>
<li><p>Use comments to indicate where your problem lies.</p></li>
<li><p>Do your best to remove everything that is not related to the problem.<br />
The shorter your code is, the easier it is to understand, and the
easier it is to fix.</p></li>
</ul></li>
</ol>
<p>Finish by checking that you have actually made a reproducible example by starting a fresh R session and copying and pasting your script in.</p>
<p>You should also spend some time preparing yourself to solve problems before they occur. Investing a little time in learning R each day will pay off handsomely in the long run. One way is to follow what Hadley, Garrett, and everyone else at RStudio are doing on the RStudio blog<span id="fn4" class="footnote" data-pagedown-footnote-number="4" style="white-space: pre-line;"><a href="https://blog.rstudio.org" class="uri">https://blog.rstudio.org</a></span>. This is where we post announcements about new packages, new IDE features, and in-person courses. You might also want to follow Hadley (@hadleywickham<span id="fn5" class="footnote" data-pagedown-footnote-number="5" style="white-space: pre-line;"><a href="https://twitter.com/hadleywickham" class="uri">https://twitter.com/hadleywickham</a></span>) or Garrett (@statgarrett<span id="fn6" class="footnote" data-pagedown-footnote-number="6" style="white-space: pre-line;"><a href="https://twitter.com/statgarrett" class="uri">https://twitter.com/statgarrett</a></span>) on Twitter, or follow @rstudiotips<span id="fn7" class="footnote" data-pagedown-footnote-number="7" style="white-space: pre-line;"><a href="https://twitter.com/rstudiotips" class="uri">https://twitter.com/rstudiotips</a></span> to keep up with new features in the IDE.</p>
<p>To keep up with the R community more broadly, we recommend reading <a href="http://www.r-bloggers.com" class="uri">http://www.r-bloggers.com</a>: it aggregates over 500 blogs about R from around the world. If you’re an active Twitter user, follow the <code>#rstats</code> hashtag. Twitter is one of the key tools that Hadley uses to keep up with new developments in the community.</p>
<!--chapter:end:intro.Rmd-->
</div>
</div>
<div id="part-explore" class="section level1 unnumbered">
<h1><span class="header-section-number">I</span> Explore</h1>
</div>
<div id="explore-intro" class="section level1">
<h1><span class="header-section-number">2</span> Introduction</h1>
<p>The goal of the first part of this book is to get you up to speed with the basic tools of <strong>data exploration</strong> as quickly as possible. Data exploration is the art of looking at your data, rapidly generating hypotheses, quickly testing them, then repeating again and again and again. The goal of data exploration is to generate many promising leads that you can later explore in more depth.</p>
<p><img src="diagrams/data-science-explore.png" width="75%" style="display: block; margin: auto;" /></p>
<p>In this part of the book you will learn some useful tools that have an immediate payoff:</p>
<ul>
<li><p>Visualisation is a great place to start with R programming, because the
payoff is so clear: you get to make elegant and informative plots that help
you understand data. In <a href="#data-visualisation">data visualisation</a> you’ll dive into visualisation,
learning the basic structure of a ggplot2 plot, and powerful techniques for
turning data into plots.</p></li>
<li><p>Visualisation alone is typically not enough, so in <a href="#transform">data transformation</a>
you’ll learn the key verbs that allow you to select important variables,
filter out key observations, create new variables, and compute summaries.</p></li>
<li><p>Finally, in <a href="#exploratory-data-analysis">exploratory data analysis</a>, you’ll combine visualisation and
transformation with your curiosity and scepticism to ask and answer
interesting questions about data.</p></li>
</ul>
<p>Modelling is an important part of the exploratory process, but you don’t have the skills to effectively learn or apply it yet. We’ll come back to it in <a href="#model-intro">modelling</a>, once you’re better equipped with more data wrangling and programming tools.</p>
<p>Nestled among these three chapters that teach you the tools of exploration are three chapters that focus on your R workflow. In <a href="#workflow-basics">workflow: basics</a>, <a href="#workflow-scripts">workflow: scripts</a>, and <a href="#workflow-projects">workflow: projects</a> you’ll learn good practices for writing and organising your R code. These will set you up for success in the long run, as they’ll give you the tools to stay organised when you tackle real projects.</p>
<!--chapter:end:explore.Rmd-->
</div>
<div id="data-visualisation" class="section level1">
<h1><span class="header-section-number">3</span> Data visualisation</h1>
<div id="introduction-1" class="section level2">
<h2><span class="header-section-number">3.1</span> Introduction</h2>
<blockquote>
<p>“The simple graph has brought more information to the data analyst’s mind
than any other device.” — John Tukey</p>
</blockquote>
<p>This chapter will teach you how to visualise your data using ggplot2. R has several systems for making graphs, but ggplot2 is one of the most elegant and most versatile. ggplot2 implements the <strong>grammar of graphics</strong>, a coherent system for describing and building graphs. With ggplot2, you can do more faster by learning one system and applying it in many places.</p>
<p>If you’d like to learn more about the theoretical underpinnings of ggplot2 before you start, I’d recommend reading “The Layered Grammar of Graphics”, <a href="http://vita.had.co.nz/papers/layered-grammar.pdf" class="uri">http://vita.had.co.nz/papers/layered-grammar.pdf</a>.</p>
<div id="prerequisites-1" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Prerequisites</h3>
<p>This chapter focusses on ggplot2, one of the core members of the tidyverse. To access the datasets, help pages, and functions that we will use in this chapter, load the tidyverse by running this code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="co">#&gt; ── Attaching packages ────────────────────────────────── tidyverse 1.2.1 ──</span>
<span class="co">#&gt; ✔ ggplot2 3.1.0     ✔ purrr   0.2.5</span>
<span class="co">#&gt; ✔ tibble  2.0.1     ✔ dplyr   0.7.8</span>
<span class="co">#&gt; ✔ tidyr   0.8.2     ✔ stringr 1.3.1</span>
<span class="co">#&gt; ✔ readr   1.3.1     ✔ forcats 0.3.0</span>
<span class="co">#&gt; ── Conflicts ───────────────────────────────────── tidyverse_conflicts() ──</span>
<span class="co">#&gt; ✖ dplyr::filter() masks stats::filter()</span>
<span class="co">#&gt; ✖ dplyr::lag()    masks stats::lag()</span></code></pre>
<p>That one line of code loads the core tidyverse; packages which you will use in almost every data analysis. It also tells you which functions from the tidyverse conflict with functions in base R (or from other packages you might have loaded).</p>
<p>If you run this code and get the error message “there is no package called ‘tidyverse’”, you’ll need to first install it, then run <code>library()</code> once again.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;tidyverse&quot;</span>)
<span class="kw">library</span>(tidyverse)</code></pre>
<p>You only need to install a package once, but you need to reload it every time you start a new session.</p>
<p>If we need to be explicit about where a function (or dataset) comes from, we’ll use the special form <code>package::function()</code>. For example, <code>ggplot2::ggplot()</code> tells you explicitly that we’re using the <code>ggplot()</code> function from the ggplot2 package.</p>
</div>
</div>
<div id="first-steps" class="section level2">
<h2><span class="header-section-number">3.2</span> First steps</h2>
<p>Let’s use our first graph to answer a question: Do cars with big engines use more fuel than cars with small engines? You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?</p>
<div id="the-mpg-data-frame" class="section level3">
<h3><span class="header-section-number">3.2.1</span> The <code>mpg</code> data frame</h3>
<p>You can test your answer with the <code>mpg</code> <strong>data frame</strong> found in ggplot2 (aka <code>ggplot2::mpg</code>). A data frame is a rectangular collection of variables (in the columns) and observations (in the rows). <code>mpg</code> contains observations collected by the US Environmental Protection Agency on 38 models of car.</p>
<pre class="sourceCode r"><code class="sourceCode r">mpg
<span class="co">#&gt; # A tibble: 234 x 11</span>
<span class="co">#&gt;   manufacturer model displ  year   cyl trans  drv     cty   hwy fl    class</span>
<span class="co">#&gt;   &lt;chr&gt;        &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1 audi         a4      1.8  1999     4 auto(… f        18    29 p     comp…</span>
<span class="co">#&gt; 2 audi         a4      1.8  1999     4 manua… f        21    29 p     comp…</span>
<span class="co">#&gt; 3 audi         a4      2    2008     4 manua… f        20    31 p     comp…</span>
<span class="co">#&gt; 4 audi         a4      2    2008     4 auto(… f        21    30 p     comp…</span>
<span class="co">#&gt; 5 audi         a4      2.8  1999     6 auto(… f        16    26 p     comp…</span>
<span class="co">#&gt; 6 audi         a4      2.8  1999     6 manua… f        18    26 p     comp…</span>
<span class="co">#&gt; # … with 228 more rows</span></code></pre>
<p>Among the variables in <code>mpg</code> are:</p>
<ol style="list-style-type: decimal">
<li><p><code>displ</code>, a car’s engine size, in litres.</p></li>
<li><p><code>hwy</code>, a car’s fuel efficiency on the highway, in miles per gallon (mpg).
A car with a low fuel efficiency consumes more fuel than a car with a high
fuel efficiency when they travel the same distance.</p></li>
</ol>
<p>To learn more about <code>mpg</code>, open its help page by running <code>?mpg</code>.</p>
</div>
<div id="creating-a-ggplot" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Creating a ggplot</h3>
<p>To plot <code>mpg</code>, run this code to put <code>displ</code> on the x-axis and <code>hwy</code> on the y-axis:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The plot shows a negative relationship between engine size (<code>displ</code>) and fuel efficiency (<code>hwy</code>). In other words, cars with big engines use more fuel. Does this confirm or refute your hypothesis about fuel efficiency and engine size?</p>
<p>With ggplot2, you begin a plot with the function <code>ggplot()</code>. <code>ggplot()</code> creates a coordinate system that you can add layers to. The first argument of <code>ggplot()</code> is the dataset to use in the graph. So <code>ggplot(data = mpg)</code> creates an empty graph, but it’s not very interesting so I’m not going to show it here.</p>
<p>You complete your graph by adding one or more layers to <code>ggplot()</code>. The function <code>geom_point()</code> adds a layer of points to your plot, which creates a scatterplot. ggplot2 comes with many geom functions that each add a different type of layer to a plot. You’ll learn a whole bunch of them throughout this chapter.</p>
<p>Each geom function in ggplot2 takes a <code>mapping</code> argument. This defines how variables in your dataset are mapped to visual properties. The <code>mapping</code> argument is always paired with <code>aes()</code>, and the <code>x</code> and <code>y</code> arguments of <code>aes()</code> specify which variables to map to the x and y axes. ggplot2 looks for the mapped variables in the <code>data</code> argument, in this case, <code>mpg</code>.</p>
</div>
<div id="a-graphing-template" class="section level3">
<h3><span class="header-section-number">3.2.3</span> A graphing template</h3>
<p>Let’s turn this code into a reusable template for making graphs with ggplot2. To make a graph, replace the bracketed sections in the code below with a dataset, a geom function, or a collection of mappings.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> <span class="op">&lt;</span>DATA<span class="op">&gt;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="er">&lt;</span>GEOM_FUNCTION<span class="op">&gt;</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="op">&lt;</span>MAPPINGS<span class="op">&gt;</span>))</code></pre>
<p>The rest of this chapter will show you how to complete and extend this template to make different types of graphs. We will begin with the <code>&lt;MAPPINGS&gt;</code> component.</p>
</div>
<div id="exercises" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Run <code>ggplot(data = mpg)</code>. What do you see?</p></li>
<li><p>How many rows are in <code>mpg</code>? How many columns?</p></li>
<li><p>What does the <code>drv</code> variable describe? Read the help for <code>?mpg</code> to find
out.</p></li>
<li><p>Make a scatterplot of <code>hwy</code> vs <code>cyl</code>.</p></li>
<li><p>What happens if you make a scatterplot of <code>class</code> vs <code>drv</code>? Why is
the plot not useful?</p></li>
</ol>
</div>
</div>
<div id="aesthetic-mappings" class="section level2">
<h2><span class="header-section-number">3.3</span> Aesthetic mappings</h2>
<blockquote>
<p>“The greatest value of a picture is when it forces us to notice what we
never expected to see.” — John Tukey</p>
</blockquote>
<p>In the plot below, one group of points (highlighted in red) seems to fall outside of the linear trend. These cars have a higher mileage than you might expect. How can you explain these cars?</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Let’s hypothesize that the cars are hybrids. One way to test this hypothesis is to look at the <code>class</code> value for each car. The <code>class</code> variable of the <code>mpg</code> dataset classifies cars into groups such as compact, midsize, and SUV. If the outlying points are hybrids, they should be classified as compact cars or, perhaps, subcompact cars (keep in mind that this data was collected before hybrid trucks and SUVs became popular).</p>
<p>You can add a third variable, like <code>class</code>, to a two dimensional scatterplot by mapping it to an <strong>aesthetic</strong>. An aesthetic is a visual property of the objects in your plot. Aesthetics include things like the size, the shape, or the color of your points. You can display a point (like the one below) in different ways by changing the values of its aesthetic properties. Since we already use the word “value” to describe data, let’s use the word “level” to describe aesthetic properties. Here we change the levels of a point’s size, shape, and color to make the point small, triangular, or blue:</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can convey information about your data by mapping the aesthetics in your plot to the variables in your dataset. For example, you can map the colors of your points to the <code>class</code> variable to reveal the class of each car.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">color =</span> class))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(If you prefer British English, like Hadley, you can use <code>colour</code> instead of <code>color</code>.)</p>
<p>To map an aesthetic to a variable, associate the name of the aesthetic to the name of the variable inside <code>aes()</code>. ggplot2 will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable, a process known as <strong>scaling</strong>. ggplot2 will also add a legend that explains which levels correspond to which values.</p>
<p>The colors reveal that many of the unusual points are two-seater cars. These cars don’t seem like hybrids, and are, in fact, sports cars! Sports cars have large engines like SUVs and pickup trucks, but small bodies like midsize and compact cars, which improves their gas mileage. In hindsight, these cars were unlikely to be hybrids since they have large engines.</p>
<p>In the above example, we mapped <code>class</code> to the color aesthetic, but we could have mapped <code>class</code> to the size aesthetic in the same way. In this case, the exact size of each point would reveal its class affiliation. We get a <em>warning</em> here, because mapping an unordered variable (<code>class</code>) to an ordered aesthetic (<code>size</code>) is not a good idea.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">size =</span> class))
<span class="co">#&gt; Warning: Using size for a discrete variable is not advised.</span></code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Or we could have mapped <code>class</code> to the <em>alpha</em> aesthetic, which controls the transparency of the points, or to the shape aesthetic, which controls the shape of the points.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Left</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">alpha =</span> class))

<span class="co"># Right</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">shape =</span> class))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-10-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-10-2.png" width="50%" /></p>
<p>What happened to the SUVs? ggplot2 will only use six shapes at a time. By default, additional groups will go unplotted when you use the shape aesthetic.</p>
<p>For each aesthetic, you use <code>aes()</code> to associate the name of the aesthetic with a variable to display. The <code>aes()</code> function gathers together each of the aesthetic mappings used by a layer and passes them to the layer’s mapping argument. The syntax highlights a useful insight about <code>x</code> and <code>y</code>: the x and y locations of a point are themselves aesthetics, visual properties that you can map to variables to display information about the data.</p>
<p>Once you map an aesthetic, ggplot2 takes care of the rest. It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. For x and y aesthetics, ggplot2 does not create a legend, but it creates an axis line with tick marks and a label. The axis line acts as a legend; it explains the mapping between locations and values.</p>
<p>You can also <em>set</em> the aesthetic properties of your geom manually. For example, we can make all of the points in our plot blue:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy), <span class="dt">color =</span> <span class="st">&quot;blue&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here, the color doesn’t convey information about a variable, but only changes the appearance of the plot. To set an aesthetic manually, set the aesthetic by name as an argument of your geom function; i.e. it goes <em>outside</em> of <code>aes()</code>. You’ll need to pick a level that makes sense for that aesthetic:</p>
<ul>
<li><p>The name of a color as a character string.</p></li>
<li><p>The size of a point in mm.</p></li>
<li><p>The shape of a point as a number, as shown in Figure <a href="#fig:shapes">3.1</a>.</p></li>
</ul>
<div class="figure" style="text-align: center"><span id="fig:shapes"></span>
<img src="visualize_files/figure-html/shapes-1.png" alt="R has 25 built in shapes that are identified by numbers. There are some seeming duplicates: for example, 0, 15, and 22 are all squares. The difference comes from the interaction of the `colour` and `fill` aesthetics. The hollow shapes (0--14) have a border determined by `colour`; the solid shapes (15--18) are filled with `colour`; the filled shapes (21--24) have a border of `colour` and are filled with `fill`." width="75%" />
<p class="caption">
Figure 3.1: R has 25 built in shapes that are identified by numbers. There are some seeming duplicates: for example, 0, 15, and 22 are all squares. The difference comes from the interaction of the <code>colour</code> and <code>fill</code> aesthetics. The hollow shapes (0–14) have a border determined by <code>colour</code>; the solid shapes (15–18) are filled with <code>colour</code>; the filled shapes (21–24) have a border of <code>colour</code> and are filled with <code>fill</code>.
</p>
</div>
<div id="exercises-1" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What’s gone wrong with this code? Why are the points not blue?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">color =</span> <span class="st">&quot;blue&quot;</span>))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
<li><p>Which variables in <code>mpg</code> are categorical? Which variables are continuous?
(Hint: type <code>?mpg</code> to read the documentation for the dataset). How
can you see this information when you run <code>mpg</code>?</p></li>
<li><p>Map a continuous variable to <code>color</code>, <code>size</code>, and <code>shape</code>. How do
these aesthetics behave differently for categorical vs. continuous
variables?</p></li>
<li><p>What happens if you map the same variable to multiple aesthetics?</p></li>
<li><p>What does the <code>stroke</code> aesthetic do? What shapes does it work with?
(Hint: use <code>?geom_point</code>)</p></li>
<li><p>What happens if you map an aesthetic to something other than a variable
name, like <code>aes(colour = displ &lt; 5)</code>? Note, you’ll also need to specify x and y.</p></li>
</ol>
</div>
</div>
<div id="common-problems" class="section level2">
<h2><span class="header-section-number">3.4</span> Common problems</h2>
<p>As you start to run R code, you’re likely to run into problems. Don’t worry — it happens to everyone. I have been writing R code for years, and every day I still write code that doesn’t work!</p>
<p>Start by carefully comparing the code that you’re running to the code in the book. R is extremely picky, and a misplaced character can make all the difference. Make sure that every <code>(</code> is matched with a <code>)</code> and every <code>&quot;</code> is paired with another <code>&quot;</code>. Sometimes you’ll run the code and nothing happens. Check the left-hand of your console: if it’s a <code>+</code>, it means that R doesn’t think you’ve typed a complete expression and it’s waiting for you to finish it. In this case, it’s usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.</p>
<p>One common problem when creating ggplot2 graphics is to put the <code>+</code> in the wrong place: it has to come at the end of the line, not the start. In other words, make sure you haven’t accidentally written code like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) 
<span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))</code></pre>
<p>If you’re still stuck, try the help. You can get help about any R function by running <code>?function_name</code> in the console, or selecting the function name and pressing F1 in RStudio. Don’t worry if the help doesn’t seem that helpful - instead skip down to the examples and look for code that matches what you’re trying to do.</p>
<p>If that doesn’t help, carefully read the error message. Sometimes the answer will be buried there! But when you’re new to R, the answer might be in the error message but you don’t yet know how to understand it. Another great tool is Google: try googling the error message, as it’s likely someone else has had the same problem, and has gotten help online.</p>
</div>
<div id="facets" class="section level2">
<h2><span class="header-section-number">3.5</span> Facets</h2>
<p>One way to add additional variables is with aesthetics. Another way, particularly useful for categorical variables, is to split your plot into <strong>facets</strong>, subplots that each display one subset of the data.</p>
<p>To facet your plot by a single variable, use <code>facet_wrap()</code>. The first argument of <code>facet_wrap()</code> should be a formula, which you create with <code>~</code> followed by a variable name (here “formula” is the name of a data structure in R, not a synonym for “equation”). The variable that you pass to <code>facet_wrap()</code> should be discrete.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>class, <span class="dt">nrow =</span> <span class="dv">2</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>To facet your plot on the combination of two variables, add <code>facet_grid()</code> to your plot call. The first argument of <code>facet_grid()</code> is also a formula. This time the formula should contain two variable names separated by a <code>~</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_grid</span>(drv <span class="op">~</span><span class="st"> </span>cyl)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you prefer to not facet in the rows or columns dimension, use a <code>.</code> instead of a variable name, e.g. <code>+ facet_grid(. ~ cyl)</code>.</p>
<div id="exercises-2" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What happens if you facet on a continuous variable?</p></li>
<li><p>What do the empty cells in plot with <code>facet_grid(drv ~ cyl)</code> mean?
How do they relate to this plot?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> drv, <span class="dt">y =</span> cyl))</code></pre></li>
<li><p>What plots does the following code make? What does <code>.</code> do?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(drv <span class="op">~</span><span class="st"> </span>.)

<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(. <span class="op">~</span><span class="st"> </span>cyl)</code></pre></li>
<li><p>Take the first faceted plot in this section:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>class, <span class="dt">nrow =</span> <span class="dv">2</span>)</code></pre>
<p>What are the advantages to using faceting instead of the colour aesthetic?
What are the disadvantages? How might the balance change if you had a
larger dataset?</p></li>
<li><p>Read <code>?facet_wrap</code>. What does <code>nrow</code> do? What does <code>ncol</code> do? What other
options control the layout of the individual panels? Why doesn’t
<code>facet_grid()</code> have <code>nrow</code> and <code>ncol</code> arguments?</p></li>
<li><p>When using <code>facet_grid()</code> you should usually put the variable with more
unique levels in the columns. Why?</p></li>
</ol>
</div>
</div>
<div id="geometric-objects" class="section level2">
<h2><span class="header-section-number">3.6</span> Geometric objects</h2>
<p>How are these two plots similar?</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-18-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-18-2.png" width="50%" /></p>
<p>Both plots contain the same x variable, the same y variable, and both describe the same data. But the plots are not identical. Each plot uses a different visual object to represent the data. In ggplot2 syntax, we say that they use different <strong>geoms</strong>.</p>
<p>A <strong>geom</strong> is the geometrical object that a plot uses to represent data. People often describe plots by the type of geom that the plot uses. For example, bar charts use bar geoms, line charts use line geoms, boxplots use boxplot geoms, and so on. Scatterplots break the trend; they use the point geom. As we see above, you can use different geoms to plot the same data. The plot on the left uses the point geom, and the plot on the right uses the smooth geom, a smooth line fitted to the data.</p>
<p>To change the geom in your plot, change the geom function that you add to <code>ggplot()</code>. For instance, to make the plots above, you can use this code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># left</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))

<span class="co"># right</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))</code></pre>
<p>Every geom function in ggplot2 takes a <code>mapping</code> argument. However, not every aesthetic works with every geom. You could set the shape of a point, but you couldn’t set the “shape” of a line. On the other hand, you <em>could</em> set the linetype of a line. <code>geom_smooth()</code> will draw a different line, with a different linetype, for each unique value of the variable that you map to linetype.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">linetype =</span> drv))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here <code>geom_smooth()</code> separates the cars into three lines based on their <code>drv</code> value, which describes a car’s drivetrain. One line describes all of the points with a <code>4</code> value, one line describes all of the points with an <code>f</code> value, and one line describes all of the points with an <code>r</code> value. Here, <code>4</code> stands for four-wheel drive, <code>f</code> for front-wheel drive, and <code>r</code> for rear-wheel drive.</p>
<p>If this sounds strange, we can make it more clear by overlaying the lines on top of the raw data and then coloring everything according to <code>drv</code>.</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Notice that this plot contains two geoms in the same graph! If this makes you excited, buckle up. We will learn how to place multiple geoms in the same plot very soon.</p>
<p>ggplot2 provides over 30 geoms, and extension packages provide even more (see <a href="https://www.ggplot2-exts.org" class="uri">https://www.ggplot2-exts.org</a> for a sampling). The best way to get a comprehensive overview is the ggplot2 cheatsheet, which you can find at <a href="http://rstudio.com/cheatsheets" class="uri">http://rstudio.com/cheatsheets</a>. To learn more about any single geom, use help: <code>?geom_smooth</code>.</p>
<p>Many geoms, like <code>geom_smooth()</code>, use a single geometric object to display multiple rows of data. For these geoms, you can set the <code>group</code> aesthetic to a categorical variable to draw multiple objects. ggplot2 will draw a separate object for each unique value of the grouping variable. In practice, ggplot2 will automatically group the data for these geoms whenever you map an aesthetic to a discrete variable (as in the <code>linetype</code> example). It is convenient to rely on this feature because the group aesthetic by itself does not add a legend or distinguishing features to the geoms.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))
              
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">group =</span> drv))
    
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(
    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">color =</span> drv),
    <span class="dt">show.legend =</span> <span class="ot">FALSE</span>
  )</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-22-1.png" width="33%" /><img src="visualize_files/figure-html/unnamed-chunk-22-2.png" width="33%" /><img src="visualize_files/figure-html/unnamed-chunk-22-3.png" width="33%" /></p>
<p>To display multiple geoms in the same plot, add multiple geom functions to <code>ggplot()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This, however, introduces some duplication in our code. Imagine if you wanted to change the y-axis to display <code>cty</code> instead of <code>hwy</code>. You’d need to change the variable in two places, and you might forget to update one. You can avoid this type of repetition by passing a set of mappings to <code>ggplot()</code>. ggplot2 will treat these mappings as global mappings that apply to each geom in the graph. In other words, this code will produce the same plot as the previous code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>()</code></pre>
<p>If you place mappings in a geom function, ggplot2 will treat them as local mappings for the layer. It will use these mappings to extend or overwrite the global mappings <em>for that layer only</em>. This makes it possible to display different aesthetics in different layers.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can use the same idea to specify different <code>data</code> for each layer. Here, our smooth line displays just a subset of the <code>mpg</code> dataset, the subcompact cars. The local data argument in <code>geom_smooth()</code> overrides the global data argument in <code>ggplot()</code> for that layer only.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">data =</span> <span class="kw">filter</span>(mpg, class <span class="op">==</span><span class="st"> &quot;subcompact&quot;</span>), <span class="dt">se =</span> <span class="ot">FALSE</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(You’ll learn how <code>filter()</code> works in the chapter on data transformations: for now, just know that this command selects only the subcompact cars.)</p>
<div id="exercises-3" class="section level3">
<h3><span class="header-section-number">3.6.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What geom would you use to draw a line chart? A boxplot?
A histogram? An area chart?</p></li>
<li><p>Run this code in your head and predict what the output will look like.
Then, run the code in R and check your predictions.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy, <span class="dt">color =</span> drv)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>)</code></pre></li>
<li><p>What does <code>show.legend = FALSE</code> do? What happens if you remove it?<br />
Why do you think I used it earlier in the chapter?</p></li>
<li><p>What does the <code>se</code> argument to <code>geom_smooth()</code> do?</p></li>
<li><p>Will these two graphs look different? Why/why not?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>()

<span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))</code></pre></li>
<li><p>Recreate the R code necessary to generate the following graphs.</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-29-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-29-2.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-29-3.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-29-4.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-29-5.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-29-6.png" width="50%" /></p></li>
</ol>
</div>
</div>
<div id="statistical-transformations" class="section level2">
<h2><span class="header-section-number">3.7</span> Statistical transformations</h2>
<p>Next, let’s take a look at a bar chart. Bar charts seem simple, but they are interesting because they reveal something subtle about plots. Consider a basic bar chart, as drawn with <code>geom_bar()</code>. The following chart displays the total number of diamonds in the <code>diamonds</code> dataset, grouped by <code>cut</code>. The <code>diamonds</code> dataset comes in ggplot2 and contains information about ~54,000 diamonds, including the <code>price</code>, <code>carat</code>, <code>color</code>, <code>clarity</code>, and <code>cut</code> of each diamond. The chart shows that more diamonds are available with high quality cuts than with low quality cuts.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-30-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>On the x-axis, the chart displays <code>cut</code>, a variable from <code>diamonds</code>. On the y-axis, it displays count, but count is not a variable in <code>diamonds</code>! Where does count come from? Many graphs, like scatterplots, plot the raw values of your dataset. Other graphs, like bar charts, calculate new values to plot:</p>
<ul>
<li><p>bar charts, histograms, and frequency polygons bin your data
and then plot bin counts, the number of points that fall in each bin.</p></li>
<li><p>smoothers fit a model to your data and then plot predictions from the
model.</p></li>
<li><p>boxplots compute a robust summary of the distribution and then display a
specially formatted box.</p></li>
</ul>
<p>The algorithm used to calculate new values for a graph is called a <strong>stat</strong>, short for statistical transformation. The figure below describes how this process works with <code>geom_bar()</code>.</p>
<p><img src="images/visualization-stat-bar.png" width="100%" style="display: block; margin: auto;" /></p>
<p>You can learn which stat a geom uses by inspecting the default value for the <code>stat</code> argument. For example, <code>?geom_bar</code> shows that the default value for <code>stat</code> is “count”, which means that <code>geom_bar()</code> uses <code>stat_count()</code>. <code>stat_count()</code> is documented on the same page as <code>geom_bar()</code>, and if you scroll down you can find a section called “Computed variables”. That describes how it computes two new variables: <code>count</code> and <code>prop</code>.</p>
<p>You can generally use geoms and stats interchangeably. For example, you can recreate the previous plot using <code>stat_count()</code> instead of <code>geom_bar()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stat_count</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-32-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This works because every geom has a default stat; and every stat has a default geom. This means that you can typically use geoms without worrying about the underlying statistical transformation. There are three reasons you might need to use a stat explicitly:</p>
<ol style="list-style-type: decimal">
<li><p>You might want to override the default stat. In the code below, I change
the stat of <code>geom_bar()</code> from count (the default) to identity. This lets
me map the height of the bars to the raw values of a <span class="math inline">\(y\)</span> variable.
Unfortunately when people talk about bar charts casually, they might be
referring to this type of bar chart, where the height of the bar is already
present in the data, or the previous bar chart where the height of the bar
is generated by counting rows.</p>
<pre class="sourceCode r"><code class="sourceCode r">demo &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>cut,         <span class="op">~</span>freq,
  <span class="st">&quot;Fair&quot;</span>,       <span class="dv">1610</span>,
  <span class="st">&quot;Good&quot;</span>,       <span class="dv">4906</span>,
  <span class="st">&quot;Very Good&quot;</span>,  <span class="dv">12082</span>,
  <span class="st">&quot;Premium&quot;</span>,    <span class="dv">13791</span>,
  <span class="st">&quot;Ideal&quot;</span>,      <span class="dv">21551</span>
)

<span class="kw">ggplot</span>(<span class="dt">data =</span> demo) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> freq), <span class="dt">stat =</span> <span class="st">&quot;identity&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-33-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(Don’t worry that you haven’t seen <code>&lt;-</code> or <code>tribble()</code> before. You might be
able to guess at their meaning from the context, and you’ll learn exactly
what they do soon!)</p></li>
<li><p>You might want to override the default mapping from transformed variables
to aesthetics. For example, you might want to display a bar chart of
proportion, rather than count:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> ..prop.., <span class="dt">group =</span> <span class="dv">1</span>))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>To find the variables computed by the stat, look for the help section
titled “computed variables”.</p></li>
<li><p>You might want to draw greater attention to the statistical transformation
in your code. For example, you might use <code>stat_summary()</code>, which
summarises the y values for each unique x value, to draw
attention to the summary that you’re computing:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stat_summary</span>(
    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> depth),
    <span class="dt">fun.ymin =</span> min,
    <span class="dt">fun.ymax =</span> max,
    <span class="dt">fun.y =</span> median
  )</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
</ol>
<p>ggplot2 provides over 20 stats for you to use. Each stat is a function, so you can get help in the usual way, e.g. <code>?stat_bin</code>. To see a complete list of stats, try the ggplot2 cheatsheet.</p>
<div id="exercises-4" class="section level3">
<h3><span class="header-section-number">3.7.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What is the default geom associated with <code>stat_summary()</code>? How could
you rewrite the previous plot to use that geom function instead of the
stat function?</p></li>
<li><p>What does <code>geom_col()</code> do? How is it different to <code>geom_bar()</code>?</p></li>
<li><p>Most geoms and stats come in pairs that are almost always used in
concert. Read through the documentation and make a list of all the
pairs. What do they have in common?</p></li>
<li><p>What variables does <code>stat_smooth()</code> compute? What parameters control
its behaviour?</p></li>
<li><p>In our proportion bar chart, we need to set <code>group = 1</code>. Why? In other
words what is the problem with these two graphs?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> ..prop..))
<span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> color, <span class="dt">y =</span> ..prop..))</code></pre></li>
</ol>
</div>
</div>
<div id="position-adjustments" class="section level2">
<h2><span class="header-section-number">3.8</span> Position adjustments</h2>
<p>There’s one more piece of magic associated with bar charts. You can colour a bar chart using either the <code>colour</code> aesthetic, or, more usefully, <code>fill</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">colour =</span> cut))
<span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> cut))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-37-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-37-2.png" width="50%" /></p>
<p>Note what happens if you map the fill aesthetic to another variable, like <code>clarity</code>: the bars are automatically stacked. Each colored rectangle represents a combination of <code>cut</code> and <code>clarity</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> clarity))</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-38-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The stacking is performed automatically by the <strong>position adjustment</strong> specified by the <code>position</code> argument. If you don’t want a stacked bar chart, you can use one of three other options: <code>&quot;identity&quot;</code>, <code>&quot;dodge&quot;</code> or <code>&quot;fill&quot;</code>.</p>
<ul>
<li><p><code>position = &quot;identity&quot;</code> will place each object exactly where it falls in
the context of the graph. This is not very useful for bars, because it
overlaps them. To see that overlapping we either need to make the bars
slightly transparent by setting <code>alpha</code> to a small value, or completely
transparent by setting <code>fill = NA</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> clarity)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">5</span>, <span class="dt">position =</span> <span class="st">&quot;identity&quot;</span>)
<span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">colour =</span> clarity)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">fill =</span> <span class="ot">NA</span>, <span class="dt">position =</span> <span class="st">&quot;identity&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-39-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-39-2.png" width="50%" /></p>
<p>The identity position adjustment is more useful for 2d geoms, like points,
where it is the default.</p></li>
<li><p><code>position = &quot;fill&quot;</code> works like stacking, but makes each set of stacked bars
the same height. This makes it easier to compare proportions across
groups.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> clarity), <span class="dt">position =</span> <span class="st">&quot;fill&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
<li><p><code>position = &quot;dodge&quot;</code> places overlapping objects directly <em>beside</em> one
another. This makes it easier to compare individual values.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> clarity), <span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
</ul>
<p>There’s one other type of adjustment that’s not useful for bar charts, but it can be very useful for scatterplots. Recall our first scatterplot. Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?</p>
<p><img src="visualize_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The values of <code>hwy</code> and <code>displ</code> are rounded so the points appear on a grid and many points overlap each other. This problem is known as <strong>overplotting</strong>. This arrangement makes it hard to see where the mass of the data is. Are the data points spread equally throughout the graph, or is there one special combination of <code>hwy</code> and <code>displ</code> that contains 109 values?</p>
<p>You can avoid this gridding by setting the position adjustment to “jitter”. <code>position = &quot;jitter&quot;</code> adds a small amount of random noise to each point. This spreads the points out because no two points are likely to receive the same amount of random noise.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy), <span class="dt">position =</span> <span class="st">&quot;jitter&quot;</span>)</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-43-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph <em>more</em> revealing at large scales. Because this is such a useful operation, ggplot2 comes with a shorthand for <code>geom_point(position = &quot;jitter&quot;)</code>: <code>geom_jitter()</code>.</p>
<p>To learn more about a position adjustment, look up the help page associated with each adjustment: <code>?position_dodge</code>, <code>?position_fill</code>, <code>?position_identity</code>, <code>?position_jitter</code>, and <code>?position_stack</code>.</p>
<div id="exercises-5" class="section level3">
<h3><span class="header-section-number">3.8.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What is the problem with this plot? How could you improve it?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cty, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-44-1.png" width="70%" style="display: block; margin: auto;" /></p></li>
<li><p>What parameters to <code>geom_jitter()</code> control the amount of jittering?</p></li>
<li><p>Compare and contrast <code>geom_jitter()</code> with <code>geom_count()</code>.</p></li>
<li><p>What’s the default position adjustment for <code>geom_boxplot()</code>? Create
a visualisation of the <code>mpg</code> dataset that demonstrates it.</p></li>
</ol>
</div>
</div>
<div id="coordinate-systems" class="section level2">
<h2><span class="header-section-number">3.9</span> Coordinate systems</h2>
<p>Coordinate systems are probably the most complicated part of ggplot2. The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point. There are a number of other coordinate systems that are occasionally helpful.</p>
<ul>
<li><p><code>coord_flip()</code> switches the x and y axes. This is useful (for example),
if you want horizontal boxplots. It’s also useful for long labels: it’s
hard to get them to fit without overlapping on the x-axis.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> class, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()
<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> class, <span class="dt">y =</span> hwy)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_flip</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-45-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-45-2.png" width="50%" /></p></li>
<li><p><code>coord_quickmap()</code> sets the aspect ratio correctly for maps. This is very
important if you’re plotting spatial data with ggplot2 (which unfortunately
we don’t have the space to cover in this book).</p>
<pre class="sourceCode r"><code class="sourceCode r">nz &lt;-<span class="st"> </span><span class="kw">map_data</span>(<span class="st">&quot;nz&quot;</span>)

<span class="kw">ggplot</span>(nz, <span class="kw">aes</span>(long, lat, <span class="dt">group =</span> group)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_polygon</span>(<span class="dt">fill =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>)

<span class="kw">ggplot</span>(nz, <span class="kw">aes</span>(long, lat, <span class="dt">group =</span> group)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_polygon</span>(<span class="dt">fill =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">colour =</span> <span class="st">&quot;black&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_quickmap</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-46-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-46-2.png" width="50%" /></p></li>
<li><p><code>coord_polar()</code> uses polar coordinates. Polar coordinates reveal an
interesting connection between a bar chart and a Coxcomb chart.</p>
<pre class="sourceCode r"><code class="sourceCode r">bar &lt;-<span class="st"> </span><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(
    <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">fill =</span> cut), 
    <span class="dt">show.legend =</span> <span class="ot">FALSE</span>,
    <span class="dt">width =</span> <span class="dv">1</span>
  ) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">aspect.ratio =</span> <span class="dv">1</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="ot">NULL</span>, <span class="dt">y =</span> <span class="ot">NULL</span>)

bar <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()
bar <span class="op">+</span><span class="st"> </span><span class="kw">coord_polar</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-47-1.png" width="50%" /><img src="visualize_files/figure-html/unnamed-chunk-47-2.png" width="50%" /></p></li>
</ul>
<div id="exercises-6" class="section level3">
<h3><span class="header-section-number">3.9.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Turn a stacked bar chart into a pie chart using <code>coord_polar()</code>.</p></li>
<li><p>What does <code>labs()</code> do? Read the documentation.</p></li>
<li><p>What’s the difference between <code>coord_quickmap()</code> and <code>coord_map()</code>?</p></li>
<li><p>What does the plot below tell you about the relationship between city
and highway mpg? Why is <code>coord_fixed()</code> important? What does
<code>geom_abline()</code> do?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cty, <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_abline</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_fixed</span>()</code></pre>
<p><img src="visualize_files/figure-html/unnamed-chunk-48-1.png" width="50%" style="display: block; margin: auto;" /></p></li>
</ol>
</div>
</div>
<div id="the-layered-grammar-of-graphics" class="section level2">
<h2><span class="header-section-number">3.10</span> The layered grammar of graphics</h2>
<p>In the previous sections, you learned much more than how to make scatterplots, bar charts, and boxplots. You learned a foundation that you can use to make <em>any</em> type of plot with ggplot2. To see this, let’s add position adjustments, stats, coordinate systems, and faceting to our code template:</p>
<pre><code>ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM_FUNCTION&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;
  ) +
  &lt;COORDINATE_FUNCTION&gt; +
  &lt;FACET_FUNCTION&gt;</code></pre>
<p>Our new template takes seven parameters, the bracketed words that appear in the template. In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function.</p>
<p>The seven parameters in the template compose the grammar of graphics, a formal system for building plots. The grammar of graphics is based on the insight that you can uniquely describe <em>any</em> plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.</p>
<p>To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat).</p>
<p><img src="images/visualization-grammar-1.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Next, you could choose a geometric object to represent each observation in the transformed data. You could then use the aesthetic properties of the geoms to represent variables in the data. You would map the values of each variable to the levels of an aesthetic.</p>
<p><img src="images/visualization-grammar-2.png" width="100%" style="display: block; margin: auto;" /></p>
<p>You’d then select a coordinate system to place the geoms into. You’d use the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables. At that point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting). You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment.</p>
<p><img src="images/visualization-grammar-3.png" width="100%" style="display: block; margin: auto;" /></p>
<p>You could use this method to build <em>any</em> plot that you imagine. In other words, you can use the code template that you’ve learned in this chapter to build hundreds of thousands of unique plots.</p>
<!--chapter:end:visualize.Rmd-->
</div>
</div>
<div id="workflow-basics" class="section level1">
<h1><span class="header-section-number">4</span> Workflow: basics</h1>
<p>You now have some experience running R code. I didn’t give you many details, but you’ve obviously figured out the basics, or you would’ve thrown this book away in frustration! Frustration is natural when you start programming in R, because it is such a stickler for punctuation, and even one character out of place will cause it to complain. But while you should expect to be a little frustrated, take comfort in that it’s both typical and temporary: it happens to everyone, and the only way to get over it is to keep trying.</p>
<p>Before we go any further, let’s make sure you’ve got a solid foundation in running R code, and that you know about some of the most helpful RStudio features.</p>
<div id="coding-basics" class="section level2">
<h2><span class="header-section-number">4.1</span> Coding basics</h2>
<p>Let’s review some basics we’ve so far omitted in the interests of getting you plotting as quickly as possible. You can use R as a calculator:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">200</span> <span class="op">*</span><span class="st"> </span><span class="dv">30</span>
<span class="co">#&gt; [1] 0.15</span>
(<span class="dv">59</span> <span class="op">+</span><span class="st"> </span><span class="dv">73</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>) <span class="op">/</span><span class="st"> </span><span class="dv">3</span>
<span class="co">#&gt; [1] 44.7</span>
<span class="kw">sin</span>(pi <span class="op">/</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; [1] 1</span></code></pre>
<p>You can create new objects with <code>&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span><span class="dv">4</span></code></pre>
<p>All R statements where you create objects, <strong>assignment</strong> statements, have the same form:</p>
<pre class="sourceCode r"><code class="sourceCode r">object_name &lt;-<span class="st"> </span>value</code></pre>
<p>When reading that code say “object name gets value” in your head.</p>
<p>You will make lots of assignments and <code>&lt;-</code> is a pain to type. Don’t be lazy and use <code>=</code>: it will work, but it will cause confusion later. Instead, use RStudio’s keyboard shortcut: Alt + - (the minus sign). Notice that RStudio automagically surrounds <code>&lt;-</code> with spaces, which is a good code formatting practice. Code is miserable to read on a good day, so giveyoureyesabreak and use spaces.</p>
</div>
<div id="whats-in-a-name" class="section level2">
<h2><span class="header-section-number">4.2</span> What’s in a name?</h2>
<p>Object names must start with a letter, and can only contain letters, numbers, <code>_</code> and <code>.</code>. You want your object names to be descriptive, so you’ll need a convention for multiple words. I recommend <strong>snake_case</strong> where you separate lowercase words with <code>_</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">i_use_snake_case
otherPeopleUseCamelCase
some.people.use.periods
And_aFew.People_RENOUNCEconvention</code></pre>
<p>We’ll come back to code style later, in <a href="#functions">functions</a>.</p>
<p>You can inspect an object by typing its name:</p>
<pre class="sourceCode r"><code class="sourceCode r">x
<span class="co">#&gt; [1] 12</span></code></pre>
<p>Make another assignment:</p>
<pre class="sourceCode r"><code class="sourceCode r">this_is_a_really_long_name &lt;-<span class="st"> </span><span class="fl">2.5</span></code></pre>
<p>To inspect this object, try out RStudio’s completion facility: type “this”, press TAB, add characters until you have a unique prefix, then press return.</p>
<p>Ooops, you made a mistake! <code>this_is_a_really_long_name</code> should have value 3.5 not 2.5. Use another keyboard shortcut to help you fix it. Type “this” then press Cmd/Ctrl + ↑. That will list all the commands you’ve typed that start those letters. Use the arrow keys to navigate, then press enter to retype the command. Change 2.5 to 3.5 and rerun.</p>
<p>Make yet another assignment:</p>
<pre class="sourceCode r"><code class="sourceCode r">r_rocks &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">^</span><span class="st"> </span><span class="dv">3</span></code></pre>
<p>Let’s try to inspect it:</p>
<pre class="sourceCode r"><code class="sourceCode r">r_rock
<span class="co">#&gt; Error: object &#39;r_rock&#39; not found</span>
R_rocks
<span class="co">#&gt; Error: object &#39;R_rocks&#39; not found</span></code></pre>
<p>There’s an implied contract between you and R: it will do the tedious computation for you, but in return, you must be completely precise in your instructions. Typos matter. Case matters.</p>
</div>
<div id="calling-functions" class="section level2">
<h2><span class="header-section-number">4.3</span> Calling functions</h2>
<p>R has a large collection of built-in functions that are called like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">function_name</span>(<span class="dt">arg1 =</span> val1, <span class="dt">arg2 =</span> val2, ...)</code></pre>
<p>Let’s try using <code>seq()</code> which makes regular <strong>seq</strong>uences of numbers and, while we’re at it, learn more helpful features of RStudio. Type <code>se</code> and hit TAB. A popup shows you possible completions. Specify <code>seq()</code> by typing more (a “q”) to disambiguate, or by using ↑/↓ arrows to select. Notice the floating tooltip that pops up, reminding you of the function’s arguments and purpose. If you want more help, press F1 to get all the details in the help tab in the lower right pane.</p>
<p>Press TAB once more when you’ve selected the function you want. RStudio will add matching opening (<code>(</code>) and closing (<code>)</code>) parentheses for you. Type the arguments <code>1, 10</code> and hit return.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>)
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span></code></pre>
<p>Type this code and notice you get similar assistance with the paired quotation marks:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;hello world&quot;</span></code></pre>
<p>Quotation marks and parentheses must always come in a pair. RStudio does its best to help you, but it’s still possible to mess up and end up with a mismatch. If this happens, R will show you the continuation character “+”:</p>
<pre><code>&gt; x &lt;- &quot;hello
+</code></pre>
<p>The <code>+</code> tells you that R is waiting for more input; it doesn’t think you’re done yet. Usually that means you’ve forgotten either a <code>&quot;</code> or a <code>)</code>. Either add the missing pair, or press ESCAPE to abort the expression and try again.</p>
<p>If you make an assignment, you don’t get to see the value. You’re then tempted to immediately double-check the result:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dt">length.out =</span> <span class="dv">5</span>)
y
<span class="co">#&gt; [1]  1.00  3.25  5.50  7.75 10.00</span></code></pre>
<p>This common action can be shortened by surrounding the assignment with parentheses, which causes assignment and “print to screen” to happen.</p>
<pre class="sourceCode r"><code class="sourceCode r">(y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dt">length.out =</span> <span class="dv">5</span>))
<span class="co">#&gt; [1]  1.00  3.25  5.50  7.75 10.00</span></code></pre>
<p>Now look at your environment in the upper right pane:</p>
<p><img src="screenshots/rstudio-env.png" width="597" style="display: block; margin: auto;" /></p>
<p>Here you can see all of the objects that you’ve created.</p>
</div>
<div id="practice" class="section level2">
<h2><span class="header-section-number">4.4</span> Practice</h2>
<ol style="list-style-type: decimal">
<li><p>Why does this code not work?</p>
<pre class="sourceCode r"><code class="sourceCode r">my_variable &lt;-<span class="st"> </span><span class="dv">10</span>
my_varıable
<span class="co">#&gt; Error in eval(expr, envir, enclos): object &#39;my_varıable&#39; not found</span></code></pre>
<p>Look carefully! (This may seem like an exercise in pointlessness, but
training your brain to notice even the tiniest difference will pay off
when programming.)</p></li>
<li><p>Tweak each of the following R commands so that they run correctly:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)

<span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> displ, <span class="dt">y =</span> hwy))

<span class="kw">fliter</span>(mpg, <span class="dt">cyl =</span> <span class="dv">8</span>)
<span class="kw">filter</span>(diamond, carat <span class="op">&gt;</span><span class="st"> </span><span class="dv">3</span>)</code></pre></li>
<li><p>Press Alt + Shift + K. What happens? How can you get to the same place
using the menus?</p></li>
</ol>
<!--chapter:end:workflow-basics.Rmd-->
</div>
</div>
<div id="transform" class="section level1">
<h1><span class="header-section-number">5</span> Data transformation</h1>
<div id="introduction-2" class="section level2">
<h2><span class="header-section-number">5.1</span> Introduction</h2>
<p>Visualisation is an important tool for insight generation, but it is rare that you get the data in exactly the right form you need. Often you’ll need to create some new variables or summaries, or maybe you just want to rename the variables or reorder the observations in order to make the data a little easier to work with. You’ll learn how to do all that (and more!) in this chapter, which will teach you how to transform your data using the dplyr package and a new dataset on flights departing New York City in 2013.</p>
<div id="prerequisites-2" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Prerequisites</h3>
<p>In this chapter we’re going to focus on how to use the dplyr package, another core member of the tidyverse. We’ll illustrate the key ideas using data from the nycflights13 package, and use ggplot2 to help us understand the data.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(nycflights13)
<span class="kw">library</span>(tidyverse)</code></pre>
<p>Take careful note of the conflicts message that’s printed when you load the tidyverse. It tells you that dplyr overwrites some functions in base R. If you want to use the base version of these functions after loading dplyr, you’ll need to use their full names: <code>stats::filter()</code> and <code>stats::lag()</code>.</p>
</div>
<div id="nycflights13" class="section level3">
<h3><span class="header-section-number">5.1.2</span> nycflights13</h3>
<p>To explore the basic data manipulation verbs of dplyr, we’ll use <code>nycflights13::flights</code>. This data frame contains all 336,776 flights that departed from New York City in 2013. The data comes from the US Bureau of Transportation Statistics<span id="fn8" class="footnote" data-pagedown-footnote-number="8" style="white-space: pre-line;"><a href="http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&amp;Link=0" class="uri">http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&amp;Link=0</a></span>, and is documented in <code>?flights</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights
<span class="co">#&gt; # A tibble: 336,776 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1      533            529         4      850</span>
<span class="co">#&gt; 3  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 4  2013     1     1      544            545        -1     1004</span>
<span class="co">#&gt; 5  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 6  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>You might notice that this data frame prints a little differently from other data frames you might have used in the past: it only shows the first few rows and all the columns that fit on one screen. (To see the whole dataset, you can run <code>View(flights)</code> which will open the dataset in the RStudio viewer). It prints differently because it’s a <strong>tibble</strong>. Tibbles are data frames, but slightly tweaked to work better in the tidyverse. For now, you don’t need to worry about the differences; we’ll come back to tibbles in more detail in <a href="#wrangle-intro">wrangle</a>.</p>
<p>You might also have noticed the row of three (or four) letter abbreviations under the column names. These describe the type of each variable:</p>
<ul>
<li><p><code>int</code> stands for integers.</p></li>
<li><p><code>dbl</code> stands for doubles, or real numbers.</p></li>
<li><p><code>chr</code> stands for character vectors, or strings.</p></li>
<li><p><code>dttm</code> stands for date-times (a date + a time).</p></li>
</ul>
<p>There are three other common types of variables that aren’t used in this dataset but you’ll encounter later in the book:</p>
<ul>
<li><p><code>lgl</code> stands for logical, vectors that contain only <code>TRUE</code> or <code>FALSE</code>.</p></li>
<li><p><code>fctr</code> stands for factors, which R uses to represent categorical variables
with fixed possible values.</p></li>
<li><p><code>date</code> stands for dates.</p></li>
</ul>
</div>
<div id="dplyr-basics" class="section level3">
<h3><span class="header-section-number">5.1.3</span> dplyr basics</h3>
<p>In this chapter you are going to learn the five key dplyr functions that allow you to solve the vast majority of your data manipulation challenges:</p>
<ul>
<li>Pick observations by their values (<code>filter()</code>).</li>
<li>Reorder the rows (<code>arrange()</code>).</li>
<li>Pick variables by their names (<code>select()</code>).</li>
<li>Create new variables with functions of existing variables (<code>mutate()</code>).</li>
<li>Collapse many values down to a single summary (<code>summarise()</code>).</li>
</ul>
<p>These can all be used in conjunction with <code>group_by()</code> which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation.</p>
<p>All verbs work similarly:</p>
<ol style="list-style-type: decimal">
<li><p>The first argument is a data frame.</p></li>
<li><p>The subsequent arguments describe what to do with the data frame,
using the variable names (without quotes).</p></li>
<li><p>The result is a new data frame.</p></li>
</ol>
<p>Together these properties make it easy to chain together multiple simple steps to achieve a complex result. Let’s dive in and see how these verbs work.</p>
</div>
</div>
<div id="filter-rows-with-filter" class="section level2">
<h2><span class="header-section-number">5.2</span> Filter rows with <code>filter()</code></h2>
<p><code>filter()</code> allows you to subset observations based on their values. The first argument is the name of the data frame. The second and subsequent arguments are the expressions that filter the data frame. For example, we can select all flights on January 1st with:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(flights, month <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, day <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 842 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1      533            529         4      850</span>
<span class="co">#&gt; 3  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 4  2013     1     1      544            545        -1     1004</span>
<span class="co">#&gt; 5  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 6  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; # … with 836 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>When you run that line of code, dplyr executes the filtering operation and returns a new data frame. dplyr functions never modify their inputs, so if you want to save the result, you’ll need to use the assignment operator, <code>&lt;-</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">jan1 &lt;-<span class="st"> </span><span class="kw">filter</span>(flights, month <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, day <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)</code></pre>
<p>R either prints out the results, or saves them to a variable. If you want to do both, you can wrap the assignment in parentheses:</p>
<pre class="sourceCode r"><code class="sourceCode r">(dec25 &lt;-<span class="st"> </span><span class="kw">filter</span>(flights, month <span class="op">==</span><span class="st"> </span><span class="dv">12</span>, day <span class="op">==</span><span class="st"> </span><span class="dv">25</span>))
<span class="co">#&gt; # A tibble: 719 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013    12    25      456            500        -4      649</span>
<span class="co">#&gt; 2  2013    12    25      524            515         9      805</span>
<span class="co">#&gt; 3  2013    12    25      542            540         2      832</span>
<span class="co">#&gt; 4  2013    12    25      546            550        -4     1022</span>
<span class="co">#&gt; 5  2013    12    25      556            600        -4      730</span>
<span class="co">#&gt; 6  2013    12    25      557            600        -3      743</span>
<span class="co">#&gt; # … with 713 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<div id="comparisons" class="section level3">
<h3><span class="header-section-number">5.2.1</span> Comparisons</h3>
<p>To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> (not equal), and <code>==</code> (equal).</p>
<p>When you’re starting out with R, the easiest mistake to make is to use <code>=</code> instead of <code>==</code> when testing for equality. When this happens you’ll get an informative error:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(flights, <span class="dt">month =</span> <span class="dv">1</span>)
<span class="co">#&gt; Error: `month` (`month = 1`) must not be named, do you need `==`?</span></code></pre>
<p>There’s another common problem you might encounter when using <code>==</code>: floating point numbers. These results might surprise you!</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sqrt</span>(<span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] FALSE</span>
<span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">49</span> <span class="op">*</span><span class="st"> </span><span class="dv">49</span> <span class="op">==</span><span class="st"> </span><span class="dv">1</span>
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>Computers use finite precision arithmetic (they obviously can’t store an infinite number of digits!) so remember that every number you see is an approximation. Instead of relying on <code>==</code>, use <code>near()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">near</span>(<span class="kw">sqrt</span>(<span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>,  <span class="dv">2</span>)
<span class="co">#&gt; [1] TRUE</span>
<span class="kw">near</span>(<span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">49</span> <span class="op">*</span><span class="st"> </span><span class="dv">49</span>, <span class="dv">1</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
</div>
<div id="logical-operators" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Logical operators</h3>
<p>Multiple arguments to <code>filter()</code> are combined with “and”: every expression must be true in order for a row to be included in the output. For other types of combinations, you’ll need to use Boolean operators yourself: <code>&amp;</code> is “and”, <code>|</code> is “or”, and <code>!</code> is “not”. Figure <a href="#fig:bool-ops">5.1</a> shows the complete set of Boolean operations.</p>
<div class="figure" style="text-align: center"><span id="fig:bool-ops"></span>
<img src="diagrams/transform-logical.png" alt="Complete set of boolean operations. `x` is the left-hand circle, `y` is the right-hand circle, and the shaded region show which parts each operator selects." width="70%" />
<p class="caption">
Figure 5.1: Complete set of boolean operations. <code>x</code> is the left-hand circle, <code>y</code> is the right-hand circle, and the shaded region show which parts each operator selects.
</p>
</div>
<p>The following code finds all flights that departed in November or December:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(flights, month <span class="op">==</span><span class="st"> </span><span class="dv">11</span> <span class="op">|</span><span class="st"> </span>month <span class="op">==</span><span class="st"> </span><span class="dv">12</span>)</code></pre>
<p>The order of operations doesn’t work like English. You can’t write <code>filter(flights, month == 11 | 12)</code>, which you might literally translate into “finds all flights that departed in November or December”. Instead it finds all months that equal <code>11 | 12</code>, an expression that evaluates to <code>TRUE</code>. In a numeric context (like here), <code>TRUE</code> becomes one, so this finds all flights in January, not November or December. This is quite confusing!</p>
<p>A useful short-hand for this problem is <code>x %in% y</code>. This will select every row where <code>x</code> is one of the values in <code>y</code>. We could use it to rewrite the code above:</p>
<pre class="sourceCode r"><code class="sourceCode r">nov_dec &lt;-<span class="st"> </span><span class="kw">filter</span>(flights, month <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">11</span>, <span class="dv">12</span>))</code></pre>
<p>Sometimes you can simplify complicated subsetting by remembering De Morgan’s law: <code>!(x &amp; y)</code> is the same as <code>!x | !y</code>, and <code>!(x | y)</code> is the same as <code>!x &amp; !y</code>. For example, if you wanted to find flights that weren’t delayed (on arrival or departure) by more than two hours, you could use either of the following two filters:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">filter</span>(flights, <span class="op">!</span>(arr_delay <span class="op">&gt;</span><span class="st"> </span><span class="dv">120</span> <span class="op">|</span><span class="st"> </span>dep_delay <span class="op">&gt;</span><span class="st"> </span><span class="dv">120</span>))
<span class="kw">filter</span>(flights, arr_delay <span class="op">&lt;=</span><span class="st"> </span><span class="dv">120</span>, dep_delay <span class="op">&lt;=</span><span class="st"> </span><span class="dv">120</span>)</code></pre>
<p>As well as <code>&amp;</code> and <code>|</code>, R also has <code>&amp;&amp;</code> and <code>||</code>. Don’t use them here! You’ll learn when you should use them in <a href="#conditional-execution">conditional execution</a>.</p>
<p>Whenever you start using complicated, multipart expressions in <code>filter()</code>, consider making them explicit variables instead. That makes it much easier to check your work. You’ll learn how to create new variables shortly.</p>
</div>
<div id="missing-values" class="section level3">
<h3><span class="header-section-number">5.2.3</span> Missing values</h3>
<p>One important feature of R that can make comparison tricky are missing values, or <code>NA</code>s (“not availables”). <code>NA</code> represents an unknown value so missing values are “contagious”: almost any operation involving an unknown value will also be unknown.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="ot">NA</span> <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>
<span class="co">#&gt; [1] NA</span>
<span class="dv">10</span> <span class="op">==</span><span class="st"> </span><span class="ot">NA</span>
<span class="co">#&gt; [1] NA</span>
<span class="ot">NA</span> <span class="op">+</span><span class="st"> </span><span class="dv">10</span>
<span class="co">#&gt; [1] NA</span>
<span class="ot">NA</span> <span class="op">/</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] NA</span></code></pre>
<p>The most confusing result is this one:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="ot">NA</span> <span class="op">==</span><span class="st"> </span><span class="ot">NA</span>
<span class="co">#&gt; [1] NA</span></code></pre>
<p>It’s easiest to understand why this is true with a bit more context:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Let x be Mary&#39;s age. We don&#39;t know how old she is.</span>
x &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="co"># Let y be John&#39;s age. We don&#39;t know how old he is.</span>
y &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="co"># Are John and Mary the same age?</span>
x <span class="op">==</span><span class="st"> </span>y
<span class="co">#&gt; [1] NA</span>
<span class="co"># We don&#39;t know!</span></code></pre>
<p>If you want to determine if a value is missing, use <code>is.na()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.na</span>(x)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p><code>filter()</code> only includes rows where the condition is <code>TRUE</code>; it excludes both <code>FALSE</code> and <code>NA</code> values. If you want to preserve missing values, ask for them explicitly:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="ot">NA</span>, <span class="dv">3</span>))
<span class="kw">filter</span>(df, x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 1 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1     3</span>
<span class="kw">filter</span>(df, <span class="kw">is.na</span>(x) <span class="op">|</span><span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 2 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1    NA</span>
<span class="co">#&gt; 2     3</span></code></pre>
</div>
<div id="exercises-7" class="section level3">
<h3><span class="header-section-number">5.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Find all flights that</p>
<ol style="list-style-type: decimal">
<li>Had an arrival delay of two or more hours</li>
<li>Flew to Houston (<code>IAH</code> or <code>HOU</code>)</li>
<li>Were operated by United, American, or Delta</li>
<li>Departed in summer (July, August, and September)</li>
<li>Arrived more than two hours late, but didn’t leave late</li>
<li>Were delayed by at least an hour, but made up over 30 minutes in flight</li>
<li>Departed between midnight and 6am (inclusive)</li>
</ol></li>
<li><p>Another useful dplyr filtering helper is <code>between()</code>. What does it do?
Can you use it to simplify the code needed to answer the previous
challenges?</p></li>
<li><p>How many flights have a missing <code>dep_time</code>? What other variables are
missing? What might these rows represent?</p></li>
<li><p>Why is <code>NA ^ 0</code> not missing? Why is <code>NA | TRUE</code> not missing?
Why is <code>FALSE &amp; NA</code> not missing? Can you figure out the general
rule? (<code>NA * 0</code> is a tricky counterexample!)</p></li>
</ol>
</div>
</div>
<div id="arrange-rows-with-arrange" class="section level2">
<h2><span class="header-section-number">5.3</span> Arrange rows with <code>arrange()</code></h2>
<p><code>arrange()</code> works similarly to <code>filter()</code> except that instead of selecting rows, it changes their order. It takes a data frame and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">arrange</span>(flights, year, month, day)
<span class="co">#&gt; # A tibble: 336,776 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1      533            529         4      850</span>
<span class="co">#&gt; 3  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 4  2013     1     1      544            545        -1     1004</span>
<span class="co">#&gt; 5  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 6  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>Use <code>desc()</code> to re-order by a column in descending order:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">arrange</span>(flights, <span class="kw">desc</span>(dep_delay))
<span class="co">#&gt; # A tibble: 336,776 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     9      641            900      1301     1242</span>
<span class="co">#&gt; 2  2013     6    15     1432           1935      1137     1607</span>
<span class="co">#&gt; 3  2013     1    10     1121           1635      1126     1239</span>
<span class="co">#&gt; 4  2013     9    20     1139           1845      1014     1457</span>
<span class="co">#&gt; 5  2013     7    22      845           1600      1005     1044</span>
<span class="co">#&gt; 6  2013     4    10     1100           1900       960     1342</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>Missing values are always sorted at the end:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="ot">NA</span>))
<span class="kw">arrange</span>(df, x)
<span class="co">#&gt; # A tibble: 3 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1     2</span>
<span class="co">#&gt; 2     5</span>
<span class="co">#&gt; 3    NA</span>
<span class="kw">arrange</span>(df, <span class="kw">desc</span>(x))
<span class="co">#&gt; # A tibble: 3 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1     5</span>
<span class="co">#&gt; 2     2</span>
<span class="co">#&gt; 3    NA</span></code></pre>
<div id="exercises-8" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How could you use <code>arrange()</code> to sort all missing values to the start?
(Hint: use <code>is.na()</code>).</p></li>
<li><p>Sort <code>flights</code> to find the most delayed flights. Find the flights that
left earliest.</p></li>
<li><p>Sort <code>flights</code> to find the fastest flights.</p></li>
<li><p>Which flights travelled the longest? Which travelled the shortest?</p></li>
</ol>
</div>
</div>
<div id="select" class="section level2">
<h2><span class="header-section-number">5.4</span> Select columns with <code>select()</code></h2>
<p>It’s not uncommon to get datasets with hundreds or even thousands of variables. In this case, the first challenge is often narrowing in on the variables you’re actually interested in. <code>select()</code> allows you to rapidly zoom in on a useful subset using operations based on the names of the variables.</p>
<p><code>select()</code> is not terribly useful with the flights data because we only have 19 variables, but you can still get the general idea:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Select columns by name</span>
<span class="kw">select</span>(flights, year, month, day)
<span class="co">#&gt; # A tibble: 336,776 x 3</span>
<span class="co">#&gt;    year month   day</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1</span>
<span class="co">#&gt; 2  2013     1     1</span>
<span class="co">#&gt; 3  2013     1     1</span>
<span class="co">#&gt; 4  2013     1     1</span>
<span class="co">#&gt; 5  2013     1     1</span>
<span class="co">#&gt; 6  2013     1     1</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span>
<span class="co"># Select all columns between year and day (inclusive)</span>
<span class="kw">select</span>(flights, year<span class="op">:</span>day)
<span class="co">#&gt; # A tibble: 336,776 x 3</span>
<span class="co">#&gt;    year month   day</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1</span>
<span class="co">#&gt; 2  2013     1     1</span>
<span class="co">#&gt; 3  2013     1     1</span>
<span class="co">#&gt; 4  2013     1     1</span>
<span class="co">#&gt; 5  2013     1     1</span>
<span class="co">#&gt; 6  2013     1     1</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span>
<span class="co"># Select all columns except those from year to day (inclusive)</span>
<span class="kw">select</span>(flights, <span class="op">-</span>(year<span class="op">:</span>day))
<span class="co">#&gt; # A tibble: 336,776 x 16</span>
<span class="co">#&gt;   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay</span>
<span class="co">#&gt;      &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1      517            515         2      830            819        11</span>
<span class="co">#&gt; 2      533            529         4      850            830        20</span>
<span class="co">#&gt; 3      542            540         2      923            850        33</span>
<span class="co">#&gt; 4      544            545        -1     1004           1022       -18</span>
<span class="co">#&gt; 5      554            600        -6      812            837       -25</span>
<span class="co">#&gt; 6      554            558        -4      740            728        12</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 10 more variables: carrier &lt;chr&gt;,</span>
<span class="co">#&gt; #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,</span>
<span class="co">#&gt; #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>There are a number of helper functions you can use within <code>select()</code>:</p>
<ul>
<li><p><code>starts_with(&quot;abc&quot;)</code>: matches names that begin with “abc”.</p></li>
<li><p><code>ends_with(&quot;xyz&quot;)</code>: matches names that end with “xyz”.</p></li>
<li><p><code>contains(&quot;ijk&quot;)</code>: matches names that contain “ijk”.</p></li>
<li><p><code>matches(&quot;(.)\\1&quot;)</code>: selects variables that match a regular expression.
This one matches any variables that contain repeated characters. You’ll
learn more about regular expressions in <a href="#strings">strings</a>.</p></li>
<li><p><code>num_range(&quot;x&quot;, 1:3)</code>: matches <code>x1</code>, <code>x2</code> and <code>x3</code>.</p></li>
</ul>
<p>See <code>?select</code> for more details.</p>
<p><code>select()</code> can be used to rename variables, but it’s rarely useful because it drops all of the variables not explicitly mentioned. Instead, use <code>rename()</code>, which is a variant of <code>select()</code> that keeps all the variables that aren’t explicitly mentioned:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rename</span>(flights, <span class="dt">tail_num =</span> tailnum)
<span class="co">#&gt; # A tibble: 336,776 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1      533            529         4      850</span>
<span class="co">#&gt; 3  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 4  2013     1     1      544            545        -1     1004</span>
<span class="co">#&gt; 5  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 6  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tail_num &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>Another option is to use <code>select()</code> in conjunction with the <code>everything()</code> helper. This is useful if you have a handful of variables you’d like to move to the start of the data frame.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">select</span>(flights, time_hour, air_time, <span class="kw">everything</span>())
<span class="co">#&gt; # A tibble: 336,776 x 19</span>
<span class="co">#&gt;   time_hour           air_time  year month   day dep_time sched_dep_time</span>
<span class="co">#&gt;   &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;</span>
<span class="co">#&gt; 1 2013-01-01 05:00:00      227  2013     1     1      517            515</span>
<span class="co">#&gt; 2 2013-01-01 05:00:00      227  2013     1     1      533            529</span>
<span class="co">#&gt; 3 2013-01-01 05:00:00      160  2013     1     1      542            540</span>
<span class="co">#&gt; 4 2013-01-01 05:00:00      183  2013     1     1      544            545</span>
<span class="co">#&gt; 5 2013-01-01 06:00:00      116  2013     1     1      554            600</span>
<span class="co">#&gt; 6 2013-01-01 05:00:00      150  2013     1     1      554            558</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 12 more variables: dep_delay &lt;dbl&gt;,</span>
<span class="co">#&gt; #   arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,</span>
<span class="co">#&gt; #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;,</span>
<span class="co">#&gt; #   hour &lt;dbl&gt;, minute &lt;dbl&gt;</span></code></pre>
<div id="exercises-9" class="section level3">
<h3><span class="header-section-number">5.4.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Brainstorm as many ways as possible to select <code>dep_time</code>, <code>dep_delay</code>,
<code>arr_time</code>, and <code>arr_delay</code> from <code>flights</code>.</p></li>
<li><p>What happens if you include the name of a variable multiple times in
a <code>select()</code> call?</p></li>
<li><p>What does the <code>one_of()</code> function do? Why might it be helpful in conjunction
with this vector?</p>
<pre class="sourceCode r"><code class="sourceCode r">vars &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;year&quot;</span>, <span class="st">&quot;month&quot;</span>, <span class="st">&quot;day&quot;</span>, <span class="st">&quot;dep_delay&quot;</span>, <span class="st">&quot;arr_delay&quot;</span>)</code></pre></li>
<li><p>Does the result of running the following code surprise you? How do the
select helpers deal with case by default? How can you change that default?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">select</span>(flights, <span class="kw">contains</span>(<span class="st">&quot;TIME&quot;</span>))</code></pre></li>
</ol>
</div>
</div>
<div id="add-new-variables-with-mutate" class="section level2">
<h2><span class="header-section-number">5.5</span> Add new variables with <code>mutate()</code></h2>
<p>Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. That’s the job of <code>mutate()</code>.</p>
<p><code>mutate()</code> always adds new columns at the end of your dataset so we’ll start by creating a narrower dataset so we can see the new variables. Remember that when you’re in RStudio, the easiest way to see all the columns is <code>View()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_sml &lt;-<span class="st"> </span><span class="kw">select</span>(flights, 
  year<span class="op">:</span>day, 
  <span class="kw">ends_with</span>(<span class="st">&quot;delay&quot;</span>), 
  distance, 
  air_time
)
<span class="kw">mutate</span>(flights_sml,
  <span class="dt">gain =</span> dep_delay <span class="op">-</span><span class="st"> </span>arr_delay,
  <span class="dt">speed =</span> distance <span class="op">/</span><span class="st"> </span>air_time <span class="op">*</span><span class="st"> </span><span class="dv">60</span>
)
<span class="co">#&gt; # A tibble: 336,776 x 9</span>
<span class="co">#&gt;    year month   day dep_delay arr_delay distance air_time  gain speed</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1         2        11     1400      227    -9  370.</span>
<span class="co">#&gt; 2  2013     1     1         4        20     1416      227   -16  374.</span>
<span class="co">#&gt; 3  2013     1     1         2        33     1089      160   -31  408.</span>
<span class="co">#&gt; 4  2013     1     1        -1       -18     1576      183    17  517.</span>
<span class="co">#&gt; 5  2013     1     1        -6       -25      762      116    19  394.</span>
<span class="co">#&gt; 6  2013     1     1        -4        12      719      150   -16  288.</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>Note that you can refer to columns that you’ve just created:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mutate</span>(flights_sml,
  <span class="dt">gain =</span> dep_delay <span class="op">-</span><span class="st"> </span>arr_delay,
  <span class="dt">hours =</span> air_time <span class="op">/</span><span class="st"> </span><span class="dv">60</span>,
  <span class="dt">gain_per_hour =</span> gain <span class="op">/</span><span class="st"> </span>hours
)
<span class="co">#&gt; # A tibble: 336,776 x 10</span>
<span class="co">#&gt;    year month   day dep_delay arr_delay distance air_time  gain hours</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1         2        11     1400      227    -9  3.78</span>
<span class="co">#&gt; 2  2013     1     1         4        20     1416      227   -16  3.78</span>
<span class="co">#&gt; 3  2013     1     1         2        33     1089      160   -31  2.67</span>
<span class="co">#&gt; 4  2013     1     1        -1       -18     1576      183    17  3.05</span>
<span class="co">#&gt; 5  2013     1     1        -6       -25      762      116    19  1.93</span>
<span class="co">#&gt; 6  2013     1     1        -4        12      719      150   -16  2.5 </span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt;</span></code></pre>
<p>If you only want to keep the new variables, use <code>transmute()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">transmute</span>(flights,
  <span class="dt">gain =</span> dep_delay <span class="op">-</span><span class="st"> </span>arr_delay,
  <span class="dt">hours =</span> air_time <span class="op">/</span><span class="st"> </span><span class="dv">60</span>,
  <span class="dt">gain_per_hour =</span> gain <span class="op">/</span><span class="st"> </span>hours
)
<span class="co">#&gt; # A tibble: 336,776 x 3</span>
<span class="co">#&gt;    gain hours gain_per_hour</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt; 1    -9  3.78         -2.38</span>
<span class="co">#&gt; 2   -16  3.78         -4.23</span>
<span class="co">#&gt; 3   -31  2.67        -11.6 </span>
<span class="co">#&gt; 4    17  3.05          5.57</span>
<span class="co">#&gt; 5    19  1.93          9.83</span>
<span class="co">#&gt; 6   -16  2.5          -6.4 </span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<div id="mutate-funs" class="section level3">
<h3><span class="header-section-number">5.5.1</span> Useful creation functions</h3>
<p>There are many functions for creating new variables that you can use with <code>mutate()</code>. The key property is that the function must be vectorised: it must take a vector of values as input, return a vector with the same number of values as output. There’s no way to list every possible function that you might use, but here’s a selection of functions that are frequently useful:</p>
<ul>
<li><p>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>. These are all vectorised,
using the so called “recycling rules”. If one parameter is shorter than
the other, it will be automatically extended to be the same length. This
is most useful when one of the arguments is a single number: <code>air_time / 60</code>,
<code>hours * 60 + minute</code>, etc.</p>
<p>Arithmetic operators are also useful in conjunction with the aggregate
functions you’ll learn about later. For example, <code>x / sum(x)</code> calculates
the proportion of a total, and <code>y - mean(y)</code> computes the difference from
the mean.</p></li>
<li><p>Modular arithmetic: <code>%/%</code> (integer division) and <code>%%</code> (remainder), where
<code>x == y * (x %/% y) + (x %% y)</code>. Modular arithmetic is a handy tool because
it allows you to break integers up into pieces. For example, in the
flights dataset, you can compute <code>hour</code> and <code>minute</code> from <code>dep_time</code> with:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">transmute</span>(flights,
  dep_time,
  <span class="dt">hour =</span> dep_time <span class="op">%/%</span><span class="st"> </span><span class="dv">100</span>,
  <span class="dt">minute =</span> dep_time <span class="op">%%</span><span class="st"> </span><span class="dv">100</span>
)
<span class="co">#&gt; # A tibble: 336,776 x 3</span>
<span class="co">#&gt;   dep_time  hour minute</span>
<span class="co">#&gt;      &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1      517     5     17</span>
<span class="co">#&gt; 2      533     5     33</span>
<span class="co">#&gt; 3      542     5     42</span>
<span class="co">#&gt; 4      544     5     44</span>
<span class="co">#&gt; 5      554     5     54</span>
<span class="co">#&gt; 6      554     5     54</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre></li>
<li><p>Logs: <code>log()</code>, <code>log2()</code>, <code>log10()</code>. Logarithms are an incredibly useful
transformation for dealing with data that ranges across multiple orders of
magnitude. They also convert multiplicative relationships to additive, a
feature we’ll come back to in modelling.</p>
<p>All else being equal, I recommend using <code>log2()</code> because it’s easy to
interpret: a difference of 1 on the log scale corresponds to doubling on
the original scale and a difference of -1 corresponds to halving.</p></li>
<li><p>Offsets: <code>lead()</code> and <code>lag()</code> allow you to refer to leading or lagging
values. This allows you to compute running differences (e.g. <code>x - lag(x)</code>)
or find when values change (<code>x != lag(x)</code>). They are most useful in
conjunction with <code>group_by()</code>, which you’ll learn about shortly.</p>
<pre class="sourceCode r"><code class="sourceCode r">(x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span>
<span class="kw">lag</span>(x)
<span class="co">#&gt;  [1] NA  1  2  3  4  5  6  7  8  9</span>
<span class="kw">lead</span>(x)
<span class="co">#&gt;  [1]  2  3  4  5  6  7  8  9 10 NA</span></code></pre></li>
<li><p>Cumulative and rolling aggregates: R provides functions for running sums,
products, mins and maxes: <code>cumsum()</code>, <code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>;
and dplyr provides <code>cummean()</code> for cumulative means. If you need rolling
aggregates (i.e. a sum computed over a rolling window), try the RcppRoll
package.</p>
<pre class="sourceCode r"><code class="sourceCode r">x
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span>
<span class="kw">cumsum</span>(x)
<span class="co">#&gt;  [1]  1  3  6 10 15 21 28 36 45 55</span>
<span class="kw">cummean</span>(x)
<span class="co">#&gt;  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5</span></code></pre></li>
<li><p>Logical comparisons, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, and <code>==</code>, which you learned about
earlier. If you’re doing a complex sequence of logical operations it’s
often a good idea to store the interim values in new variables so you can
check that each step is working as expected.</p></li>
<li><p>Ranking: there are a number of ranking functions, but you should
start with <code>min_rank()</code>. It does the most usual type of ranking
(e.g. 1st, 2nd, 2nd, 4th). The default gives smallest values the small
ranks; use <code>desc(x)</code> to give the largest values the smallest ranks.</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="ot">NA</span>, <span class="dv">3</span>, <span class="dv">4</span>)
<span class="kw">min_rank</span>(y)
<span class="co">#&gt; [1]  1  2  2 NA  4  5</span>
<span class="kw">min_rank</span>(<span class="kw">desc</span>(y))
<span class="co">#&gt; [1]  5  3  3 NA  2  1</span></code></pre>
<p>If <code>min_rank()</code> doesn’t do what you need, look at the variants
<code>row_number()</code>, <code>dense_rank()</code>, <code>percent_rank()</code>, <code>cume_dist()</code>,
<code>ntile()</code>. See their help pages for more details.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">row_number</span>(y)
<span class="co">#&gt; [1]  1  2  3 NA  4  5</span>
<span class="kw">dense_rank</span>(y)
<span class="co">#&gt; [1]  1  2  2 NA  3  4</span>
<span class="kw">percent_rank</span>(y)
<span class="co">#&gt; [1] 0.00 0.25 0.25   NA 0.75 1.00</span>
<span class="kw">cume_dist</span>(y)
<span class="co">#&gt; [1] 0.2 0.6 0.6  NA 0.8 1.0</span></code></pre></li>
</ul>
</div>
<div id="exercises-10" class="section level3">
<h3><span class="header-section-number">5.5.2</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Currently <code>dep_time</code> and <code>sched_dep_time</code> are convenient to look at, but
hard to compute with because they’re not really continuous numbers.
Convert them to a more convenient representation of number of minutes
since midnight.</p></li>
<li><p>Compare <code>air_time</code> with <code>arr_time - dep_time</code>. What do you expect to see?
What do you see? What do you need to do to fix it?</p></li>
<li><p>Compare <code>dep_time</code>, <code>sched_dep_time</code>, and <code>dep_delay</code>. How would you
expect those three numbers to be related?</p></li>
<li><p>Find the 10 most delayed flights using a ranking function. How do you want
to handle ties? Carefully read the documentation for <code>min_rank()</code>.</p></li>
<li><p>What does <code>1:3 + 1:10</code> return? Why?</p></li>
<li><p>What trigonometric functions does R provide?</p></li>
</ol>
</div>
</div>
<div id="grouped-summaries-with-summarise" class="section level2">
<h2><span class="header-section-number">5.6</span> Grouped summaries with <code>summarise()</code></h2>
<p>The last key verb is <code>summarise()</code>. It collapses a data frame to a single row:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summarise</span>(flights, <span class="dt">delay =</span> <span class="kw">mean</span>(dep_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; # A tibble: 1 x 1</span>
<span class="co">#&gt;   delay</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1  12.6</span></code></pre>
<p>(We’ll come back to what that <code>na.rm = TRUE</code> means very shortly.)</p>
<p><code>summarise()</code> is not terribly useful unless we pair it with <code>group_by()</code>. This changes the unit of analysis from the complete dataset to individual groups. Then, when you use the dplyr verbs on a grouped data frame they’ll be automatically applied “by group”. For example, if we applied exactly the same code to a data frame grouped by date, we get the average delay per date:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_day &lt;-<span class="st"> </span><span class="kw">group_by</span>(flights, year, month, day)
<span class="kw">summarise</span>(by_day, <span class="dt">delay =</span> <span class="kw">mean</span>(dep_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day delay</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1 11.5 </span>
<span class="co">#&gt; 2  2013     1     2 13.9 </span>
<span class="co">#&gt; 3  2013     1     3 11.0 </span>
<span class="co">#&gt; 4  2013     1     4  8.95</span>
<span class="co">#&gt; 5  2013     1     5  5.73</span>
<span class="co">#&gt; 6  2013     1     6  7.15</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre>
<p>Together <code>group_by()</code> and <code>summarise()</code> provide one of the tools that you’ll use most commonly when working with dplyr: grouped summaries. But before we go any further with this, we need to introduce a powerful new idea: the pipe.</p>
<div id="combining-multiple-operations-with-the-pipe" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Combining multiple operations with the pipe</h3>
<p>Imagine that we want to explore the relationship between the distance and average delay for each location. Using what you know about dplyr, you might write code like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_dest &lt;-<span class="st"> </span><span class="kw">group_by</span>(flights, dest)
delay &lt;-<span class="st"> </span><span class="kw">summarise</span>(by_dest,
  <span class="dt">count =</span> <span class="kw">n</span>(),
  <span class="dt">dist =</span> <span class="kw">mean</span>(distance, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
  <span class="dt">delay =</span> <span class="kw">mean</span>(arr_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
)
delay &lt;-<span class="st"> </span><span class="kw">filter</span>(delay, count <span class="op">&gt;</span><span class="st"> </span><span class="dv">20</span>, dest <span class="op">!=</span><span class="st"> &quot;HNL&quot;</span>)

<span class="co"># It looks like delays increase with distance up to ~750 miles </span>
<span class="co"># and then decrease. Maybe as flights get longer there&#39;s more </span>
<span class="co"># ability to make up delays in the air?</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> delay, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> dist, <span class="dt">y =</span> delay)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">size =</span> count), <span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</span></code></pre>
<p><img src="transform_files/figure-html/unnamed-chunk-36-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are three steps to prepare this data:</p>
<ol style="list-style-type: decimal">
<li><p>Group flights by destination.</p></li>
<li><p>Summarise to compute distance, average delay, and number of flights.</p></li>
<li><p>Filter to remove noisy points and Honolulu airport, which is almost
twice as far away as the next closest airport.</p></li>
</ol>
<p>This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don’t care about it. Naming things is hard, so this slows down our analysis.</p>
<p>There’s another way to tackle the same problem with the pipe, <code>%&gt;%</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">delays &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">count =</span> <span class="kw">n</span>(),
    <span class="dt">dist =</span> <span class="kw">mean</span>(distance, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">delay =</span> <span class="kw">mean</span>(arr_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(count <span class="op">&gt;</span><span class="st"> </span><span class="dv">20</span>, dest <span class="op">!=</span><span class="st"> &quot;HNL&quot;</span>)</code></pre>
<p>This focuses on the transformations, not what’s being transformed, which makes the code easier to read. You can read it as a series of imperative statements: group, then summarise, then filter. As suggested by this reading, a good way to pronounce <code>%&gt;%</code> when reading code is “then”.</p>
<p>Behind the scenes, <code>x %&gt;% f(y)</code> turns into <code>f(x, y)</code>, and <code>x %&gt;% f(y) %&gt;% g(z)</code> turns into <code>g(f(x, y), z)</code> and so on. You can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom. We’ll use piping frequently from now on because it considerably improves the readability of code, and we’ll come back to it in more detail in <a href="#pipes">pipes</a>.</p>
<p>Working with the pipe is one of the key criteria for belonging to the tidyverse. The only exception is ggplot2: it was written before the pipe was discovered. Unfortunately, the next iteration of ggplot2, ggvis, which does use the pipe, isn’t quite ready for prime time yet.</p>
</div>
<div id="missing-values-1" class="section level3">
<h3><span class="header-section-number">5.6.2</span> Missing values</h3>
<p>You may have wondered about the <code>na.rm</code> argument we used above. What happens if we don’t set it?</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(dep_delay))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day  mean</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1    NA</span>
<span class="co">#&gt; 2  2013     1     2    NA</span>
<span class="co">#&gt; 3  2013     1     3    NA</span>
<span class="co">#&gt; 4  2013     1     4    NA</span>
<span class="co">#&gt; 5  2013     1     5    NA</span>
<span class="co">#&gt; 6  2013     1     6    NA</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre>
<p>We get a lot of missing values! That’s because aggregation functions obey the usual rule of missing values: if there’s any missing value in the input, the output will be a missing value. Fortunately, all aggregation functions have an <code>na.rm</code> argument which removes the missing values prior to computation:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(dep_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day  mean</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1 11.5 </span>
<span class="co">#&gt; 2  2013     1     2 13.9 </span>
<span class="co">#&gt; 3  2013     1     3 11.0 </span>
<span class="co">#&gt; 4  2013     1     4  8.95</span>
<span class="co">#&gt; 5  2013     1     5  5.73</span>
<span class="co">#&gt; 6  2013     1     6  7.15</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre>
<p>In this case, where missing values represent cancelled flights, we could also tackle the problem by first removing the cancelled flights. We’ll save this dataset so we can reuse it in the next few examples.</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(dep_delay), <span class="op">!</span><span class="kw">is.na</span>(arr_delay))

not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(dep_delay))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day  mean</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1 11.4 </span>
<span class="co">#&gt; 2  2013     1     2 13.7 </span>
<span class="co">#&gt; 3  2013     1     3 10.9 </span>
<span class="co">#&gt; 4  2013     1     4  8.97</span>
<span class="co">#&gt; 5  2013     1     5  5.73</span>
<span class="co">#&gt; 6  2013     1     6  7.15</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre>
</div>
<div id="counts" class="section level3">
<h3><span class="header-section-number">5.6.3</span> Counts</h3>
<p>Whenever you do any aggregation, it’s always a good idea to include either a count (<code>n()</code>), or a count of non-missing values (<code>sum(!is.na(x))</code>). That way you can check that you’re not drawing conclusions based on very small amounts of data. For example, let’s look at the planes (identified by their tail number) that have the highest average delays:</p>
<pre class="sourceCode r"><code class="sourceCode r">delays &lt;-<span class="st"> </span>not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(tailnum) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">delay =</span> <span class="kw">mean</span>(arr_delay)
  )

<span class="kw">ggplot</span>(<span class="dt">data =</span> delays, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> delay)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="dv">10</span>)</code></pre>
<p><img src="transform_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Wow, there are some planes that have an <em>average</em> delay of 5 hours (300 minutes)!</p>
<p>The story is actually a little more nuanced. We can get more insight if we draw a scatterplot of number of flights vs. average delay:</p>
<pre class="sourceCode r"><code class="sourceCode r">delays &lt;-<span class="st"> </span>not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(tailnum) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">delay =</span> <span class="kw">mean</span>(arr_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">n =</span> <span class="kw">n</span>()
  )

<span class="kw">ggplot</span>(<span class="dt">data =</span> delays, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> n, <span class="dt">y =</span> delay)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">10</span>)</code></pre>
<p><img src="transform_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Not surprisingly, there is much greater variation in the average delay when there are few flights. The shape of this plot is very characteristic: whenever you plot a mean (or other summary) vs. group size, you’ll see that the variation decreases as the sample size increases.</p>
<p>When looking at this sort of plot, it’s often useful to filter out the groups with the smallest numbers of observations, so you can see more of the pattern and less of the extreme variation in the smallest groups. This is what the following code does, as well as showing you a handy pattern for integrating ggplot2 into dplyr flows. It’s a bit painful that you have to switch from <code>%&gt;%</code> to <code>+</code>, but once you get the hang of it, it’s quite convenient.</p>
<pre class="sourceCode r"><code class="sourceCode r">delays <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">25</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> n, <span class="dt">y =</span> delay)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">10</span>)</code></pre>
<p><img src="transform_files/figure-html/unnamed-chunk-43-1.png" width="70%" style="display: block; margin: auto;" /></p>
<hr />
<p>RStudio tip: a useful keyboard shortcut is Cmd/Ctrl + Shift + P. This resends the previously sent chunk from the editor to the console. This is very convenient when you’re (e.g.) exploring the value of <code>n</code> in the example above. You send the whole block once with Cmd/Ctrl + Enter, then you modify the value of <code>n</code> and press Cmd/Ctrl + Shift + P to resend the complete block.</p>
<hr />
<p>There’s another common variation of this type of pattern. Let’s look at how the average performance of batters in baseball is related to the number of times they’re at bat. Here I use data from the <strong>Lahman</strong> package to compute the batting average (number of hits / number of attempts) of every major league baseball player.</p>
<p>When I plot the skill of the batter (measured by the batting average, <code>ba</code>) against the number of opportunities to hit the ball (measured by at bat, <code>ab</code>), you see two patterns:</p>
<ol style="list-style-type: decimal">
<li><p>As above, the variation in our aggregate decreases as we get more
data points.</p></li>
<li><p>There’s a positive correlation between skill (<code>ba</code>) and opportunities to
hit the ball (<code>ab</code>). This is because teams control who gets to play,
and obviously they’ll pick their best players.</p></li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Convert to a tibble so it prints nicely</span>
batting &lt;-<span class="st"> </span><span class="kw">as_tibble</span>(Lahman<span class="op">::</span>Batting)

batters &lt;-<span class="st"> </span>batting <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(playerID) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">ba =</span> <span class="kw">sum</span>(H, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(AB, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">ab =</span> <span class="kw">sum</span>(AB, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  )

batters <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(ab <span class="op">&gt;</span><span class="st"> </span><span class="dv">100</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> ab, <span class="dt">y =</span> ba)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</span></code></pre>
<p><img src="transform_files/figure-html/unnamed-chunk-44-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This also has important implications for ranking. If you naively sort on <code>desc(ba)</code>, the people with the best batting averages are clearly lucky, not skilled:</p>
<pre class="sourceCode r"><code class="sourceCode r">batters <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(ba))
<span class="co">#&gt; # A tibble: 18,915 x 3</span>
<span class="co">#&gt;   playerID     ba    ab</span>
<span class="co">#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 abramge01     1     1</span>
<span class="co">#&gt; 2 banisje01     1     1</span>
<span class="co">#&gt; 3 bartocl01     1     1</span>
<span class="co">#&gt; 4 bassdo01      1     1</span>
<span class="co">#&gt; 5 berrijo01     1     1</span>
<span class="co">#&gt; 6 birasst01     1     2</span>
<span class="co">#&gt; # … with 1.891e+04 more rows</span></code></pre>
<p>You can find a good explanation of this problem at <a href="http://varianceexplained.org/r/empirical_bayes_baseball/" class="uri">http://varianceexplained.org/r/empirical_bayes_baseball/</a> and <a href="http://www.evanmiller.org/how-not-to-sort-by-average-rating.html" class="uri">http://www.evanmiller.org/how-not-to-sort-by-average-rating.html</a>.</p>
</div>
<div id="summarise-funs" class="section level3">
<h3><span class="header-section-number">5.6.4</span> Useful summary functions</h3>
<p>Just using means, counts, and sum can get you a long way, but R provides many other useful summary functions:</p>
<ul>
<li><p>Measures of location: we’ve used <code>mean(x)</code>, but <code>median(x)</code> is also
useful. The mean is the sum divided by the length; the median is a value
where 50% of <code>x</code> is above it, and 50% is below it.</p>
<p>It’s sometimes useful to combine aggregation with logical subsetting.
We haven’t talked about this sort of subsetting yet, but you’ll learn more
about it in <a href="#subsetting-1">subsetting</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">avg_delay1 =</span> <span class="kw">mean</span>(arr_delay),
    <span class="dt">avg_delay2 =</span> <span class="kw">mean</span>(arr_delay[arr_delay <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>]) <span class="co"># the average positive delay</span>
  )
<span class="co">#&gt; # A tibble: 365 x 5</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day avg_delay1 avg_delay2</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1      12.7        32.5</span>
<span class="co">#&gt; 2  2013     1     2      12.7        32.0</span>
<span class="co">#&gt; 3  2013     1     3       5.73       27.7</span>
<span class="co">#&gt; 4  2013     1     4      -1.93       28.3</span>
<span class="co">#&gt; 5  2013     1     5      -1.53       22.6</span>
<span class="co">#&gt; 6  2013     1     6       4.24       24.4</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre></li>
<li><p>Measures of spread: <code>sd(x)</code>, <code>IQR(x)</code>, <code>mad(x)</code>. The root mean squared deviation,
or standard deviation <code>sd(x)</code>, is the standard measure of spread.
The interquartile range <code>IQR(x)</code> and median absolute deviation <code>mad(x)</code>
are robust equivalents that may be more useful if you have outliers.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Why is distance to some destinations more variable than to others?</span>
not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">distance_sd =</span> <span class="kw">sd</span>(distance)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(distance_sd))
<span class="co">#&gt; # A tibble: 104 x 2</span>
<span class="co">#&gt;   dest  distance_sd</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;dbl&gt;</span>
<span class="co">#&gt; 1 EGE         10.5 </span>
<span class="co">#&gt; 2 SAN         10.4 </span>
<span class="co">#&gt; 3 SFO         10.2 </span>
<span class="co">#&gt; 4 HNL         10.0 </span>
<span class="co">#&gt; 5 SEA          9.98</span>
<span class="co">#&gt; 6 LAS          9.91</span>
<span class="co">#&gt; # … with 98 more rows</span></code></pre></li>
<li><p>Measures of rank: <code>min(x)</code>, <code>quantile(x, 0.25)</code>, <code>max(x)</code>. Quantiles
are a generalisation of the median. For example, <code>quantile(x, 0.25)</code>
will find a value of <code>x</code> that is greater than 25% of the values,
and less than the remaining 75%.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># When do the first and last flights leave each day?</span>
not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">first =</span> <span class="kw">min</span>(dep_time),
    <span class="dt">last =</span> <span class="kw">max</span>(dep_time)
  )
<span class="co">#&gt; # A tibble: 365 x 5</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day first  last</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1   517  2356</span>
<span class="co">#&gt; 2  2013     1     2    42  2354</span>
<span class="co">#&gt; 3  2013     1     3    32  2349</span>
<span class="co">#&gt; 4  2013     1     4    25  2358</span>
<span class="co">#&gt; 5  2013     1     5    14  2357</span>
<span class="co">#&gt; 6  2013     1     6    16  2355</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre></li>
<li><p>Measures of position: <code>first(x)</code>, <code>nth(x, 2)</code>, <code>last(x)</code>. These work
similarly to <code>x[1]</code>, <code>x[2]</code>, and <code>x[length(x)]</code> but let you set a default
value if that position does not exist (i.e. you’re trying to get the 3rd
element from a group that only has two elements). For example, we can
find the first and last departure for each day:</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">first_dep =</span> <span class="kw">first</span>(dep_time), 
    <span class="dt">last_dep =</span> <span class="kw">last</span>(dep_time)
  )
<span class="co">#&gt; # A tibble: 365 x 5</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day first_dep last_dep</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1       517     2356</span>
<span class="co">#&gt; 2  2013     1     2        42     2354</span>
<span class="co">#&gt; 3  2013     1     3        32     2349</span>
<span class="co">#&gt; 4  2013     1     4        25     2358</span>
<span class="co">#&gt; 5  2013     1     5        14     2357</span>
<span class="co">#&gt; 6  2013     1     6        16     2355</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre>
<p>These functions are complementary to filtering on ranks. Filtering gives
you all variables, with each observation in a separate row:</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">r =</span> <span class="kw">min_rank</span>(<span class="kw">desc</span>(dep_time))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(r <span class="op">%in%</span><span class="st"> </span><span class="kw">range</span>(r))
<span class="co">#&gt; # A tibble: 770 x 20</span>
<span class="co">#&gt; # Groups:   year, month, day [365]</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1     2356           2359        -3      425</span>
<span class="co">#&gt; 3  2013     1     2       42           2359        43      518</span>
<span class="co">#&gt; 4  2013     1     2     2354           2359        -5      413</span>
<span class="co">#&gt; 5  2013     1     3       32           2359        33      504</span>
<span class="co">#&gt; 6  2013     1     3     2349           2359       -10      434</span>
<span class="co">#&gt; # … with 764 more rows, and 13 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, r &lt;int&gt;</span></code></pre></li>
<li><p>Counts: You’ve seen <code>n()</code>, which takes no arguments, and returns the
size of the current group. To count the number of non-missing values, use
<code>sum(!is.na(x))</code>. To count the number of distinct (unique) values, use
<code>n_distinct(x)</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Which destinations have the most carriers?</span>
not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">carriers =</span> <span class="kw">n_distinct</span>(carrier)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(carriers))
<span class="co">#&gt; # A tibble: 104 x 2</span>
<span class="co">#&gt;   dest  carriers</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1 ATL          7</span>
<span class="co">#&gt; 2 BOS          7</span>
<span class="co">#&gt; 3 CLT          7</span>
<span class="co">#&gt; 4 ORD          7</span>
<span class="co">#&gt; 5 TPA          7</span>
<span class="co">#&gt; 6 AUS          6</span>
<span class="co">#&gt; # … with 98 more rows</span></code></pre>
<p>Counts are so useful that dplyr provides a simple helper if all you want is
a count:</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(dest)
<span class="co">#&gt; # A tibble: 104 x 2</span>
<span class="co">#&gt;   dest      n</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 ABQ     254</span>
<span class="co">#&gt; 2 ACK     264</span>
<span class="co">#&gt; 3 ALB     418</span>
<span class="co">#&gt; 4 ANC       8</span>
<span class="co">#&gt; 5 ATL   16837</span>
<span class="co">#&gt; 6 AUS    2411</span>
<span class="co">#&gt; # … with 98 more rows</span></code></pre>
<p>You can optionally provide a weight variable. For example, you could use
this to “count” (sum) the total number of miles a plane flew:</p>
<pre class="sourceCode r"><code class="sourceCode r">not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(tailnum, <span class="dt">wt =</span> distance)
<span class="co">#&gt; # A tibble: 4,037 x 2</span>
<span class="co">#&gt;   tailnum      n</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;dbl&gt;</span>
<span class="co">#&gt; 1 D942DN    3418</span>
<span class="co">#&gt; 2 N0EGMQ  239143</span>
<span class="co">#&gt; 3 N10156  109664</span>
<span class="co">#&gt; 4 N102UW   25722</span>
<span class="co">#&gt; 5 N103US   24619</span>
<span class="co">#&gt; 6 N104UW   24616</span>
<span class="co">#&gt; # … with 4,031 more rows</span></code></pre></li>
<li><p>Counts and proportions of logical values: <code>sum(x &gt; 10)</code>, <code>mean(y == 0)</code>.
When used with numeric functions, <code>TRUE</code> is converted to 1 and <code>FALSE</code> to 0.
This makes <code>sum()</code> and <code>mean()</code> very useful: <code>sum(x)</code> gives the number of
<code>TRUE</code>s in <code>x</code>, and <code>mean(x)</code> gives the proportion.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># How many flights left before 5am? (these usually indicate delayed</span>
<span class="co"># flights from the previous day)</span>
not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n_early =</span> <span class="kw">sum</span>(dep_time <span class="op">&lt;</span><span class="st"> </span><span class="dv">500</span>))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day n_early</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1       0</span>
<span class="co">#&gt; 2  2013     1     2       3</span>
<span class="co">#&gt; 3  2013     1     3       4</span>
<span class="co">#&gt; 4  2013     1     4       3</span>
<span class="co">#&gt; 5  2013     1     5       3</span>
<span class="co">#&gt; 6  2013     1     6       2</span>
<span class="co">#&gt; # … with 359 more rows</span>

<span class="co"># What proportion of flights are delayed by more than an hour?</span>
not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">hour_perc =</span> <span class="kw">mean</span>(arr_delay <span class="op">&gt;</span><span class="st"> </span><span class="dv">60</span>))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day hour_perc</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1    0.0722</span>
<span class="co">#&gt; 2  2013     1     2    0.0851</span>
<span class="co">#&gt; 3  2013     1     3    0.0567</span>
<span class="co">#&gt; 4  2013     1     4    0.0396</span>
<span class="co">#&gt; 5  2013     1     5    0.0349</span>
<span class="co">#&gt; 6  2013     1     6    0.0470</span>
<span class="co">#&gt; # … with 359 more rows</span></code></pre></li>
</ul>
</div>
<div id="grouping-by-multiple-variables" class="section level3">
<h3><span class="header-section-number">5.6.5</span> Grouping by multiple variables</h3>
<p>When you group by multiple variables, each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily &lt;-<span class="st"> </span><span class="kw">group_by</span>(flights, year, month, day)
(per_day   &lt;-<span class="st"> </span><span class="kw">summarise</span>(daily, <span class="dt">flights =</span> <span class="kw">n</span>()))
<span class="co">#&gt; # A tibble: 365 x 4</span>
<span class="co">#&gt; # Groups:   year, month [?]</span>
<span class="co">#&gt;    year month   day flights</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1     842</span>
<span class="co">#&gt; 2  2013     1     2     943</span>
<span class="co">#&gt; 3  2013     1     3     914</span>
<span class="co">#&gt; 4  2013     1     4     915</span>
<span class="co">#&gt; 5  2013     1     5     720</span>
<span class="co">#&gt; 6  2013     1     6     832</span>
<span class="co">#&gt; # … with 359 more rows</span>
(per_month &lt;-<span class="st"> </span><span class="kw">summarise</span>(per_day, <span class="dt">flights =</span> <span class="kw">sum</span>(flights)))
<span class="co">#&gt; # A tibble: 12 x 3</span>
<span class="co">#&gt; # Groups:   year [?]</span>
<span class="co">#&gt;    year month flights</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1   27004</span>
<span class="co">#&gt; 2  2013     2   24951</span>
<span class="co">#&gt; 3  2013     3   28834</span>
<span class="co">#&gt; 4  2013     4   28330</span>
<span class="co">#&gt; 5  2013     5   28796</span>
<span class="co">#&gt; 6  2013     6   28243</span>
<span class="co">#&gt; # … with 6 more rows</span>
(per_year  &lt;-<span class="st"> </span><span class="kw">summarise</span>(per_month, <span class="dt">flights =</span> <span class="kw">sum</span>(flights)))
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;    year flights</span>
<span class="co">#&gt;   &lt;int&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1  2013  336776</span></code></pre>
<p>Be careful when progressively rolling up summaries: it’s OK for sums and counts, but you need to think about weighting means and variances, and it’s not possible to do it exactly for rank-based statistics like the median. In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median.</p>
</div>
<div id="ungrouping" class="section level3">
<h3><span class="header-section-number">5.6.6</span> Ungrouping</h3>
<p>If you need to remove grouping, and return to operations on ungrouped data, use <code>ungroup()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ungroup</span>() <span class="op">%&gt;%</span><span class="st">             </span><span class="co"># no longer grouped by date</span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">flights =</span> <span class="kw">n</span>())  <span class="co"># all flights</span>
<span class="co">#&gt; # A tibble: 1 x 1</span>
<span class="co">#&gt;   flights</span>
<span class="co">#&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1  336776</span></code></pre>
</div>
<div id="exercises-11" class="section level3">
<h3><span class="header-section-number">5.6.7</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Brainstorm at least 5 different ways to assess the typical delay
characteristics of a group of flights. Consider the following scenarios:</p>
<ul>
<li><p>A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of
the time.</p></li>
<li><p>A flight is always 10 minutes late.</p></li>
<li><p>A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of
the time.</p></li>
<li><p>99% of the time a flight is on time. 1% of the time it’s 2 hours late.</p></li>
</ul>
<p>Which is more important: arrival delay or departure delay?</p></li>
<li><p>Come up with another approach that will give you the same output as
<code>not_cancelled %&gt;% count(dest)</code> and
<code>not_cancelled %&gt;% count(tailnum, wt = distance)</code> (without using
<code>count()</code>).</p></li>
<li><p>Our definition of cancelled flights (<code>is.na(dep_delay) | is.na(arr_delay)</code>
) is slightly suboptimal. Why? Which is the most important column?</p></li>
<li><p>Look at the number of cancelled flights per day. Is there a pattern?
Is the proportion of cancelled flights related to the average delay?</p></li>
<li><p>Which carrier has the worst delays? Challenge: can you disentangle the
effects of bad airports vs. bad carriers? Why/why not? (Hint: think about
<code>flights %&gt;% group_by(carrier, dest) %&gt;% summarise(n())</code>)</p></li>
<li><p>What does the <code>sort</code> argument to <code>count()</code> do. When might you use it?</p></li>
</ol>
</div>
</div>
<div id="grouped-mutates-and-filters" class="section level2">
<h2><span class="header-section-number">5.7</span> Grouped mutates (and filters)</h2>
<p>Grouping is most useful in conjunction with <code>summarise()</code>, but you can also do convenient operations with <code>mutate()</code> and <code>filter()</code>:</p>
<ul>
<li><p>Find the worst members of each group:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_sml <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">rank</span>(<span class="kw">desc</span>(arr_delay)) <span class="op">&lt;</span><span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; # A tibble: 3,306 x 7</span>
<span class="co">#&gt; # Groups:   year, month, day [365]</span>
<span class="co">#&gt;    year month   day dep_delay arr_delay distance air_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1       853       851      184       41</span>
<span class="co">#&gt; 2  2013     1     1       290       338     1134      213</span>
<span class="co">#&gt; 3  2013     1     1       260       263      266       46</span>
<span class="co">#&gt; 4  2013     1     1       157       174      213       60</span>
<span class="co">#&gt; 5  2013     1     1       216       222      708      121</span>
<span class="co">#&gt; 6  2013     1     1       255       250      589      115</span>
<span class="co">#&gt; # … with 3,300 more rows</span></code></pre></li>
<li><p>Find all groups bigger than a threshold:</p>
<pre class="sourceCode r"><code class="sourceCode r">popular_dests &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">n</span>() <span class="op">&gt;</span><span class="st"> </span><span class="dv">365</span>)
popular_dests
<span class="co">#&gt; # A tibble: 332,577 x 19</span>
<span class="co">#&gt; # Groups:   dest [77]</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      517            515         2      830</span>
<span class="co">#&gt; 2  2013     1     1      533            529         4      850</span>
<span class="co">#&gt; 3  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 4  2013     1     1      544            545        -1     1004</span>
<span class="co">#&gt; 5  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 6  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; # … with 3.326e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre></li>
<li><p>Standardise to compute per group metrics:</p>
<pre class="sourceCode r"><code class="sourceCode r">popular_dests <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(arr_delay <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">prop_delay =</span> arr_delay <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(arr_delay)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(year<span class="op">:</span>day, dest, arr_delay, prop_delay)
<span class="co">#&gt; # A tibble: 131,106 x 6</span>
<span class="co">#&gt; # Groups:   dest [77]</span>
<span class="co">#&gt;    year month   day dest  arr_delay prop_delay</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1 IAH          11  0.000111 </span>
<span class="co">#&gt; 2  2013     1     1 IAH          20  0.000201 </span>
<span class="co">#&gt; 3  2013     1     1 MIA          33  0.000235 </span>
<span class="co">#&gt; 4  2013     1     1 ORD          12  0.0000424</span>
<span class="co">#&gt; 5  2013     1     1 FLL          19  0.0000938</span>
<span class="co">#&gt; 6  2013     1     1 ORD           8  0.0000283</span>
<span class="co">#&gt; # … with 1.311e+05 more rows</span></code></pre></li>
</ul>
<p>A grouped filter is a grouped mutate followed by an ungrouped filter. I generally avoid them except for quick and dirty manipulations: otherwise it’s hard to check that you’ve done the manipulation correctly.</p>
<p>Functions that work most naturally in grouped mutates and filters are known as window functions (vs. the summary functions used for summaries). You can learn more about useful window functions in the corresponding vignette: <code>vignette(&quot;window-functions&quot;)</code>.</p>
<div id="exercises-12" class="section level3">
<h3><span class="header-section-number">5.7.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Refer back to the lists of useful mutate and filtering functions.
Describe how each operation changes when you combine it with grouping.</p></li>
<li><p>Which plane (<code>tailnum</code>) has the worst on-time record?</p></li>
<li><p>What time of day should you fly if you want to avoid delays as much
as possible?</p></li>
<li><p>For each destination, compute the total minutes of delay. For each
flight, compute the proportion of the total delay for its destination.</p></li>
<li><p>Delays are typically temporally correlated: even once the problem that
caused the initial delay has been resolved, later flights are delayed
to allow earlier flights to leave. Using <code>lag()</code>, explore how the delay
of a flight is related to the delay of the immediately preceding flight.</p></li>
<li><p>Look at each destination. Can you find flights that are suspiciously
fast? (i.e. flights that represent a potential data entry error). Compute
the air time a flight relative to the shortest flight to that destination.
Which flights were most delayed in the air?</p></li>
<li><p>Find all destinations that are flown by at least two carriers. Use that
information to rank the carriers.</p></li>
<li><p>For each plane, count the number of flights before the first delay
of greater than 1 hour.</p></li>
</ol>
<!--chapter:end:transform.Rmd-->
</div>
</div>
</div>
<div id="workflow-scripts" class="section level1">
<h1><span class="header-section-number">6</span> Workflow: scripts</h1>
<p>So far you’ve been using the console to run code. That’s a great place to start, but you’ll find it gets cramped pretty quickly as you create more complex ggplot2 graphics and dplyr pipes. To give yourself more room to work, it’s a great idea to use the script editor. Open it up either by clicking the File menu, and selecting New File, then R script, or using the keyboard shortcut Cmd/Ctrl + Shift + N. Now you’ll see four panes:</p>
<p><img src="diagrams/rstudio-editor.png" width="75%" style="display: block; margin: auto;" /></p>
<p>The script editor is a great place to put code you care about. Keep experimenting in the console, but once you have written code that works and does what you want, put it in the script editor. RStudio will automatically save the contents of the editor when you quit RStudio, and will automatically load it when you re-open. Nevertheless, it’s a good idea to save your scripts regularly and to back them up.</p>
<div id="running-code" class="section level2">
<h2><span class="header-section-number">6.1</span> Running code</h2>
<p>The script editor is also a great place to build up complex ggplot2 plots or long sequences of dplyr manipulations. The key to using the script editor effectively is to memorise one of the most important keyboard shortcuts: Cmd/Ctrl + Enter. This executes the current R expression in the console. For example, take the code below. If your cursor is at █, pressing Cmd/Ctrl + Enter will run the complete command that generates <code>not_cancelled</code>. It will also move the cursor to the next statement (beginning with <code>not_cancelled %&gt;%</code>). That makes it easy to run your complete script by repeatedly pressing Cmd/Ctrl + Enter.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)
<span class="kw">library</span>(nycflights13)

not_cancelled &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(dep_delay)█, <span class="op">!</span><span class="kw">is.na</span>(arr_delay))

not_cancelled <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(year, month, day) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean =</span> <span class="kw">mean</span>(dep_delay))</code></pre>
<p>Instead of running expression-by-expression, you can also execute the complete script in one step: Cmd/Ctrl + Shift + S. Doing this regularly is a great way to check that you’ve captured all the important parts of your code in the script.</p>
<p>I recommend that you always start your script with the packages that you need. That way, if you share your code with others, they can easily see what packages they need to install. Note, however, that you should never include <code>install.packages()</code> or <code>setwd()</code> in a script that you share. It’s very antisocial to change settings on someone else’s computer!</p>
<p>When working through future chapters, I highly recommend starting in the editor and practicing your keyboard shortcuts. Over time, sending code to the console in this way will become so natural that you won’t even think about it.</p>
</div>
<div id="rstudio-diagnostics" class="section level2">
<h2><span class="header-section-number">6.2</span> RStudio diagnostics</h2>
<p>The script editor will also highlight syntax errors with a red squiggly line and a cross in the sidebar:</p>
<p><img src="screenshots/rstudio-diagnostic.png" width="129" style="display: block; margin: auto;" /></p>
<p>Hover over the cross to see what the problem is:</p>
<p><img src="screenshots/rstudio-diagnostic-tip.png" width="202" style="display: block; margin: auto;" /></p>
<p>RStudio will also let you know about potential problems:</p>
<p><img src="screenshots/rstudio-diagnostic-warn.png" width="439" style="display: block; margin: auto;" /></p>
</div>
<div id="practice-1" class="section level2">
<h2><span class="header-section-number">6.3</span> Practice</h2>
<ol style="list-style-type: decimal">
<li><p>Go to the RStudio Tips twitter account, <a href="https://twitter.com/rstudiotips" class="uri">https://twitter.com/rstudiotips</a>
and find one tip that looks interesting. Practice using it!</p></li>
<li><p>What other common mistakes will RStudio diagnostics report? Read
<a href="https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics" class="uri">https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics</a> to
find out.</p></li>
</ol>
<!--chapter:end:workflow-scripts.Rmd-->
</div>
</div>
<div id="exploratory-data-analysis" class="section level1">
<h1><span class="header-section-number">7</span> Exploratory Data Analysis</h1>
<div id="introduction-3" class="section level2">
<h2><span class="header-section-number">7.1</span> Introduction</h2>
<p>This chapter will show you how to use visualisation and transformation to explore your data in a systematic way, a task that statisticians call exploratory data analysis, or EDA for short. EDA is an iterative cycle. You:</p>
<ol style="list-style-type: decimal">
<li><p>Generate questions about your data.</p></li>
<li><p>Search for answers by visualising, transforming, and modelling your data.</p></li>
<li><p>Use what you learn to refine your questions and/or generate new questions.</p></li>
</ol>
<p>EDA is not a formal process with a strict set of rules. More than anything, EDA is a state of mind. During the initial phases of EDA you should feel free to investigate every idea that occurs to you. Some of these ideas will pan out, and some will be dead ends. As your exploration continues, you will home in on a few particularly productive areas that you’ll eventually write up and communicate to others.</p>
<p>EDA is an important part of any data analysis, even if the questions are handed to you on a platter, because you always need to investigate the quality of your data. Data cleaning is just one application of EDA: you ask questions about whether your data meets your expectations or not. To do data cleaning, you’ll need to deploy all the tools of EDA: visualisation, transformation, and modelling.</p>
<div id="prerequisites-3" class="section level3">
<h3><span class="header-section-number">7.1.1</span> Prerequisites</h3>
<p>In this chapter we’ll combine what you’ve learned about dplyr and ggplot2 to interactively ask questions, answer them with data, and then ask new questions.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="questions" class="section level2">
<h2><span class="header-section-number">7.2</span> Questions</h2>
<blockquote>
<p>“There are no routine statistical questions, only questionable statistical
routines.” — Sir David Cox</p>
</blockquote>
<blockquote>
<p>“Far better an approximate answer to the right question, which is often
vague, than an exact answer to the wrong question, which can always be made
precise.” — John Tukey</p>
</blockquote>
<p>Your goal during EDA is to develop an understanding of your data. The easiest way to do this is to use questions as tools to guide your investigation. When you ask a question, the question focuses your attention on a specific part of your dataset and helps you decide which graphs, models, or transformations to make.</p>
<p>EDA is fundamentally a creative process. And like most creative processes, the key to asking <em>quality</em> questions is to generate a large <em>quantity</em> of questions. It is difficult to ask revealing questions at the start of your analysis because you do not know what insights are contained in your dataset. On the other hand, each new question that you ask will expose you to a new aspect of your data and increase your chance of making a discovery. You can quickly drill down into the most interesting parts of your data—and develop a set of thought-provoking questions—if you follow up each question with a new question based on what you find.</p>
<p>There is no rule about which questions you should ask to guide your research. However, two types of questions will always be useful for making discoveries within your data. You can loosely word these questions as:</p>
<ol style="list-style-type: decimal">
<li><p>What type of variation occurs within my variables?</p></li>
<li><p>What type of covariation occurs between my variables?</p></li>
</ol>
<p>The rest of this chapter will look at these two questions. I’ll explain what variation and covariation are, and I’ll show you several ways to answer each question. To make the discussion easier, let’s define some terms:</p>
<ul>
<li><p>A <strong>variable</strong> is a quantity, quality, or property that you can measure.</p></li>
<li><p>A <strong>value</strong> is the state of a variable when you measure it. The value of a
variable may change from measurement to measurement.</p></li>
<li><p>An <strong>observation</strong> is a set of measurements made under similar conditions
(you usually make all of the measurements in an observation at the same
time and on the same object). An observation will contain several values,
each associated with a different variable. I’ll sometimes refer to
an observation as a data point.</p></li>
<li><p><strong>Tabular data</strong> is a set of values, each associated with a variable and an
observation. Tabular data is <em>tidy</em> if each value is placed in its own
“cell”, each variable in its own column, and each observation in its own
row.</p></li>
</ul>
<p>So far, all of the data that you’ve seen has been tidy. In real-life, most data isn’t tidy, so we’ll come back to these ideas again in <a href="#tidy-data-1">tidy data</a>.</p>
</div>
<div id="variation" class="section level2">
<h2><span class="header-section-number">7.3</span> Variation</h2>
<p><strong>Variation</strong> is the tendency of the values of a variable to change from measurement to measurement. You can see variation easily in real life; if you measure any continuous variable twice, you will get two different results. This is true even if you measure quantities that are constant, like the speed of light. Each of your measurements will include a small amount of error that varies from measurement to measurement. Categorical variables can also vary if you measure across different subjects (e.g. the eye colors of different people), or different times (e.g. the energy levels of an electron at different moments).
Every variable has its own pattern of variation, which can reveal interesting information. The best way to understand that pattern is to visualise the distribution of the variable’s values.</p>
<div id="visualising-distributions" class="section level3">
<h3><span class="header-section-number">7.3.1</span> Visualising distributions</h3>
<p>How you visualise the distribution of a variable will depend on whether the variable is categorical or continuous. A variable is <strong>categorical</strong> if it can only take one of a small set of values. In R, categorical variables are usually saved as factors or character vectors. To examine the distribution of a categorical variable, use a bar chart:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The height of the bars displays how many observations occurred with each x value. You can compute these values manually with <code>dplyr::count()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(cut)
<span class="co">#&gt; # A tibble: 5 x 2</span>
<span class="co">#&gt;   cut           n</span>
<span class="co">#&gt;   &lt;ord&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1 Fair       1610</span>
<span class="co">#&gt; 2 Good       4906</span>
<span class="co">#&gt; 3 Very Good 12082</span>
<span class="co">#&gt; 4 Premium   13791</span>
<span class="co">#&gt; 5 Ideal     21551</span></code></pre>
<p>A variable is <strong>continuous</strong> if it can take any of an infinite set of ordered values. Numbers and date-times are two examples of continuous variables. To examine the distribution of a continuous variable, use a histogram:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat), <span class="dt">binwidth =</span> <span class="fl">0.5</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can compute this by hand by combining <code>dplyr::count()</code> and <code>ggplot2::cut_width()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(<span class="kw">cut_width</span>(carat, <span class="fl">0.5</span>))
<span class="co">#&gt; # A tibble: 11 x 2</span>
<span class="co">#&gt;   `cut_width(carat, 0.5)`     n</span>
<span class="co">#&gt;   &lt;fct&gt;                   &lt;int&gt;</span>
<span class="co">#&gt; 1 [-0.25,0.25]              785</span>
<span class="co">#&gt; 2 (0.25,0.75]             29498</span>
<span class="co">#&gt; 3 (0.75,1.25]             15977</span>
<span class="co">#&gt; 4 (1.25,1.75]              5313</span>
<span class="co">#&gt; 5 (1.75,2.25]              2002</span>
<span class="co">#&gt; 6 (2.25,2.75]               322</span>
<span class="co">#&gt; # … with 5 more rows</span></code></pre>
<p>A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. In the graph above, the tallest bar shows that almost 30,000 observations have a <code>carat</code> value between 0.25 and 0.75, which are the left and right edges of the bar.</p>
<p>You can set the width of the intervals in a histogram with the <code>binwidth</code> argument, which is measured in the units of the <code>x</code> variable. You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns. For example, here is how the graph above looks when we zoom into just the diamonds with a size of less than three carats and choose a smaller binwidth.</p>
<pre class="sourceCode r"><code class="sourceCode r">smaller &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(carat <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span>)
  
<span class="kw">ggplot</span>(<span class="dt">data =</span> smaller, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="fl">0.1</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you wish to overlay multiple histograms in the same plot, I recommend using <code>geom_freqpoly()</code> instead of <code>geom_histogram()</code>. <code>geom_freqpoly()</code> performs the same calculation as <code>geom_histogram()</code>, but instead of displaying the counts with bars, uses lines instead. It’s much easier to understand overlapping lines than bars.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> smaller, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">colour =</span> cut)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="fl">0.1</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are a few challenges with this type of plot, which we will come back to in <a href="#cat-cont">visualising a categorical and a continuous variable</a>.</p>
<p>Now that you can visualise variation, what should you look for in your plots? And what type of follow-up questions should you ask? I’ve put together a list below of the most useful types of information that you will find in your graphs, along with some follow-up questions for each type of information. The key to asking good follow-up questions will be to rely on your curiosity (What do you want to learn more about?) as well as your skepticism (How could this be misleading?).</p>
</div>
<div id="typical-values" class="section level3">
<h3><span class="header-section-number">7.3.2</span> Typical values</h3>
<p>In both bar charts and histograms, tall bars show the common values of a variable, and shorter bars show less-common values. Places that do not have bars reveal values that were not seen in your data. To turn this information into useful questions, look for anything unexpected:</p>
<ul>
<li><p>Which values are the most common? Why?</p></li>
<li><p>Which values are rare? Why? Does that match your expectations?</p></li>
<li><p>Can you see any unusual patterns? What might explain them?</p></li>
</ul>
<p>As an example, the histogram below suggests several interesting questions:</p>
<ul>
<li><p>Why are there more diamonds at whole carats and common fractions of carats?</p></li>
<li><p>Why are there more diamonds slightly to the right of each peak than there
are slightly to the left of each peak?</p></li>
<li><p>Why are there no diamonds bigger than 3 carats?</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> smaller, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="fl">0.01</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Clusters of similar values suggest that subgroups exist in your data. To understand the subgroups, ask:</p>
<ul>
<li><p>How are the observations within each cluster similar to each other?</p></li>
<li><p>How are the observations in separate clusters different from each other?</p></li>
<li><p>How can you explain or describe the clusters?</p></li>
<li><p>Why might the appearance of clusters be misleading?</p></li>
</ul>
<p>The histogram below shows the length (in minutes) of 272 eruptions of the Old Faithful Geyser in Yellowstone National Park. Eruption times appear to be clustered into two groups: there are short eruptions (of around 2 minutes) and long eruptions (4-5 minutes), but little in between.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> faithful, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> eruptions)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">binwidth =</span> <span class="fl">0.25</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Many of the questions above will prompt you to explore a relationship <em>between</em> variables, for example, to see if the values of one variable can explain the behavior of another variable. We’ll get to that shortly.</p>
</div>
<div id="unusual-values" class="section level3">
<h3><span class="header-section-number">7.3.3</span> Unusual values</h3>
<p>Outliers are observations that are unusual; data points that don’t seem to fit the pattern. Sometimes outliers are data entry errors; other times outliers suggest important new science. When you have a lot of data, outliers are sometimes difficult to see in a histogram. For example, take the distribution of the <code>y</code> variable from the diamonds dataset. The only evidence of outliers is the unusually wide limits on the x-axis.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> y), <span class="dt">binwidth =</span> <span class="fl">0.5</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are so many observations in the common bins that the rare bins are so short that you can’t see them (although maybe if you stare intently at 0 you’ll spot something). To make it easy to see the unusual values, we need to zoom to small values of the y-axis with <code>coord_cartesian()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> y), <span class="dt">binwidth =</span> <span class="fl">0.5</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_cartesian</span>(<span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">50</span>))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(<code>coord_cartesian()</code> also has an <code>xlim()</code> argument for when you need to zoom into the x-axis. ggplot2 also has <code>xlim()</code> and <code>ylim()</code> functions that work slightly differently: they throw away the data outside the limits.)</p>
<p>This allows us to see that there are three unusual values: 0, ~30, and ~60. We pluck them out with dplyr:</p>
<pre class="sourceCode r"><code class="sourceCode r">unusual &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(y <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span> <span class="op">|</span><span class="st"> </span>y <span class="op">&gt;</span><span class="st"> </span><span class="dv">20</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(price, x, y, z) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(y)
unusual
<span class="co">#&gt; # A tibble: 9 x 4</span>
<span class="co">#&gt;   price     x     y     z</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  5139  0      0    0   </span>
<span class="co">#&gt; 2  6381  0      0    0   </span>
<span class="co">#&gt; 3 12800  0      0    0   </span>
<span class="co">#&gt; 4 15686  0      0    0   </span>
<span class="co">#&gt; 5 18034  0      0    0   </span>
<span class="co">#&gt; 6  2130  0      0    0   </span>
<span class="co">#&gt; 7  2130  0      0    0   </span>
<span class="co">#&gt; 8  2075  5.15  31.8  5.12</span>
<span class="co">#&gt; 9 12210  8.09  58.9  8.06</span></code></pre>
<p>The <code>y</code> variable measures one of the three dimensions of these diamonds, in mm. We know that diamonds can’t have a width of 0mm, so these values must be incorrect. We might also suspect that measurements of 32mm and 59mm are implausible: those diamonds are over an inch long, but don’t cost hundreds of thousands of dollars!</p>
<p>It’s good practice to repeat your analysis with and without the outliers. If they have minimal effect on the results, and you can’t figure out why they’re there, it’s reasonable to replace them with missing values, and move on. However, if they have a substantial effect on your results, you shouldn’t drop them without justification. You’ll need to figure out what caused them (e.g. a data entry error) and disclose that you removed them in your write-up.</p>
</div>
<div id="exercises-13" class="section level3">
<h3><span class="header-section-number">7.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Explore the distribution of each of the <code>x</code>, <code>y</code>, and <code>z</code> variables
in <code>diamonds</code>. What do you learn? Think about a diamond and how you
might decide which dimension is the length, width, and depth.</p></li>
<li><p>Explore the distribution of <code>price</code>. Do you discover anything unusual
or surprising? (Hint: Carefully think about the <code>binwidth</code> and make sure
you try a wide range of values.)</p></li>
<li><p>How many diamonds are 0.99 carat? How many are 1 carat? What
do you think is the cause of the difference?</p></li>
<li><p>Compare and contrast <code>coord_cartesian()</code> vs <code>xlim()</code> or <code>ylim()</code> when
zooming in on a histogram. What happens if you leave <code>binwidth</code> unset?
What happens if you try and zoom so only half a bar shows?</p></li>
</ol>
</div>
</div>
<div id="missing-values-2" class="section level2">
<h2><span class="header-section-number">7.4</span> Missing values</h2>
<p>If you’ve encountered unusual values in your dataset, and simply want to move on to the rest of your analysis, you have two options.</p>
<ol style="list-style-type: decimal">
<li><p>Drop the entire row with the strange values:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">between</span>(y, <span class="dv">3</span>, <span class="dv">20</span>))</code></pre>
<p>I don’t recommend this option because just because one measurement
is invalid, doesn’t mean all the measurements are. Additionally, if you
have low quality data, by time that you’ve applied this approach to every
variable you might find that you don’t have any data left!</p></li>
<li><p>Instead, I recommend replacing the unusual values with missing values.
The easiest way to do this is to use <code>mutate()</code> to replace the variable
with a modified copy. You can use the <code>ifelse()</code> function to replace
unusual values with <code>NA</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">y =</span> <span class="kw">ifelse</span>(y <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span> <span class="op">|</span><span class="st"> </span>y <span class="op">&gt;</span><span class="st"> </span><span class="dv">20</span>, <span class="ot">NA</span>, y))</code></pre></li>
</ol>
<p><code>ifelse()</code> has three arguments. The first argument <code>test</code> should be a logical vector. The result will contain the value of the second argument, <code>yes</code>, when <code>test</code> is <code>TRUE</code>, and the value of the third argument, <code>no</code>, when it is false. Alternatively to ifelse, use <code>dplyr::case_when()</code>. <code>case_when()</code> is particularly useful inside mutate when you want to create a new variable that relies on a complex combination of existing variables.</p>
<p>Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing. It’s not obvious where you should plot missing values, so ggplot2 doesn’t include them in the plot, but it does warn that they’ve been removed:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds2, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>()
<span class="co">#&gt; Warning: Removed 9 rows containing missing values (geom_point).</span></code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>To suppress that warning, set <code>na.rm = TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds2, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre>
<p>Other times you want to understand what makes observations with missing values different to observations with recorded values. For example, in <code>nycflights13::flights</code>, missing values in the <code>dep_time</code> variable indicate that the flight was cancelled. So you might want to compare the scheduled departure times for cancelled and non-cancelled times. You can do this by making a new variable with <code>is.na()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">nycflights13<span class="op">::</span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">cancelled =</span> <span class="kw">is.na</span>(dep_time),
    <span class="dt">sched_hour =</span> sched_dep_time <span class="op">%/%</span><span class="st"> </span><span class="dv">100</span>,
    <span class="dt">sched_min =</span> sched_dep_time <span class="op">%%</span><span class="st"> </span><span class="dv">100</span>,
    <span class="dt">sched_dep_time =</span> sched_hour <span class="op">+</span><span class="st"> </span>sched_min <span class="op">/</span><span class="st"> </span><span class="dv">60</span>
  ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(sched_dep_time)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_freqpoly</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">colour =</span> cancelled), <span class="dt">binwidth =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">4</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>However this plot isn’t great because there are many more non-cancelled flights than cancelled flights. In the next section we’ll explore some techniques for improving this comparison.</p>
<div id="exercises-14" class="section level3">
<h3><span class="header-section-number">7.4.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What happens to missing values in a histogram? What happens to missing
values in a bar chart? Why is there a difference?</p></li>
<li><p>What does <code>na.rm = TRUE</code> do in <code>mean()</code> and <code>sum()</code>?</p></li>
</ol>
</div>
</div>
<div id="covariation" class="section level2">
<h2><span class="header-section-number">7.5</span> Covariation</h2>
<p>If variation describes the behavior <em>within</em> a variable, covariation describes the behavior <em>between</em> variables. <strong>Covariation</strong> is the tendency for the values of two or more variables to vary together in a related way. The best way to spot covariation is to visualise the relationship between two or more variables. How you do that should again depend on the type of variables involved.</p>
<div id="cat-cont" class="section level3">
<h3><span class="header-section-number">7.5.1</span> A categorical and continuous variable</h3>
<p>It’s common to want to explore the distribution of a continuous variable broken down by a categorical variable, as in the previous frequency polygon. The default appearance of <code>geom_freqpoly()</code> is not that useful for that sort of comparison because the height is given by the count. That means if one of the groups is much smaller than the others, it’s hard to see the differences in shape. For example, let’s explore how the price of a diamond varies with its quality:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">colour =</span> cut), <span class="dt">binwidth =</span> <span class="dv">500</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It’s hard to see the difference in distribution because the overall counts differ so much:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>To make the comparison easier we need to swap what is displayed on the y-axis. Instead of displaying count, we’ll display <strong>density</strong>, which is the count standardised so that the area under each frequency polygon is one.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> price, <span class="dt">y =</span> ..density..)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">colour =</span> cut), <span class="dt">binwidth =</span> <span class="dv">500</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There’s something rather surprising about this plot - it appears that fair diamonds (the lowest quality) have the highest average price! But maybe that’s because frequency polygons are a little hard to interpret - there’s a lot going on in this plot.</p>
<p>Another alternative to display the distribution of a continuous variable broken down by a categorical variable is the boxplot. A <strong>boxplot</strong> is a type of visual shorthand for a distribution of values that is popular among statisticians. Each boxplot consists of:</p>
<ul>
<li><p>A box that stretches from the 25th percentile of the distribution to the
75th percentile, a distance known as the interquartile range (IQR). In the
middle of the box is a line that displays the median, i.e. 50th percentile,
of the distribution. These three lines give you a sense of the spread of the
distribution and whether or not the distribution is symmetric about the
median or skewed to one side.</p></li>
<li><p>Visual points that display observations that fall more than 1.5 times the
IQR from either edge of the box. These outlying points are unusual
so are plotted individually.</p></li>
<li><p>A line (or whisker) that extends from each end of the box and goes to the<br />
farthest non-outlier point in the distribution.</p></li>
</ul>
<p><img src="images/EDA-boxplot.png" width="100%" style="display: block; margin: auto;" /></p>
<p>Let’s take a look at the distribution of price by cut using <code>geom_boxplot()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> price)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We see much less information about the distribution, but the boxplots are much more compact so we can more easily compare them (and fit more on one plot). It supports the counterintuitive finding that better quality diamonds are cheaper on average! In the exercises, you’ll be challenged to figure out why.</p>
<p><code>cut</code> is an ordered factor: fair is worse than good, which is worse than very good and so on. Many categorical variables don’t have such an intrinsic order, so you might want to reorder them to make a more informative display. One way to do that is with the <code>reorder()</code> function.</p>
<p>For example, take the <code>class</code> variable in the <code>mpg</code> dataset. You might be interested to know how highway mileage varies across classes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> class, <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>To make the trend easier to see, we can reorder <code>class</code> based on the median value of <code>hwy</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(class, hwy, <span class="dt">FUN =</span> median), <span class="dt">y =</span> hwy))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you have long variable names, <code>geom_boxplot()</code> will work better if you flip it 90°. You can do that with <code>coord_flip()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> mpg) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> <span class="kw">reorder</span>(class, hwy, <span class="dt">FUN =</span> median), <span class="dt">y =</span> hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_flip</span>()</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-27-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="exercises-15" class="section level4">
<h4><span class="header-section-number">7.5.1.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Use what you’ve learned to improve the visualisation of the departure times
of cancelled vs. non-cancelled flights.</p></li>
<li><p>What variable in the diamonds dataset is most important for predicting
the price of a diamond? How is that variable correlated with cut?
Why does the combination of those two relationships lead to lower quality
diamonds being more expensive?</p></li>
<li><p>Install the ggstance package, and create a horizontal boxplot.
How does this compare to using <code>coord_flip()</code>?</p></li>
<li><p>One problem with boxplots is that they were developed in an era of
much smaller datasets and tend to display a prohibitively large
number of “outlying values”. One approach to remedy this problem is
the letter value plot. Install the lvplot package, and try using
<code>geom_lv()</code> to display the distribution of price vs cut. What
do you learn? How do you interpret the plots?</p></li>
<li><p>Compare and contrast <code>geom_violin()</code> with a facetted <code>geom_histogram()</code>,
or a coloured <code>geom_freqpoly()</code>. What are the pros and cons of each
method?</p></li>
<li><p>If you have a small dataset, it’s sometimes useful to use <code>geom_jitter()</code>
to see the relationship between a continuous and categorical variable.
The ggbeeswarm package provides a number of methods similar to
<code>geom_jitter()</code>. List them and briefly describe what each one does.</p></li>
</ol>
</div>
</div>
<div id="two-categorical-variables" class="section level3">
<h3><span class="header-section-number">7.5.2</span> Two categorical variables</h3>
<p>To visualise the covariation between categorical variables, you’ll need to count the number of observations for each combination. One way to do that is to rely on the built-in <code>geom_count()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_count</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> color))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-28-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The size of each circle in the plot displays how many observations occurred at each combination of values. Covariation will appear as a strong correlation between specific x values and specific y values.</p>
<p>Another approach is to compute the count with dplyr:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(color, cut)
<span class="co">#&gt; # A tibble: 35 x 3</span>
<span class="co">#&gt;   color cut           n</span>
<span class="co">#&gt;   &lt;ord&gt; &lt;ord&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1 D     Fair        163</span>
<span class="co">#&gt; 2 D     Good        662</span>
<span class="co">#&gt; 3 D     Very Good  1513</span>
<span class="co">#&gt; 4 D     Premium    1603</span>
<span class="co">#&gt; 5 D     Ideal      2834</span>
<span class="co">#&gt; 6 E     Fair        224</span>
<span class="co">#&gt; # … with 29 more rows</span></code></pre>
<p>Then visualise with <code>geom_tile()</code> and the fill aesthetic:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(color, cut) <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> color, <span class="dt">y =</span> cut)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_tile</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">fill =</span> n))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-30-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If the categorical variables are unordered, you might want to use the seriation package to simultaneously reorder the rows and columns in order to more clearly reveal interesting patterns. For larger plots, you might want to try the d3heatmap or heatmaply packages, which create interactive plots.</p>
<div id="exercises-16" class="section level4">
<h4><span class="header-section-number">7.5.2.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>How could you rescale the count dataset above to more clearly show
the distribution of cut within colour, or colour within cut?</p></li>
<li><p>Use <code>geom_tile()</code> together with dplyr to explore how average flight
delays vary by destination and month of year. What makes the
plot difficult to read? How could you improve it?</p></li>
<li><p>Why is it slightly better to use <code>aes(x = color, y = cut)</code> rather
than <code>aes(x = cut, y = color)</code> in the example above?</p></li>
</ol>
</div>
</div>
<div id="two-continuous-variables" class="section level3">
<h3><span class="header-section-number">7.5.3</span> Two continuous variables</h3>
<p>You’ve already seen one great way to visualise the covariation between two continuous variables: draw a scatterplot with <code>geom_point()</code>. You can see covariation as a pattern in the points. For example, you can see an exponential relationship between the carat size and price of a diamond.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Scatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black (as above).
You’ve already seen one way to fix the problem: using the <code>alpha</code> aesthetic to add transparency.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price), <span class="dt">alpha =</span> <span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">100</span>)</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-32-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>But using transparency can be challenging for very large datasets. Another solution is to use bin. Previously you used <code>geom_histogram()</code> and <code>geom_freqpoly()</code> to bin in one dimension. Now you’ll learn how to use <code>geom_bin2d()</code> and <code>geom_hex()</code> to bin in two dimensions.</p>
<p><code>geom_bin2d()</code> and <code>geom_hex()</code> divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. <code>geom_bin2d()</code> creates rectangular bins. <code>geom_hex()</code> creates hexagonal bins. You will need to install the hexbin package to use <code>geom_hex()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> smaller) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bin2d</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price))

<span class="co"># install.packages(&quot;hexbin&quot;)</span>
<span class="kw">ggplot</span>(<span class="dt">data =</span> smaller) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-33-1.png" width="50%" /><img src="EDA_files/figure-html/unnamed-chunk-33-2.png" width="50%" /></p>
<p>Another option is to bin one continuous variable so it acts like a categorical variable. Then you can use one of the techniques for visualising the combination of a categorical and a continuous variable that you learned about. For example, you could bin <code>carat</code> and then for each group, display a boxplot:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> smaller, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">group =</span> <span class="kw">cut_width</span>(carat, <span class="fl">0.1</span>)))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p><code>cut_width(x, width)</code>, as used above, divides <code>x</code> into bins of width <code>width</code>. By default, boxplots look roughly the same (apart from number of outliers) regardless of how many observations there are, so it’s difficult to tell that each boxplot summarises a different number of points. One way to show that is to make the width of the boxplot proportional to the number of points with <code>varwidth = TRUE</code>.</p>
<p>Another approach is to display approximately the same number of points in each bin. That’s the job of <code>cut_number()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> smaller, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">group =</span> <span class="kw">cut_number</span>(carat, <span class="dv">20</span>)))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="exercises-17" class="section level4">
<h4><span class="header-section-number">7.5.3.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Instead of summarising the conditional distribution with a boxplot, you
could use a frequency polygon. What do you need to consider when using
<code>cut_width()</code> vs <code>cut_number()</code>? How does that impact a visualisation of
the 2d distribution of <code>carat</code> and <code>price</code>?</p></li>
<li><p>Visualise the distribution of carat, partitioned by price.</p></li>
<li><p>How does the price distribution of very large diamonds compare to small
diamonds? Is it as you expect, or does it surprise you?</p></li>
<li><p>Combine two of the techniques you’ve learned to visualise the
combined distribution of cut, carat, and price.</p></li>
<li><p>Two dimensional plots reveal outliers that are not visible in one
dimensional plots. For example, some points in the plot below have an
unusual combination of <code>x</code> and <code>y</code> values, which makes the points outliers
even though their <code>x</code> and <code>y</code> values appear normal when examined separately.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_cartesian</span>(<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">11</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">11</span>))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-36-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Why is a scatterplot a better display than a binned plot for this case?</p></li>
</ol>
</div>
</div>
</div>
<div id="patterns-and-models" class="section level2">
<h2><span class="header-section-number">7.6</span> Patterns and models</h2>
<p>Patterns in your data provide clues about relationships. If a systematic relationship exists between two variables it will appear as a pattern in the data. If you spot a pattern, ask yourself:</p>
<ul>
<li><p>Could this pattern be due to coincidence (i.e. random chance)?</p></li>
<li><p>How can you describe the relationship implied by the pattern?</p></li>
<li><p>How strong is the relationship implied by the pattern?</p></li>
<li><p>What other variables might affect the relationship?</p></li>
<li><p>Does the relationship change if you look at individual subgroups of the data?</p></li>
</ul>
<p>A scatterplot of Old Faithful eruption lengths versus the wait time between eruptions shows a pattern: longer wait times are associated with longer eruptions. The scatterplot also displays the two clusters that we noticed above.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> faithful) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> eruptions, <span class="dt">y =</span> waiting))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Patterns provide one of the most useful tools for data scientists because they reveal covariation. If you think of variation as a phenomenon that creates uncertainty, covariation is a phenomenon that reduces it. If two variables covary, you can use the values of one variable to make better predictions about the values of the second. If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.</p>
<p>Models are a tool for extracting patterns out of data. For example, consider the diamonds data. It’s hard to understand the relationship between cut and price, because cut and carat, and carat and price are tightly related. It’s possible to use a model to remove the very strong relationship between price and carat so we can explore the subtleties that remain. The following code fits a model that predicts <code>price</code> from <code>carat</code> and then computes the residuals (the difference between the predicted value and the actual value). The residuals give us a view of the price of the diamond, once the effect of carat has been removed.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(modelr)

mod &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="kw">log</span>(price) <span class="op">~</span><span class="st"> </span><span class="kw">log</span>(carat), <span class="dt">data =</span> diamonds)

diamonds2 &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(mod) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid =</span> <span class="kw">exp</span>(resid))

<span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds2) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> carat, <span class="dt">y =</span> resid))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-38-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Once you’ve removed the strong relationship between carat and price, you can see what you expect in the relationship between cut and price: relative to their size, better quality diamonds are more expensive.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> diamonds2) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>(<span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> cut, <span class="dt">y =</span> resid))</code></pre>
<p><img src="EDA_files/figure-html/unnamed-chunk-39-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You’ll learn how models, and the modelr package, work in the final part of the book, <a href="#model-intro">model</a>. We’re saving modelling for later because understanding what models are and how they work is easiest once you have tools of data wrangling and programming in hand.</p>
</div>
<div id="ggplot2-calls" class="section level2">
<h2><span class="header-section-number">7.7</span> ggplot2 calls</h2>
<p>As we move on from these introductory chapters, we’ll transition to a more concise expression of ggplot2 code. So far we’ve been very explicit, which is helpful when you are learning:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(<span class="dt">data =</span> faithful, <span class="dt">mapping =</span> <span class="kw">aes</span>(<span class="dt">x =</span> eruptions)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="fl">0.25</span>)</code></pre>
<p>Typically, the first one or two arguments to a function are so important that you should know them by heart. The first two arguments to <code>ggplot()</code> are <code>data</code> and <code>mapping</code>, and the first two arguments to <code>aes()</code> are <code>x</code> and <code>y</code>. In the remainder of the book, we won’t supply those names. That saves typing, and, by reducing the amount of boilerplate, makes it easier to see what’s different between plots. That’s a really important programming concern that we’ll come back in <a href="#functions">functions</a>.</p>
<p>Rewriting the previous plot more concisely yields:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(faithful, <span class="kw">aes</span>(eruptions)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="fl">0.25</span>)</code></pre>
<p>Sometimes we’ll turn the end of a pipeline of data transformation into a plot. Watch for the transition from <code>%&gt;%</code> to <code>+</code>. I wish this transition wasn’t necessary but unfortunately ggplot2 was created before the pipe was discovered.</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(cut, clarity) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(clarity, cut, <span class="dt">fill =</span> n)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_tile</span>()</code></pre>
</div>
<div id="learning-more" class="section level2">
<h2><span class="header-section-number">7.8</span> Learning more</h2>
<p>If you want to learn more about the mechanics of ggplot2, I’d highly recommend grabbing a copy of the ggplot2 book: <a href="https://amzn.com/331924275X" class="uri">https://amzn.com/331924275X</a>. It’s been recently updated, so it includes dplyr and tidyr code, and has much more space to explore all the facets of visualisation. Unfortunately the book isn’t generally available for free, but if you have a connection to a university you can probably get an electronic version for free through SpringerLink.</p>
<p>Another useful resource is the <em>R Graphics Cookbook</em><span id="fn9" class="footnote" data-pagedown-footnote-number="9" style="white-space: pre-line;"><a href="https://amzn.com/1449316956" class="uri">https://amzn.com/1449316956</a></span> by Winston Chang. Much of the contents are available online at <a href="http://www.cookbook-r.com/Graphs/" class="uri">http://www.cookbook-r.com/Graphs/</a>.</p>
<p>I also recommend <em>Graphical Data Analysis with R</em><span id="fn10" class="footnote" data-pagedown-footnote-number="10" style="white-space: pre-line;"><a href="https://amzn.com/1498715230" class="uri">https://amzn.com/1498715230</a></span>, by Antony Unwin. This is a book-length treatment similar to the material covered in this chapter, but has the space to go into much greater depth.</p>
<!--chapter:end:EDA.Rmd-->
</div>
</div>
<div id="workflow-projects" class="section level1">
<h1><span class="header-section-number">8</span> Workflow: projects</h1>
<p>One day you will need to quit R, go do something else and return to your analysis the next day. One day you will be working on multiple analyses simultaneously that all use R and you want to keep them separate. One day you will need to bring data from the outside world into R and send numerical results and figures from R back out into the world. To handle these real life situations, you need to make two decisions:</p>
<ol style="list-style-type: decimal">
<li><p>What about your analysis is “real”, i.e. what will you save as your
lasting record of what happened?</p></li>
<li><p>Where does your analysis “live”?</p></li>
</ol>
<div id="what-is-real" class="section level2">
<h2><span class="header-section-number">8.1</span> What is real?</h2>
<p>As a beginning R user, it’s OK to consider your environment (i.e. the objects listed in the environment pane) “real”. However, in the long run, you’ll be much better off if you consider your R scripts as “real”.</p>
<p>With your R scripts (and your data files), you can recreate the environment. It’s much harder to recreate your R scripts from your environment! You’ll either have to retype a lot of code from memory (making mistakes all the way) or you’ll have to carefully mine your R history.</p>
<p>To foster this behaviour, I highly recommend that you instruct RStudio not to preserve your workspace between sessions:</p>
<p><img src="screenshots/rstudio-workspace.png" width="75%" style="display: block; margin: auto;" /></p>
<p>This will cause you some short-term pain, because now when you restart RStudio it will not remember the results of the code that you ran last time. But this short-term pain will save you long-term agony because it forces you to capture all important interactions in your code. There’s nothing worse than discovering three months after the fact that you’ve only stored the results of an important calculation in your workspace, not the calculation itself in your code.</p>
<p>There is a great pair of keyboard shortcuts that will work together to make sure you’ve captured the important parts of your code in the editor:</p>
<ol style="list-style-type: decimal">
<li>Press Cmd/Ctrl + Shift + F10 to restart RStudio.</li>
<li>Press Cmd/Ctrl + Shift + S to rerun the current script.</li>
</ol>
<p>I use this pattern hundreds of times a week.</p>
</div>
<div id="where-does-your-analysis-live" class="section level2">
<h2><span class="header-section-number">8.2</span> Where does your analysis live?</h2>
<p>R has a powerful notion of the <strong>working directory</strong>. This is where R looks for files that you ask it to load, and where it will put any files that you ask it to save. RStudio shows your current working directory at the top of the console:</p>
<p><img src="screenshots/rstudio-wd.png" width="50%" style="display: block; margin: auto;" /></p>
<p>And you can print this out in R code by running <code>getwd()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getwd</span>()
<span class="co">#&gt; [1] &quot;/Users/hadley/Documents/r4ds/r4ds&quot;</span></code></pre>
<p>As a beginning R user, it’s OK to let your home directory, documents directory, or any other weird directory on your computer be R’s working directory. But you’re six chapters into this book, and you’re no longer a rank beginner. Very soon now you should evolve to organising your analytical projects into directories and, when working on a project, setting R’s working directory to the associated directory.</p>
<p><strong>I do not recommend it</strong>, but you can also set the working directory from within R:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setwd</span>(<span class="st">&quot;/path/to/my/CoolProject&quot;</span>)</code></pre>
<p>But you should never do this because there’s a better way; a way that also puts you on the path to managing your R work like an expert.</p>
</div>
<div id="paths-and-directories" class="section level2">
<h2><span class="header-section-number">8.3</span> Paths and directories</h2>
<p>Paths and directories are a little complicated because there are two basic styles of paths: Mac/Linux and Windows. There are three chief ways in which they differ:</p>
<ol style="list-style-type: decimal">
<li><p>The most important difference is how you separate the components of the
path. Mac and Linux uses slashes (e.g. <code>plots/diamonds.pdf</code>) and Windows
uses backslashes (e.g. <code>plots\diamonds.pdf</code>). R can work with either type
(no matter what platform you’re currently using), but unfortunately,
backslashes mean something special to R, and to get a single backslash
in the path, you need to type two backslashes! That makes life frustrating,
so I recommend always using the Linux/Mac style with forward slashes.</p></li>
<li><p>Absolute paths (i.e. paths that point to the same place regardless of
your working directory) look different. In Windows they start with a drive
letter (e.g. <code>C:</code>) or two backslashes (e.g. <code>\\servername</code>) and in
Mac/Linux they start with a slash “/” (e.g. <code>/users/hadley</code>). You should
<strong>never</strong> use absolute paths in your scripts, because they hinder sharing:
no one else will have exactly the same directory configuration as you.</p></li>
<li><p>The last minor difference is the place that <code>~</code> points to. <code>~</code> is a
convenient shortcut to your home directory. Windows doesn’t really have
the notion of a home directory, so it instead points to your documents
directory.</p></li>
</ol>
</div>
<div id="rstudio-projects" class="section level2">
<h2><span class="header-section-number">8.4</span> RStudio projects</h2>
<p>R experts keep all the files associated with a project together — input data, R scripts, analytical results, figures. This is such a wise and common practice that RStudio has built-in support for this via <strong>projects</strong>.</p>
<p>Let’s make a project for you to use while you’re working through the rest of this book. Click File &gt; New Project, then:</p>
<p><img src="screenshots/rstudio-project-1.png" width="50%" style="display: block; margin: auto;" /><img src="screenshots/rstudio-project-2.png" width="50%" style="display: block; margin: auto;" /><img src="screenshots/rstudio-project-3.png" width="50%" style="display: block; margin: auto;" /></p>
<p>Call your project <code>r4ds</code> and think carefully about which <em>subdirectory</em> you put the project in. If you don’t store it somewhere sensible, it will be hard to find it in the future!</p>
<p>Once this process is complete, you’ll get a new RStudio project just for this book. Check that the “home” directory of your project is the current working directory:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getwd</span>()
<span class="co">#&gt; [1] /Users/hadley/Documents/r4ds/r4ds</span></code></pre>
<p>Whenever you refer to a file with a relative path it will look for it here.</p>
<p>Now enter the following commands in the script editor, and save the file, calling it “diamonds.R”. Next, run the complete script which will save a PDF and CSV file into your project directory. Don’t worry about the details, you’ll learn them later in the book.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)

<span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(carat, price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>()
<span class="kw">ggsave</span>(<span class="st">&quot;diamonds.pdf&quot;</span>)

<span class="kw">write_csv</span>(diamonds, <span class="st">&quot;diamonds.csv&quot;</span>)</code></pre>
<p>Quit RStudio. Inspect the folder associated with your project — notice the <code>.Rproj</code> file. Double-click that file to re-open the project. Notice you get back to where you left off: it’s the same working directory and command history, and all the files you were working on are still open. Because you followed my instructions above, you will, however, have a completely fresh environment, guaranteeing that you’re starting with a clean slate.</p>
<p>In your favorite OS-specific way, search your computer for <code>diamonds.pdf</code> and you will find the PDF (no surprise) but <em>also the script that created it</em> (<code>diamonds.R</code>). This is huge win! One day you will want to remake a figure or just understand where it came from. If you rigorously save figures to files <strong>with R code</strong> and never with the mouse or the clipboard, you will be able to reproduce old work with ease!</p>
</div>
<div id="summary" class="section level2">
<h2><span class="header-section-number">8.5</span> Summary</h2>
<p>In summary, RStudio projects give you a solid workflow that will serve you well in the future:</p>
<ul>
<li><p>Create an RStudio project for each data analysis project.</p></li>
<li><p>Keep data files there; we’ll talk about loading them into R in
<a href="#data-import">data import</a>.</p></li>
<li><p>Keep scripts there; edit them, run them in bits or as a whole.</p></li>
<li><p>Save your outputs (plots and cleaned data) there.</p></li>
<li><p>Only ever use relative paths, not absolute paths.</p></li>
</ul>
<p>Everything you need is in one place, and cleanly separated from all the other projects that you are working on.</p>
<!--chapter:end:workflow-projects.Rmd-->
</div>
</div>
<div id="part-wrangle" class="section level1 unnumbered">
<h1><span class="header-section-number">II</span> Wrangle</h1>
</div>
<div id="wrangle-intro" class="section level1">
<h1><span class="header-section-number">9</span> Introduction</h1>
<p>In this part of the book, you’ll learn about data wrangling, the art of getting your data into R in a useful form for visualisation and modelling. Data wrangling is very important: without it you can’t work with your own data! There are three main parts to data wrangling:</p>
<p><img src="diagrams/data-science-wrangle.png" width="75%" style="display: block; margin: auto;" /></p>
<p>This part of the book proceeds as follows:</p>
<ul>
<li><p>In <a href="#tibbles-1">tibbles</a>, you’ll learn about the variant of the data frame that we use
in this book: the <strong>tibble</strong>. You’ll learn what makes them different
from regular data frames, and how you can construct them “by hand”.</p></li>
<li><p>In <a href="#data-import">data import</a>, you’ll learn how to get your data from disk and into R.
We’ll focus on plain-text rectangular formats, but will give you pointers
to packages that help with other types of data.</p></li>
<li><p>In <a href="#tidy-data-1">tidy data</a>, you’ll learn about tidy data, a consistent way of storing
your data that makes transformation, visualisation, and modelling easier.
You’ll learn the underlying principles, and how to get your data into a
tidy form.</p></li>
</ul>
<p>Data wrangling also encompasses data transformation, which you’ve already learned a little about. Now we’ll focus on new skills for three specific types of data you will frequently encounter in practice:</p>
<ul>
<li><p><a href="#relational-data">Relational data</a> will give you tools for working with multiple
interrelated datasets.</p></li>
<li><p><a href="#strings">Strings</a> will introduce regular expressions, a powerful tool for
manipulating strings.</p></li>
<li><p><a href="#factors-1">Factors</a> are how R stores categorical data. They are used when a variable
has a fixed set of possible values, or when you want to use a non-alphabetical
ordering of a string.</p></li>
<li><p><a href="#dates-and-times">Dates and times</a> will give you the key tools for working with
dates and date-times.</p></li>
</ul>
<!--chapter:end:wrangle.Rmd-->
</div>
<div id="tibbles" class="section level1">
<h1><span class="header-section-number">10</span> Tibbles</h1>
<div id="introduction-4" class="section level2">
<h2><span class="header-section-number">10.1</span> Introduction</h2>
<p>Throughout this book we work with “tibbles” instead of R’s traditional <code>data.frame</code>. Tibbles <em>are</em> data frames, but they tweak some older behaviours to make life a little easier. R is an old language, and some things that were useful 10 or 20 years ago now get in your way. It’s difficult to change base R without breaking existing code, so most innovation occurs in packages. Here we will describe the <strong>tibble</strong> package, which provides opinionated data frames that make working in the tidyverse a little easier. In most places, I’ll use the term tibble and data frame interchangeably; when I want to draw particular attention to R’s built-in data frame, I’ll call them <code>data.frame</code>s.</p>
<p>If this chapter leaves you wanting to learn more about tibbles, you might enjoy <code>vignette(&quot;tibble&quot;)</code>.</p>
<div id="prerequisites-4" class="section level3">
<h3><span class="header-section-number">10.1.1</span> Prerequisites</h3>
<p>In this chapter we’ll explore the <strong>tibble</strong> package, part of the core tidyverse.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="tibbles" class="section level2">
<h2><span class="header-section-number">10.2</span> Creating tibbles</h2>
<p>Almost all of the functions that you’ll use in this book produce tibbles, as tibbles are one of the unifying features of the tidyverse. Most other R packages use regular data frames, so you might want to coerce a data frame to a tibble. You can do that with <code>as_tibble()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_tibble</span>(iris)
<span class="co">#&gt; # A tibble: 150 x 5</span>
<span class="co">#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span>
<span class="co">#&gt;          &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;  </span>
<span class="co">#&gt; 1          5.1         3.5          1.4         0.2 setosa </span>
<span class="co">#&gt; 2          4.9         3            1.4         0.2 setosa </span>
<span class="co">#&gt; 3          4.7         3.2          1.3         0.2 setosa </span>
<span class="co">#&gt; 4          4.6         3.1          1.5         0.2 setosa </span>
<span class="co">#&gt; 5          5           3.6          1.4         0.2 setosa </span>
<span class="co">#&gt; 6          5.4         3.9          1.7         0.4 setosa </span>
<span class="co">#&gt; # … with 144 more rows</span></code></pre>
<p>You can create a new tibble from individual vectors with <code>tibble()</code>. <code>tibble()</code> will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, 
  <span class="dt">y =</span> <span class="dv">1</span>, 
  <span class="dt">z =</span> x <span class="op">^</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>y
)
<span class="co">#&gt; # A tibble: 5 x 3</span>
<span class="co">#&gt;       x     y     z</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     1     2</span>
<span class="co">#&gt; 2     2     1     5</span>
<span class="co">#&gt; 3     3     1    10</span>
<span class="co">#&gt; 4     4     1    17</span>
<span class="co">#&gt; 5     5     1    26</span></code></pre>
<p>If you’re already familiar with <code>data.frame()</code>, note that <code>tibble()</code> does much less: it never changes the type of the inputs (e.g. it never converts strings to factors!), it never changes the names of variables, and it never creates row names.</p>
<p>It’s possible for a tibble to have column names that are not valid R variable names, aka <strong>non-syntactic</strong> names. For example, they might not start with a letter, or they might contain unusual characters like a space. To refer to these variables, you need to surround them with backticks, <code>`</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">tb &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">:)</span><span class="st">`</span> =<span class="st"> &quot;smile&quot;</span>, 
  <span class="st">`</span><span class="dt"> </span><span class="st">`</span> =<span class="st"> &quot;space&quot;</span>,
  <span class="st">`</span><span class="dt">2000</span><span class="st">`</span> =<span class="st"> &quot;number&quot;</span>
)
tb
<span class="co">#&gt; # A tibble: 1 x 3</span>
<span class="co">#&gt;   `:)`  ` `   `2000`</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; </span>
<span class="co">#&gt; 1 smile space number</span></code></pre>
<p>You’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.</p>
<p>Another way to create a tibble is with <code>tribble()</code>, short for <strong>tr</strong>ansposed tibble. <code>tribble()</code> is customised for data entry in code: column headings are defined by formulas (i.e. they start with <code>~</code>), and entries are separated by commas. This makes it possible to lay out small amounts of data in easy to read form.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y, <span class="op">~</span>z,
  <span class="co">#--|--|----</span>
  <span class="st">&quot;a&quot;</span>, <span class="dv">2</span>, <span class="fl">3.6</span>,
  <span class="st">&quot;b&quot;</span>, <span class="dv">1</span>, <span class="fl">8.5</span>
)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;   x         y     z</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 a         2   3.6</span>
<span class="co">#&gt; 2 b         1   8.5</span></code></pre>
<p>I often add a comment (the line starting with <code>#</code>), to make it really clear where the header is.</p>
</div>
<div id="tibbles-vs.data.frame" class="section level2">
<h2><span class="header-section-number">10.3</span> Tibbles vs. data.frame</h2>
<p>There are two main differences in the usage of a tibble vs. a classic <code>data.frame</code>: printing and subsetting.</p>
<div id="printing" class="section level3">
<h3><span class="header-section-number">10.3.1</span> Printing</h3>
<p>Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. This makes it much easier to work with large data. In addition to its name, each column reports its type, a nice feature borrowed from <code>str()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">a =</span> lubridate<span class="op">::</span><span class="kw">now</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">86400</span>,
  <span class="dt">b =</span> lubridate<span class="op">::</span><span class="kw">today</span>() <span class="op">+</span><span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e3</span>) <span class="op">*</span><span class="st"> </span><span class="dv">30</span>,
  <span class="dt">c =</span> <span class="dv">1</span><span class="op">:</span><span class="fl">1e3</span>,
  <span class="dt">d =</span> <span class="kw">runif</span>(<span class="fl">1e3</span>),
  <span class="dt">e =</span> <span class="kw">sample</span>(letters, <span class="fl">1e3</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
)
<span class="co">#&gt; # A tibble: 1,000 x 5</span>
<span class="co">#&gt;   a                   b              c     d e    </span>
<span class="co">#&gt;   &lt;dttm&gt;              &lt;date&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1 2019-01-24 17:14:41 2019-01-31     1 0.368 h    </span>
<span class="co">#&gt; 2 2019-01-25 11:19:50 2019-02-05     2 0.612 n    </span>
<span class="co">#&gt; 3 2019-01-25 05:43:30 2019-02-15     3 0.415 l    </span>
<span class="co">#&gt; 4 2019-01-24 19:04:47 2019-02-14     4 0.212 x    </span>
<span class="co">#&gt; 5 2019-01-24 15:29:03 2019-02-11     5 0.733 a    </span>
<span class="co">#&gt; 6 2019-01-25 02:30:00 2019-02-07     6 0.460 v    </span>
<span class="co">#&gt; # … with 994 more rows</span></code></pre>
<p>Tibbles are designed so that you don’t accidentally overwhelm your console when you print large data frames. But sometimes you need more output than the default display. There are a few options that can help.</p>
<p>First, you can explicitly <code>print()</code> the data frame and control the number of rows (<code>n</code>) and the <code>width</code> of the display. <code>width = Inf</code> will display all columns:</p>
<pre class="sourceCode r"><code class="sourceCode r">nycflights13<span class="op">::</span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="dv">10</span>, <span class="dt">width =</span> <span class="ot">Inf</span>)</code></pre>
<p>You can also control the default print behaviour by setting options:</p>
<ul>
<li><p><code>options(tibble.print_max = n, tibble.print_min = m)</code>: if more than <code>n</code>
rows, print only <code>m</code> rows. Use <code>options(tibble.print_min = Inf)</code> to always
show all rows.</p></li>
<li><p>Use <code>options(tibble.width = Inf)</code> to always print all columns, regardless
of the width of the screen.</p></li>
</ul>
<p>You can see a complete list of options by looking at the package help with <code>package?tibble</code>.</p>
<p>A final option is to use RStudio’s built-in data viewer to get a scrollable view of the complete dataset. This is also often useful at the end of a long chain of manipulations.</p>
<pre class="sourceCode r"><code class="sourceCode r">nycflights13<span class="op">::</span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">View</span>()</code></pre>
</div>
<div id="subsetting" class="section level3">
<h3><span class="header-section-number">10.3.2</span> Subsetting</h3>
<p>So far all the tools you’ve learned have worked with complete data frames. If you want to pull out a single variable, you need some new tools, <code>$</code> and <code>[[</code>. <code>[[</code> can extract by name or position; <code>$</code> only extracts by name but is a little less typing.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">runif</span>(<span class="dv">5</span>),
  <span class="dt">y =</span> <span class="kw">rnorm</span>(<span class="dv">5</span>)
)

<span class="co"># Extract by name</span>
df<span class="op">$</span>x
<span class="co">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span>
df[[<span class="st">&quot;x&quot;</span>]]
<span class="co">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span>

<span class="co"># Extract by position</span>
df[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span></code></pre>
<p>To use these in a pipe, you’ll need to use the special placeholder <code>.</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>.<span class="op">$</span>x
<span class="co">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span>
df <span class="op">%&gt;%</span><span class="st"> </span>.[[<span class="st">&quot;x&quot;</span>]]
<span class="co">#&gt; [1] 0.434 0.395 0.548 0.762 0.254</span></code></pre>
<p>Compared to a <code>data.frame</code>, tibbles are more strict: they never do partial matching, and they will generate a warning if the column you are trying to access does not exist.</p>
</div>
</div>
<div id="interacting-with-older-code" class="section level2">
<h2><span class="header-section-number">10.4</span> Interacting with older code</h2>
<p>Some older functions don’t work with tibbles. If you encounter one of these functions, use <code>as.data.frame()</code> to turn a tibble back to a <code>data.frame</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(<span class="kw">as.data.frame</span>(tb))
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre>
<p>The main reason that some older functions don’t work with tibble is the <code>[</code> function. We don’t use <code>[</code> much in this book because <code>dplyr::filter()</code> and <code>dplyr::select()</code> allow you to solve the same problems with clearer code (but you will learn a little about it in <a href="#vector-subsetting">vector subsetting</a>). With base R data frames, <code>[</code> sometimes returns a data frame, and sometimes returns a vector. With tibbles, <code>[</code> always returns another tibble.</p>
</div>
<div id="exercises-18" class="section level2">
<h2><span class="header-section-number">10.5</span> Exercises</h2>
<ol style="list-style-type: decimal">
<li><p>How can you tell if an object is a tibble? (Hint: try printing <code>mtcars</code>,
which is a regular data frame).</p></li>
<li><p>Compare and contrast the following operations on a <code>data.frame</code> and
equivalent tibble. What is different? Why might the default data frame
behaviours cause you frustration?</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">xyz =</span> <span class="st">&quot;a&quot;</span>)
df<span class="op">$</span>x
df[, <span class="st">&quot;xyz&quot;</span>]
df[, <span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;xyz&quot;</span>)]</code></pre></li>
<li><p>If you have the name of a variable stored in an object, e.g. <code>var &lt;- &quot;mpg&quot;</code>,
how can you extract the reference variable from a tibble?</p></li>
<li><p>Practice referring to non-syntactic names in the following data frame by:</p>
<ol style="list-style-type: decimal">
<li><p>Extracting the variable called <code>1</code>.</p></li>
<li><p>Plotting a scatterplot of <code>1</code> vs <code>2</code>.</p></li>
<li><p>Creating a new column called <code>3</code> which is <code>2</code> divided by <code>1</code>.</p></li>
<li><p>Renaming the columns to <code>one</code>, <code>two</code> and <code>three</code>.</p></li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r">annoying &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="st">`</span><span class="dt">1</span><span class="st">`</span> =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>,
  <span class="st">`</span><span class="dt">2</span><span class="st">`</span> =<span class="st"> `</span><span class="dt">1</span><span class="st">`</span> <span class="op">*</span><span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(<span class="st">`</span><span class="dt">1</span><span class="st">`</span>))
)</code></pre></li>
<li><p>What does <code>tibble::enframe()</code> do? When might you use it?</p></li>
<li><p>What option controls how many additional column names are printed
at the footer of a tibble?</p></li>
</ol>
<!--chapter:end:tibble.Rmd-->
</div>
</div>
<div id="data-import" class="section level1">
<h1><span class="header-section-number">11</span> Data import</h1>
<div id="introduction-5" class="section level2">
<h2><span class="header-section-number">11.1</span> Introduction</h2>
<p>Working with data provided by R packages is a great way to learn the tools of data science, but at some point you want to stop learning and start working with your own data. In this chapter, you’ll learn how to read plain-text rectangular files into R. Here, we’ll only scratch the surface of data import, but many of the principles will translate to other forms of data. We’ll finish with a few pointers to packages that are useful for other types of data.</p>
<div id="prerequisites-5" class="section level3">
<h3><span class="header-section-number">11.1.1</span> Prerequisites</h3>
<p>In this chapter, you’ll learn how to load flat files in R with the <strong>readr</strong> package, which is part of the core tidyverse.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="getting-started" class="section level2">
<h2><span class="header-section-number">11.2</span> Getting started</h2>
<p>Most of readr’s functions are concerned with turning flat files into data frames:</p>
<ul>
<li><p><code>read_csv()</code> reads comma delimited files, <code>read_csv2()</code> reads semicolon
separated files (common in countries where <code>,</code> is used as the decimal place),
<code>read_tsv()</code> reads tab delimited files, and <code>read_delim()</code> reads in files
with any delimiter.</p></li>
<li><p><code>read_fwf()</code> reads fixed width files. You can specify fields either by their
widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code>.
<code>read_table()</code> reads a common variation of fixed width files where columns
are separated by white space.</p></li>
<li><p><code>read_log()</code> reads Apache style log files. (But also check out
webreadr<span id="fn11" class="footnote" data-pagedown-footnote-number="11" style="white-space: pre-line;"><a href="https://github.com/Ironholds/webreadr" class="uri">https://github.com/Ironholds/webreadr</a></span> which is built on top
of <code>read_log()</code> and provides many more helpful tools.)</p></li>
</ul>
<p>These functions all have similar syntax: once you’ve mastered one, you can use the others with ease. For the rest of this chapter we’ll focus on <code>read_csv()</code>. Not only are csv files one of the most common forms of data storage, but once you understand <code>read_csv()</code>, you can easily apply your knowledge to all the other functions in readr.</p>
<p>The first argument to <code>read_csv()</code> is the most important: it’s the path to the file to read.</p>
<pre class="sourceCode r"><code class="sourceCode r">heights &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/heights.csv&quot;</span>)
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   earn = col_double(),</span>
<span class="co">#&gt;   height = col_double(),</span>
<span class="co">#&gt;   sex = col_character(),</span>
<span class="co">#&gt;   ed = col_double(),</span>
<span class="co">#&gt;   age = col_double(),</span>
<span class="co">#&gt;   race = col_character()</span>
<span class="co">#&gt; )</span></code></pre>
<p>When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column. That’s an important part of readr, which we’ll come back to in <a href="#parsing-a-file">parsing a file</a>.</p>
<p>You can also supply an inline csv file. This is useful for experimenting with readr and for creating reproducible examples to share with others:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span>
<span class="st">1,2,3</span>
<span class="st">4,5,6&quot;</span>)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;       a     b     c</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2     3</span>
<span class="co">#&gt; 2     4     5     6</span></code></pre>
<p>In both cases <code>read_csv()</code> uses the first line of the data for the column names, which is a very common convention. There are two cases where you might want to tweak this behaviour:</p>
<ol style="list-style-type: decimal">
<li><p>Sometimes there are a few lines of metadata at the top of the file. You can
use <code>skip = n</code> to skip the first <code>n</code> lines; or use <code>comment = &quot;#&quot;</code> to drop
all lines that start with (e.g.) <code>#</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;The first line of metadata</span>
<span class="st">  The second line of metadata</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)
<span class="co">#&gt; # A tibble: 1 x 3</span>
<span class="co">#&gt;       x     y     z</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2     3</span>

<span class="kw">read_csv</span>(<span class="st">&quot;# A comment I want to skip</span>
<span class="st">  x,y,z</span>
<span class="st">  1,2,3&quot;</span>, <span class="dt">comment =</span> <span class="st">&quot;#&quot;</span>)
<span class="co">#&gt; # A tibble: 1 x 3</span>
<span class="co">#&gt;       x     y     z</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2     3</span></code></pre></li>
<li><p>The data might not have column names. You can use <code>col_names = FALSE</code> to
tell <code>read_csv()</code> not to treat the first row as headings, and instead
label them sequentially from <code>X1</code> to <code>Xn</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;      X1    X2    X3</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2     3</span>
<span class="co">#&gt; 2     4     5     6</span></code></pre>
<p>(<code>&quot;\n&quot;</code> is a convenient shortcut for adding a new line. You’ll learn more
about it and other types of string escape in <a href="#string-basics">string basics</a>.)</p>
<p>Alternatively you can pass <code>col_names</code> a character vector which will be
used as the column names:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>, <span class="dt">col_names =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>))
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;       x     y     z</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2     3</span>
<span class="co">#&gt; 2     4     5     6</span></code></pre></li>
</ol>
<p>Another option that commonly needs tweaking is <code>na</code>: this specifies the value (or values) that are used to represent missing values in your file:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2,.&quot;</span>, <span class="dt">na =</span> <span class="st">&quot;.&quot;</span>)
<span class="co">#&gt; # A tibble: 1 x 3</span>
<span class="co">#&gt;       a     b c    </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;</span>
<span class="co">#&gt; 1     1     2 NA</span></code></pre>
<p>This is all you need to know to read ~75% of CSV files that you’ll encounter in practice. You can also easily adapt what you’ve learned to read tab separated files with <code>read_tsv()</code> and fixed width files with <code>read_fwf()</code>. To read in more challenging files, you’ll need to learn more about how readr parses each column, turning them into R vectors.</p>
<div id="compared-to-base-r" class="section level3">
<h3><span class="header-section-number">11.2.1</span> Compared to base R</h3>
<p>If you’ve used R before, you might wonder why we’re not using <code>read.csv()</code>. There are a few good reasons to favour readr functions over the base equivalents:</p>
<ul>
<li><p>They are typically much faster (~10x) than their base equivalents.
Long running jobs have a progress bar, so you can see what’s happening.
If you’re looking for raw speed, try <code>data.table::fread()</code>. It doesn’t fit
quite so well into the tidyverse, but it can be quite a bit faster.</p></li>
<li><p>They produce tibbles, they don’t convert character vectors to factors,
use row names, or munge the column names. These are common sources of
frustration with the base R functions.</p></li>
<li><p>They are more reproducible. Base R functions inherit some behaviour from
your operating system and environment variables, so import code that works
on your computer might not work on someone else’s.</p></li>
</ul>
</div>
<div id="exercises-19" class="section level3">
<h3><span class="header-section-number">11.2.2</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What function would you use to read a file where fields were separated with<br />
“|”?</p></li>
<li><p>Apart from <code>file</code>, <code>skip</code>, and <code>comment</code>, what other arguments do
<code>read_csv()</code> and <code>read_tsv()</code> have in common?</p></li>
<li><p>What are the most important arguments to <code>read_fwf()</code>?</p></li>
<li><p>Sometimes strings in a CSV file contain commas. To prevent them from
causing problems they need to be surrounded by a quoting character, like
<code>&quot;</code> or <code>'</code>. By convention, <code>read_csv()</code> assumes that the quoting
character will be <code>&quot;</code>, and if you want to change it you’ll need to
use <code>read_delim()</code> instead. What arguments do you need to specify
to read the following text into a data frame?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;x,y</span><span class="ch">\n</span><span class="st">1,&#39;a,b&#39;&quot;</span></code></pre></li>
<li><p>Identify what is wrong with each of the following inline CSV files.
What happens when you run the code?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n</span><span class="st">1,2,3</span><span class="ch">\n</span><span class="st">4,5,6&quot;</span>)
<span class="kw">read_csv</span>(<span class="st">&quot;a,b,c</span><span class="ch">\n</span><span class="st">1,2</span><span class="ch">\n</span><span class="st">1,2,3,4&quot;</span>)
<span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n\&quot;</span><span class="st">1&quot;</span>)
<span class="kw">read_csv</span>(<span class="st">&quot;a,b</span><span class="ch">\n</span><span class="st">1,2</span><span class="ch">\n</span><span class="st">a,b&quot;</span>)
<span class="kw">read_csv</span>(<span class="st">&quot;a;b</span><span class="ch">\n</span><span class="st">1;3&quot;</span>)</code></pre></li>
</ol>
</div>
</div>
<div id="parsing-a-vector" class="section level2">
<h2><span class="header-section-number">11.3</span> Parsing a vector</h2>
<p>Before we get into the details of how readr reads files from disk, we need to take a little detour to talk about the <code>parse_*()</code> functions. These functions take a character vector and return a more specialised vector like a logical, integer, or date:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(<span class="kw">parse_logical</span>(<span class="kw">c</span>(<span class="st">&quot;TRUE&quot;</span>, <span class="st">&quot;FALSE&quot;</span>, <span class="st">&quot;NA&quot;</span>)))
<span class="co">#&gt;  logi [1:3] TRUE FALSE NA</span>
<span class="kw">str</span>(<span class="kw">parse_integer</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>)))
<span class="co">#&gt;  int [1:3] 1 2 3</span>
<span class="kw">str</span>(<span class="kw">parse_date</span>(<span class="kw">c</span>(<span class="st">&quot;2010-01-01&quot;</span>, <span class="st">&quot;1979-10-14&quot;</span>)))
<span class="co">#&gt;  Date[1:2], format: &quot;2010-01-01&quot; &quot;1979-10-14&quot;</span></code></pre>
<p>These functions are useful in their own right, but are also an important building block for readr. Once you’ve learned how the individual parsers work in this section, we’ll circle back and see how they fit together to parse a complete file in the next section.</p>
<p>Like all functions in the tidyverse, the <code>parse_*()</code> functions are uniform: the first argument is a character vector to parse, and the <code>na</code> argument specifies which strings should be treated as missing:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_integer</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;231&quot;</span>, <span class="st">&quot;.&quot;</span>, <span class="st">&quot;456&quot;</span>), <span class="dt">na =</span> <span class="st">&quot;.&quot;</span>)
<span class="co">#&gt; [1]   1 231  NA 456</span></code></pre>
<p>If parsing fails, you’ll get a warning:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">parse_integer</span>(<span class="kw">c</span>(<span class="st">&quot;123&quot;</span>, <span class="st">&quot;345&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;123.45&quot;</span>))
<span class="co">#&gt; Warning: 2 parsing failures.</span>
<span class="co">#&gt; row col               expected actual</span>
<span class="co">#&gt;   3  -- an integer                abc</span>
<span class="co">#&gt;   4  -- no trailing characters    .45</span></code></pre>
<p>And the failures will be missing in the output:</p>
<pre class="sourceCode r"><code class="sourceCode r">x
<span class="co">#&gt; [1] 123 345  NA  NA</span>
<span class="co">#&gt; attr(,&quot;problems&quot;)</span>
<span class="co">#&gt; # A tibble: 2 x 4</span>
<span class="co">#&gt;     row   col expected               actual</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt; </span>
<span class="co">#&gt; 1     3    NA an integer             abc   </span>
<span class="co">#&gt; 2     4    NA no trailing characters .45</span></code></pre>
<p>If there are many parsing failures, you’ll need to use <code>problems()</code> to get the complete set. This returns a tibble, which you can then manipulate with dplyr.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">problems</span>(x)
<span class="co">#&gt; # A tibble: 2 x 4</span>
<span class="co">#&gt;     row   col expected               actual</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt; </span>
<span class="co">#&gt; 1     3    NA an integer             abc   </span>
<span class="co">#&gt; 2     4    NA no trailing characters .45</span></code></pre>
<p>Using parsers is mostly a matter of understanding what’s available and how they deal with different types of input. There are eight particularly important parsers:</p>
<ol style="list-style-type: decimal">
<li><p><code>parse_logical()</code> and <code>parse_integer()</code> parse logicals and integers
respectively. There’s basically nothing that can go wrong with these
parsers so I won’t describe them here further.</p></li>
<li><p><code>parse_double()</code> is a strict numeric parser, and <code>parse_number()</code>
is a flexible numeric parser. These are more complicated than you might
expect because different parts of the world write numbers in different
ways.</p></li>
<li><p><code>parse_character()</code> seems so simple that it shouldn’t be necessary. But
one complication makes it quite important: character encodings.</p></li>
<li><p><code>parse_factor()</code> create factors, the data structure that R uses to represent
categorical variables with fixed and known values.</p></li>
<li><p><code>parse_datetime()</code>, <code>parse_date()</code>, and <code>parse_time()</code> allow you to
parse various date &amp; time specifications. These are the most complicated
because there are so many different ways of writing dates.</p></li>
</ol>
<p>The following sections describe these parsers in more detail.</p>
<div id="numbers" class="section level3">
<h3><span class="header-section-number">11.3.1</span> Numbers</h3>
<p>It seems like it should be straightforward to parse a number, but three problems make it tricky:</p>
<ol style="list-style-type: decimal">
<li><p>People write numbers differently in different parts of the world.
For example, some countries use <code>.</code> in between the integer and fractional
parts of a real number, while others use <code>,</code>.</p></li>
<li><p>Numbers are often surrounded by other characters that provide some
context, like “$1000” or “10%”.</p></li>
<li><p>Numbers often contain “grouping” characters to make them easier to read,
like “1,000,000”, and these grouping characters vary around the world.</p></li>
</ol>
<p>To address the first problem, readr has the notion of a “locale”, an object that specifies parsing options that differ from place to place. When parsing numbers, the most important option is the character you use for the decimal mark. You can override the default value of <code>.</code> by creating a new locale and setting the <code>decimal_mark</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_double</span>(<span class="st">&quot;1.23&quot;</span>)
<span class="co">#&gt; [1] 1.23</span>
<span class="kw">parse_double</span>(<span class="st">&quot;1,23&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">decimal_mark =</span> <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt; [1] 1.23</span></code></pre>
<p>readr’s default locale is US-centric, because generally R is US-centric (i.e. the documentation of base R is written in American English). An alternative approach would be to try and guess the defaults from your operating system. This is hard to do well, and, more importantly, makes your code fragile: even if it works on your computer, it might fail when you email it to a colleague in another country.</p>
<p><code>parse_number()</code> addresses the second problem: it ignores non-numeric characters before and after the number. This is particularly useful for currencies and percentages, but also works to extract numbers embedded in text.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_number</span>(<span class="st">&quot;$100&quot;</span>)
<span class="co">#&gt; [1] 100</span>
<span class="kw">parse_number</span>(<span class="st">&quot;20%&quot;</span>)
<span class="co">#&gt; [1] 20</span>
<span class="kw">parse_number</span>(<span class="st">&quot;It cost $123.45&quot;</span>)
<span class="co">#&gt; [1] 123</span></code></pre>
<p>The final problem is addressed by the combination of <code>parse_number()</code> and the locale as <code>parse_number()</code> will ignore the “grouping mark”:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Used in America</span>
<span class="kw">parse_number</span>(<span class="st">&quot;$123,456,789&quot;</span>)
<span class="co">#&gt; [1] 1.23e+08</span>

<span class="co"># Used in many parts of Europe</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123.456.789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;.&quot;</span>))
<span class="co">#&gt; [1] 1.23e+08</span>

<span class="co"># Used in Switzerland</span>
<span class="kw">parse_number</span>(<span class="st">&quot;123&#39;456&#39;789&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">grouping_mark =</span> <span class="st">&quot;&#39;&quot;</span>))
<span class="co">#&gt; [1] 1.23e+08</span></code></pre>
</div>
<div id="readr-strings" class="section level3">
<h3><span class="header-section-number">11.3.2</span> Strings</h3>
<p>It seems like <code>parse_character()</code> should be really simple — it could just return its input. Unfortunately life isn’t so simple, as there are multiple ways to represent the same string. To understand what’s going on, we need to dive into the details of how computers represent strings. In R, we can get at the underlying representation of a string using <code>charToRaw()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">charToRaw</span>(<span class="st">&quot;Hadley&quot;</span>)
<span class="co">#&gt; [1] 48 61 64 6c 65 79</span></code></pre>
<p>Each hexadecimal number represents a byte of information: <code>48</code> is H, <code>61</code> is a, and so on. The mapping from hexadecimal number to character is called the encoding, and in this case the encoding is called ASCII. ASCII does a great job of representing English characters, because it’s the <strong>American</strong> Standard Code for Information Interchange.</p>
<p>Things get more complicated for languages other than English. In the early days of computing there were many competing standards for encoding non-English characters, and to correctly interpret a string you needed to know both the values and the encoding. For example, two common encodings are Latin1 (aka ISO-8859-1, used for Western European languages) and Latin2 (aka ISO-8859-2, used for Eastern European languages). In Latin1, the byte <code>b1</code> is “±”, but in Latin2, it’s “ą”! Fortunately, today there is one standard that is supported almost everywhere: UTF-8. UTF-8 can encode just about every character used by humans today, as well as many extra symbols (like emoji!).</p>
<p>readr uses UTF-8 everywhere: it assumes your data is UTF-8 encoded when you read it, and always uses it when writing. This is a good default, but will fail for data produced by older systems that don’t understand UTF-8. If this happens to you, your strings will look weird when you print them. Sometimes just one or two characters might be messed up; other times you’ll get complete gibberish. For example:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> &quot;El Ni</span><span class="ch">\xf1</span><span class="st">o was particularly bad this year&quot;</span>
x2 &lt;-<span class="st"> &quot;</span><span class="ch">\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd</span><span class="st">&quot;</span>

x1
<span class="co">#&gt; [1] &quot;El Ni\xf1o was particularly bad this year&quot;</span>
x2
<span class="co">#&gt; [1] &quot;\x82\xb1\x82\xf1\x82ɂ\xbf\x82\xcd&quot;</span></code></pre>
<p>To fix the problem you need to specify the encoding in <code>parse_character()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_character</span>(x1, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;Latin1&quot;</span>))
<span class="co">#&gt; [1] &quot;El Niño was particularly bad this year&quot;</span>
<span class="kw">parse_character</span>(x2, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;Shift-JIS&quot;</span>))
<span class="co">#&gt; [1] &quot;こんにちは&quot;</span></code></pre>
<p>How do you find the correct encoding? If you’re lucky, it’ll be included somewhere in the data documentation. Unfortunately, that’s rarely the case, so readr provides <code>guess_encoding()</code> to help you figure it out. It’s not foolproof, and it works better when you have lots of text (unlike here), but it’s a reasonable place to start. Expect to try a few different encodings before you find the right one.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">guess_encoding</span>(<span class="kw">charToRaw</span>(x1))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   encoding   confidence</span>
<span class="co">#&gt;   &lt;chr&gt;           &lt;dbl&gt;</span>
<span class="co">#&gt; 1 ISO-8859-1       0.46</span>
<span class="co">#&gt; 2 ISO-8859-9       0.23</span>
<span class="kw">guess_encoding</span>(<span class="kw">charToRaw</span>(x2))
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;   encoding confidence</span>
<span class="co">#&gt;   &lt;chr&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt; 1 KOI8-R         0.42</span></code></pre>
<p>The first argument to <code>guess_encoding()</code> can either be a path to a file, or, as in this case, a raw vector (useful if the strings are already in R).</p>
<p>Encodings are a rich and complex topic, and I’ve only scratched the surface here. If you’d like to learn more I’d recommend reading the detailed explanation at <a href="http://kunststube.net/encoding/" class="uri">http://kunststube.net/encoding/</a>.</p>
</div>
<div id="readr-factors" class="section level3">
<h3><span class="header-section-number">11.3.3</span> Factors</h3>
<p>R uses factors to represent categorical variables that have a known set of possible values. Give <code>parse_factor()</code> a vector of known <code>levels</code> to generate a warning whenever an unexpected value is present:</p>
<pre class="sourceCode r"><code class="sourceCode r">fruit &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>)
<span class="kw">parse_factor</span>(<span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;bananana&quot;</span>), <span class="dt">levels =</span> fruit)
<span class="co">#&gt; Warning: 1 parsing failure.</span>
<span class="co">#&gt; row col           expected   actual</span>
<span class="co">#&gt;   3  -- value in level set bananana</span>
<span class="co">#&gt; [1] apple  banana &lt;NA&gt;  </span>
<span class="co">#&gt; attr(,&quot;problems&quot;)</span>
<span class="co">#&gt; # A tibble: 1 x 4</span>
<span class="co">#&gt;     row   col expected           actual  </span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;chr&gt;              &lt;chr&gt;   </span>
<span class="co">#&gt; 1     3    NA value in level set bananana</span>
<span class="co">#&gt; Levels: apple banana</span></code></pre>
<p>But if you have many problematic entries, it’s often easier to leave as character vectors and then use the tools you’ll learn about in <a href="#strings">strings</a> and <a href="#factors-1">factors</a> to clean them up.</p>
</div>
<div id="readr-datetimes" class="section level3">
<h3><span class="header-section-number">11.3.4</span> Dates, date-times, and times</h3>
<p>You pick between three parsers depending on whether you want a date (the number of days since 1970-01-01), a date-time (the number of seconds since midnight 1970-01-01), or a time (the number of seconds since midnight). When called without any additional arguments:</p>
<ul>
<li><p><code>parse_datetime()</code> expects an ISO8601 date-time. ISO8601 is an
international standard in which the components of a date are
organised from biggest to smallest: year, month, day, hour, minute,
second.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_datetime</span>(<span class="st">&quot;2010-10-01T2010&quot;</span>)
<span class="co">#&gt; [1] &quot;2010-10-01 20:10:00 UTC&quot;</span>
<span class="co"># If time is omitted, it will be set to midnight</span>
<span class="kw">parse_datetime</span>(<span class="st">&quot;20101010&quot;</span>)
<span class="co">#&gt; [1] &quot;2010-10-10 UTC&quot;</span></code></pre>
<p>This is the most important date/time standard, and if you work with
dates and times frequently, I recommend reading
<a href="https://en.wikipedia.org/wiki/ISO_8601" class="uri">https://en.wikipedia.org/wiki/ISO_8601</a></p></li>
<li><p><code>parse_date()</code> expects a four digit year, a <code>-</code> or <code>/</code>, the month, a <code>-</code>
or <code>/</code>, then the day:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;2010-10-01&quot;</span>)
<span class="co">#&gt; [1] &quot;2010-10-01&quot;</span></code></pre></li>
<li><p><code>parse_time()</code> expects the hour, <code>:</code>, minutes, optionally <code>:</code> and seconds,
and an optional am/pm specifier:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(hms)
<span class="kw">parse_time</span>(<span class="st">&quot;01:10 am&quot;</span>)
<span class="co">#&gt; 01:10:00</span>
<span class="kw">parse_time</span>(<span class="st">&quot;20:10:01&quot;</span>)
<span class="co">#&gt; 20:10:01</span></code></pre>
<p>Base R doesn’t have a great built in class for time data, so we use
the one provided in the hms package.</p></li>
</ul>
<p>If these defaults don’t work for your data you can supply your own date-time <code>format</code>, built up of the following pieces:</p>
<dl>
<dt>Year</dt>
<dd><code>%Y</code> (4 digits).
</dd>
<dd><code>%y</code> (2 digits); 00-69 -&gt; 2000-2069, 70-99 -&gt; 1970-1999.
</dd>
<dt>Month</dt>
<dd><code>%m</code> (2 digits).
</dd>
<dd><code>%b</code> (abbreviated name, like “Jan”).
</dd>
<dd><code>%B</code> (full name, “January”).
</dd>
<dt>Day</dt>
<dd><code>%d</code> (2 digits).
</dd>
<dd><code>%e</code> (optional leading space).
</dd>
<dt>Time</dt>
<dd><code>%H</code> 0-23 hour.
</dd>
<dd><code>%I</code> 0-12, must be used with <code>%p</code>.
</dd>
<dd><code>%p</code> AM/PM indicator.
</dd>
<dd><code>%M</code> minutes.
</dd>
<dd><code>%S</code> integer seconds.
</dd>
<dd><code>%OS</code> real seconds.
</dd>
<dd><code>%Z</code> Time zone (as name, e.g. <code>America/Chicago</code>). Beware of abbreviations:
if you’re American, note that “EST” is a Canadian time zone that does not
have daylight savings time. It is <em>not</em> Eastern Standard Time! We’ll
come back to this <a href="#time-zones">time zones</a>.
</dd>
<dd><code>%z</code> (as offset from UTC, e.g. <code>+0800</code>).
</dd>
<dt>Non-digits</dt>
<dd><code>%.</code> skips one non-digit character.
</dd>
<dd><code>%*</code> skips any number of non-digits.
</dd>
</dl>
<p>The best way to figure out the correct format is to create a few examples in a character vector, and test with one of the parsing functions. For example:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;01/02/15&quot;</span>, <span class="st">&quot;%m/%d/%y&quot;</span>)
<span class="co">#&gt; [1] &quot;2015-01-02&quot;</span>
<span class="kw">parse_date</span>(<span class="st">&quot;01/02/15&quot;</span>, <span class="st">&quot;%d/%m/%y&quot;</span>)
<span class="co">#&gt; [1] &quot;2015-02-01&quot;</span>
<span class="kw">parse_date</span>(<span class="st">&quot;01/02/15&quot;</span>, <span class="st">&quot;%y/%m/%d&quot;</span>)
<span class="co">#&gt; [1] &quot;2001-02-15&quot;</span></code></pre>
<p>If you’re using <code>%b</code> or <code>%B</code> with non-English month names, you’ll need to set the <code>lang</code> argument to <code>locale()</code>. See the list of built-in languages in <code>date_names_langs()</code>, or if your language is not already included, create your own with <code>date_names()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parse_date</span>(<span class="st">&quot;1 janvier 2015&quot;</span>, <span class="st">&quot;%d %B %Y&quot;</span>, <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="st">&quot;fr&quot;</span>))
<span class="co">#&gt; [1] &quot;2015-01-01&quot;</span></code></pre>
</div>
<div id="exercises-20" class="section level3">
<h3><span class="header-section-number">11.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What are the most important arguments to <code>locale()</code>?</p></li>
<li><p>What happens if you try and set <code>decimal_mark</code> and <code>grouping_mark</code>
to the same character? What happens to the default value of
<code>grouping_mark</code> when you set <code>decimal_mark</code> to “,”? What happens
to the default value of <code>decimal_mark</code> when you set the <code>grouping_mark</code>
to “.”?</p></li>
<li><p>I didn’t discuss the <code>date_format</code> and <code>time_format</code> options to
<code>locale()</code>. What do they do? Construct an example that shows when
they might be useful.</p></li>
<li><p>If you live outside the US, create a new locale object that encapsulates
the settings for the types of file you read most commonly.</p></li>
<li><p>What’s the difference between <code>read_csv()</code> and <code>read_csv2()</code>?</p></li>
<li><p>What are the most common encodings used in Europe? What are the
most common encodings used in Asia? Do some googling to find out.</p></li>
<li><p>Generate the correct format string to parse each of the following
dates and times:</p>
<pre class="sourceCode r"><code class="sourceCode r">d1 &lt;-<span class="st"> &quot;January 1, 2010&quot;</span>
d2 &lt;-<span class="st"> &quot;2015-Mar-07&quot;</span>
d3 &lt;-<span class="st"> &quot;06-Jun-2017&quot;</span>
d4 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;August 19 (2015)&quot;</span>, <span class="st">&quot;July 1 (2015)&quot;</span>)
d5 &lt;-<span class="st"> &quot;12/30/14&quot;</span> <span class="co"># Dec 30, 2014</span>
t1 &lt;-<span class="st"> &quot;1705&quot;</span>
t2 &lt;-<span class="st"> &quot;11:15:10.12 PM&quot;</span></code></pre></li>
</ol>
</div>
</div>
<div id="parsing-a-file" class="section level2">
<h2><span class="header-section-number">11.4</span> Parsing a file</h2>
<p>Now that you’ve learned how to parse an individual vector, it’s time to return to the beginning and explore how readr parses a file. There are two new things that you’ll learn about in this section:</p>
<ol style="list-style-type: decimal">
<li>How readr automatically guesses the type of each column.</li>
<li>How to override the default specification.</li>
</ol>
<div id="strategy" class="section level3">
<h3><span class="header-section-number">11.4.1</span> Strategy</h3>
<p>readr uses a heuristic to figure out the type of each column: it reads the first 1000 rows and uses some (moderately conservative) heuristics to figure out the type of each column. You can emulate this process with a character vector using <code>guess_parser()</code>, which returns readr’s best guess, and <code>parse_guess()</code> which uses that guess to parse the column:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">guess_parser</span>(<span class="st">&quot;2010-10-01&quot;</span>)
<span class="co">#&gt; [1] &quot;date&quot;</span>
<span class="kw">guess_parser</span>(<span class="st">&quot;15:01&quot;</span>)
<span class="co">#&gt; [1] &quot;time&quot;</span>
<span class="kw">guess_parser</span>(<span class="kw">c</span>(<span class="st">&quot;TRUE&quot;</span>, <span class="st">&quot;FALSE&quot;</span>))
<span class="co">#&gt; [1] &quot;logical&quot;</span>
<span class="kw">guess_parser</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;5&quot;</span>, <span class="st">&quot;9&quot;</span>))
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">guess_parser</span>(<span class="kw">c</span>(<span class="st">&quot;12,352,561&quot;</span>))
<span class="co">#&gt; [1] &quot;number&quot;</span>

<span class="kw">str</span>(<span class="kw">parse_guess</span>(<span class="st">&quot;2010-10-10&quot;</span>))
<span class="co">#&gt;  Date[1:1], format: &quot;2010-10-10&quot;</span></code></pre>
<p>The heuristic tries each of the following types, stopping when it finds a match:</p>
<ul>
<li>logical: contains only “F”, “T”, “FALSE”, or “TRUE”.</li>
<li>integer: contains only numeric characters (and <code>-</code>).</li>
<li>double: contains only valid doubles (including numbers like <code>4.5e-5</code>).</li>
<li>number: contains valid doubles with the grouping mark inside.</li>
<li>time: matches the default <code>time_format</code>.</li>
<li>date: matches the default <code>date_format</code>.</li>
<li>date-time: any ISO8601 date.</li>
</ul>
<p>If none of these rules apply, then the column will stay as a vector of strings.</p>
</div>
<div id="problems" class="section level3">
<h3><span class="header-section-number">11.4.2</span> Problems</h3>
<p>These defaults don’t always work for larger files. There are two basic problems:</p>
<ol style="list-style-type: decimal">
<li><p>The first thousand rows might be a special case, and readr guesses
a type that is not sufficiently general. For example, you might have
a column of doubles that only contains integers in the first 1000 rows.</p></li>
<li><p>The column might contain a lot of missing values. If the first 1000
rows contain only <code>NA</code>s, readr will guess that it’s a character
vector, whereas you probably want to parse it as something more
specific.</p></li>
</ol>
<p>readr contains a challenging CSV that illustrates both of these problems:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>))
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_logical()</span>
<span class="co">#&gt; )</span>
<span class="co">#&gt; Warning: 1000 parsing failures.</span>
<span class="co">#&gt;  row col           expected     actual                                                                       file</span>
<span class="co">#&gt; 1001   y 1/0/T/F/TRUE/FALSE 2015-01-16 &#39;/home/liao/R/x86_64-pc-linux-gnu-library/3.4/readr/extdata/challenge.csv&#39;</span>
<span class="co">#&gt; 1002   y 1/0/T/F/TRUE/FALSE 2018-05-18 &#39;/home/liao/R/x86_64-pc-linux-gnu-library/3.4/readr/extdata/challenge.csv&#39;</span>
<span class="co">#&gt; 1003   y 1/0/T/F/TRUE/FALSE 2015-09-05 &#39;/home/liao/R/x86_64-pc-linux-gnu-library/3.4/readr/extdata/challenge.csv&#39;</span>
<span class="co">#&gt; 1004   y 1/0/T/F/TRUE/FALSE 2012-11-28 &#39;/home/liao/R/x86_64-pc-linux-gnu-library/3.4/readr/extdata/challenge.csv&#39;</span>
<span class="co">#&gt; 1005   y 1/0/T/F/TRUE/FALSE 2020-01-13 &#39;/home/liao/R/x86_64-pc-linux-gnu-library/3.4/readr/extdata/challenge.csv&#39;</span>
<span class="co">#&gt; .... ... .................. .......... ..........................................................................</span>
<span class="co">#&gt; See problems(...) for more details.</span></code></pre>
<p>(Note the use of <code>readr_example()</code> which finds the path to one of the files included with the package)</p>
<p>There are two printed outputs: the column specification generated by looking at the first 1000 rows, and the first five parsing failures. It’s always a good idea to explicitly pull out the <code>problems()</code>, so you can explore them in more depth:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">problems</span>(challenge)
<span class="co">#&gt; # A tibble: 1,000 x 5</span>
<span class="co">#&gt;     row col   expected      actual   file                                  </span>
<span class="co">#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;         &lt;chr&gt;    &lt;chr&gt;                                 </span>
<span class="co">#&gt; 1  1001 y     1/0/T/F/TRUE… 2015-01… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; 2  1002 y     1/0/T/F/TRUE… 2018-05… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; 3  1003 y     1/0/T/F/TRUE… 2015-09… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; 4  1004 y     1/0/T/F/TRUE… 2012-11… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; 5  1005 y     1/0/T/F/TRUE… 2020-01… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; 6  1006 y     1/0/T/F/TRUE… 2016-04… &#39;/home/liao/R/x86_64-pc-linux-gnu-lib…</span>
<span class="co">#&gt; # … with 994 more rows</span></code></pre>
<p>A good strategy is to work column by column until there are no problems remaining. Here we can see that there are a lot of parsing problems with the <code>x</code> column - there are trailing characters after the integer value. That suggests we need to use a double parser instead.</p>
<p>To fix the call, start by copying and pasting the column specification into your original call:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge &lt;-<span class="st"> </span><span class="kw">read_csv</span>(
  <span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>), 
  <span class="dt">col_types =</span> <span class="kw">cols</span>(
    <span class="dt">x =</span> <span class="kw">col_integer</span>(),
    <span class="dt">y =</span> <span class="kw">col_character</span>()
  )
)</code></pre>
<p>Then you can tweak the type of the <code>x</code> column:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge &lt;-<span class="st"> </span><span class="kw">read_csv</span>(
  <span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>), 
  <span class="dt">col_types =</span> <span class="kw">cols</span>(
    <span class="dt">x =</span> <span class="kw">col_double</span>(),
    <span class="dt">y =</span> <span class="kw">col_character</span>()
  )
)</code></pre>
<p>That fixes the first problem, but if we look at the last few rows, you’ll see that they’re dates stored in a character vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(challenge)
<span class="co">#&gt; # A tibble: 6 x 2</span>
<span class="co">#&gt;       x y         </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt;     </span>
<span class="co">#&gt; 1 0.805 2019-11-21</span>
<span class="co">#&gt; 2 0.164 2018-03-29</span>
<span class="co">#&gt; 3 0.472 2014-08-04</span>
<span class="co">#&gt; 4 0.718 2015-08-16</span>
<span class="co">#&gt; 5 0.270 2020-02-04</span>
<span class="co">#&gt; 6 0.608 2019-01-06</span></code></pre>
<p>You can fix that by specifying that <code>y</code> is a date column:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge &lt;-<span class="st"> </span><span class="kw">read_csv</span>(
  <span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>), 
  <span class="dt">col_types =</span> <span class="kw">cols</span>(
    <span class="dt">x =</span> <span class="kw">col_double</span>(),
    <span class="dt">y =</span> <span class="kw">col_date</span>()
  )
)
<span class="kw">tail</span>(challenge)
<span class="co">#&gt; # A tibble: 6 x 2</span>
<span class="co">#&gt;       x y         </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class="co">#&gt; 1 0.805 2019-11-21</span>
<span class="co">#&gt; 2 0.164 2018-03-29</span>
<span class="co">#&gt; 3 0.472 2014-08-04</span>
<span class="co">#&gt; 4 0.718 2015-08-16</span>
<span class="co">#&gt; 5 0.270 2020-02-04</span>
<span class="co">#&gt; 6 0.608 2019-01-06</span></code></pre>
<p>Every <code>parse_xyz()</code> function has a corresponding <code>col_xyz()</code> function. You use <code>parse_xyz()</code> when the data is in a character vector in R already; you use <code>col_xyz()</code> when you want to tell readr how to load the data.</p>
<p>I highly recommend always supplying <code>col_types</code>, building up from the print-out provided by readr. This ensures that you have a consistent and reproducible data import script. If you rely on the default guesses and your data changes, readr will continue to read it in. If you want to be really strict, use <code>stop_for_problems()</code>: that will throw an error and stop your script if there are any parsing problems.</p>
</div>
<div id="other-strategies" class="section level3">
<h3><span class="header-section-number">11.4.3</span> Other strategies</h3>
<p>There are a few other general strategies to help you parse files:</p>
<ul>
<li><p>In the previous example, we just got unlucky: if we look at just
one more row than the default, we can correctly parse in one shot:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge2 &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>), <span class="dt">guess_max =</span> <span class="dv">1001</span>)
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_date(format = &quot;&quot;)</span>
<span class="co">#&gt; )</span>
challenge2
<span class="co">#&gt; # A tibble: 2,000 x 2</span>
<span class="co">#&gt;       x y         </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class="co">#&gt; 1   404 NA        </span>
<span class="co">#&gt; 2  4172 NA        </span>
<span class="co">#&gt; 3  3004 NA        </span>
<span class="co">#&gt; 4   787 NA        </span>
<span class="co">#&gt; 5    37 NA        </span>
<span class="co">#&gt; 6  2332 NA        </span>
<span class="co">#&gt; # … with 1,994 more rows</span></code></pre></li>
<li><p>Sometimes it’s easier to diagnose problems if you just read in all
the columns as character vectors:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge2 &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="kw">readr_example</span>(<span class="st">&quot;challenge.csv&quot;</span>), 
  <span class="dt">col_types =</span> <span class="kw">cols</span>(<span class="dt">.default =</span> <span class="kw">col_character</span>())
)</code></pre>
<p>This is particularly useful in conjunction with <code>type_convert()</code>,
which applies the parsing heuristics to the character columns in a data
frame.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x,  <span class="op">~</span>y,
  <span class="st">&quot;1&quot;</span>, <span class="st">&quot;1.21&quot;</span>,
  <span class="st">&quot;2&quot;</span>, <span class="st">&quot;2.32&quot;</span>,
  <span class="st">&quot;3&quot;</span>, <span class="st">&quot;4.56&quot;</span>
)
df
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   x     y    </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1 1     1.21 </span>
<span class="co">#&gt; 2 2     2.32 </span>
<span class="co">#&gt; 3 3     4.56</span>

<span class="co"># Note the column types</span>
<span class="kw">type_convert</span>(df)
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_double()</span>
<span class="co">#&gt; )</span>
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1  1.21</span>
<span class="co">#&gt; 2     2  2.32</span>
<span class="co">#&gt; 3     3  4.56</span></code></pre></li>
<li><p>If you’re reading a very large file, you might want to set <code>n_max</code> to
a smallish number like 10,000 or 100,000. That will accelerate your
iterations while you eliminate common problems.</p></li>
<li><p>If you’re having major parsing problems, sometimes it’s easier
to just read into a character vector of lines with <code>read_lines()</code>,
or even a character vector of length 1 with <code>read_file()</code>. Then you
can use the string parsing skills you’ll learn later to parse
more exotic formats.</p></li>
</ul>
</div>
</div>
<div id="writing-to-a-file" class="section level2">
<h2><span class="header-section-number">11.5</span> Writing to a file</h2>
<p>readr also comes with two useful functions for writing data back to disk: <code>write_csv()</code> and <code>write_tsv()</code>. Both functions increase the chances of the output file being read back in correctly by:</p>
<ul>
<li><p>Always encoding strings in UTF-8.</p></li>
<li><p>Saving dates and date-times in ISO8601 format so they are easily
parsed elsewhere.</p></li>
</ul>
<p>If you want to export a csv file to Excel, use <code>write_excel_csv()</code> — this writes a special character (a “byte order mark”) at the start of the file which tells Excel that you’re using the UTF-8 encoding.</p>
<p>The most important arguments are <code>x</code> (the data frame to save), and <code>path</code> (the location to save it). You can also specify how missing values are written with <code>na</code>, and if you want to <code>append</code> to an existing file.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(challenge, <span class="st">&quot;challenge.csv&quot;</span>)</code></pre>
<p>Note that the type information is lost when you save to csv:</p>
<pre class="sourceCode r"><code class="sourceCode r">challenge
<span class="co">#&gt; # A tibble: 2,000 x 2</span>
<span class="co">#&gt;       x y         </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class="co">#&gt; 1   404 NA        </span>
<span class="co">#&gt; 2  4172 NA        </span>
<span class="co">#&gt; 3  3004 NA        </span>
<span class="co">#&gt; 4   787 NA        </span>
<span class="co">#&gt; 5    37 NA        </span>
<span class="co">#&gt; 6  2332 NA        </span>
<span class="co">#&gt; # … with 1,994 more rows</span>
<span class="kw">write_csv</span>(challenge, <span class="st">&quot;challenge-2.csv&quot;</span>)
<span class="kw">read_csv</span>(<span class="st">&quot;challenge-2.csv&quot;</span>)
<span class="co">#&gt; Parsed with column specification:</span>
<span class="co">#&gt; cols(</span>
<span class="co">#&gt;   x = col_double(),</span>
<span class="co">#&gt;   y = col_logical()</span>
<span class="co">#&gt; )</span>
<span class="co">#&gt; # A tibble: 2,000 x 2</span>
<span class="co">#&gt;       x y    </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;lgl&gt;</span>
<span class="co">#&gt; 1   404 NA   </span>
<span class="co">#&gt; 2  4172 NA   </span>
<span class="co">#&gt; 3  3004 NA   </span>
<span class="co">#&gt; 4   787 NA   </span>
<span class="co">#&gt; 5    37 NA   </span>
<span class="co">#&gt; 6  2332 NA   </span>
<span class="co">#&gt; # … with 1,994 more rows</span></code></pre>
<p>This makes CSVs a little unreliable for caching interim results—you need to recreate the column specification every time you load in. There are two alternatives:</p>
<ol style="list-style-type: decimal">
<li><p><code>write_rds()</code> and <code>read_rds()</code> are uniform wrappers around the base
functions <code>readRDS()</code> and <code>saveRDS()</code>. These store data in R’s custom
binary format called RDS:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_rds</span>(challenge, <span class="st">&quot;challenge.rds&quot;</span>)
<span class="kw">read_rds</span>(<span class="st">&quot;challenge.rds&quot;</span>)
<span class="co">#&gt; # A tibble: 2,000 x 2</span>
<span class="co">#&gt;       x y         </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class="co">#&gt; 1   404 NA        </span>
<span class="co">#&gt; 2  4172 NA        </span>
<span class="co">#&gt; 3  3004 NA        </span>
<span class="co">#&gt; 4   787 NA        </span>
<span class="co">#&gt; 5    37 NA        </span>
<span class="co">#&gt; 6  2332 NA        </span>
<span class="co">#&gt; # … with 1,994 more rows</span></code></pre></li>
<li><p>The feather package implements a fast binary file format that can
be shared across programming languages:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(feather)
<span class="kw">write_feather</span>(challenge, <span class="st">&quot;challenge.feather&quot;</span>)
<span class="kw">read_feather</span>(<span class="st">&quot;challenge.feather&quot;</span>)
<span class="co">#&gt; # A tibble: 2,000 x 2</span>
<span class="co">#&gt;       x      y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;date&gt;</span>
<span class="co">#&gt; 1   404   &lt;NA&gt;</span>
<span class="co">#&gt; 2  4172   &lt;NA&gt;</span>
<span class="co">#&gt; 3  3004   &lt;NA&gt;</span>
<span class="co">#&gt; 4   787   &lt;NA&gt;</span>
<span class="co">#&gt; 5    37   &lt;NA&gt;</span>
<span class="co">#&gt; 6  2332   &lt;NA&gt;</span>
<span class="co">#&gt; # ... with 1,994 more rows</span></code></pre></li>
</ol>
<p>Feather tends to be faster than RDS and is usable outside of R. RDS supports list-columns (which you’ll learn about in <a href="#many-models">many models</a>); feather currently does not.</p>
</div>
<div id="other-types-of-data" class="section level2">
<h2><span class="header-section-number">11.6</span> Other types of data</h2>
<p>To get other types of data into R, we recommend starting with the tidyverse packages listed below. They’re certainly not perfect, but they are a good place to start. For rectangular data:</p>
<ul>
<li><p><strong>haven</strong> reads SPSS, Stata, and SAS files.</p></li>
<li><p><strong>readxl</strong> reads excel files (both <code>.xls</code> and <code>.xlsx</code>).</p></li>
<li><p><strong>DBI</strong>, along with a database specific backend (e.g. <strong>RMySQL</strong>,
<strong>RSQLite</strong>, <strong>RPostgreSQL</strong> etc) allows you to run SQL queries against a
database and return a data frame.</p></li>
</ul>
<p>For hierarchical data: use <strong>jsonlite</strong> (by Jeroen Ooms) for json, and <strong>xml2</strong> for XML. Jenny Bryan has some excellent worked examples at <a href="https://jennybc.github.io/purrr-tutorial/" class="uri">https://jennybc.github.io/purrr-tutorial/</a>.</p>
<p>For other file types, try the R data import/export manual<span id="fn12" class="footnote" data-pagedown-footnote-number="12" style="white-space: pre-line;"><a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html" class="uri">https://cran.r-project.org/doc/manuals/r-release/R-data.html</a></span> and the <strong>rio</strong><span id="fn13" class="footnote" data-pagedown-footnote-number="13" style="white-space: pre-line;"><a href="https://github.com/leeper/rio" class="uri">https://github.com/leeper/rio</a></span> package.</p>
<!--chapter:end:import.Rmd-->
</div>
</div>
<div id="tidy-data" class="section level1">
<h1><span class="header-section-number">12</span> Tidy data</h1>
<div id="introduction-6" class="section level2">
<h2><span class="header-section-number">12.1</span> Introduction</h2>
<blockquote>
<p>“Happy families are all alike; every unhappy family is unhappy in its
own way.” –– Leo Tolstoy</p>
</blockquote>
<blockquote>
<p>“Tidy datasets are all alike, but every messy dataset is messy in its
own way.” –– Hadley Wickham</p>
</blockquote>
<p>In this chapter, you will learn a consistent way to organise your data in R, an organisation called <strong>tidy data</strong>. Getting your data into this format requires some upfront work, but that work pays off in the long term. Once you have tidy data and the tidy tools provided by packages in the tidyverse, you will spend much less time munging data from one representation to another, allowing you to spend more time on the analytic questions at hand.</p>
<p>This chapter will give you a practical introduction to tidy data and the accompanying tools in the <strong>tidyr</strong> package. If you’d like to learn more about the underlying theory, you might enjoy the <em>Tidy Data</em> paper published in the Journal of Statistical Software, <a href="http://www.jstatsoft.org/v59/i10/paper" class="uri">http://www.jstatsoft.org/v59/i10/paper</a>.</p>
<div id="prerequisites-6" class="section level3">
<h3><span class="header-section-number">12.1.1</span> Prerequisites</h3>
<p>In this chapter we’ll focus on tidyr, a package that provides a bunch of tools to help tidy up your messy datasets. tidyr is a member of the core tidyverse.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="tidy-data-1" class="section level2">
<h2><span class="header-section-number">12.2</span> Tidy data</h2>
<p>You can represent the same underlying data in multiple ways. The example below shows the same data organised in four different ways. Each dataset shows the same values of four variables <em>country</em>, <em>year</em>, <em>population</em>, and <em>cases</em>, but each dataset organises the values in a different way.</p>
<pre class="sourceCode r"><code class="sourceCode r">table1
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country      year  cases population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999    745   19987071</span>
<span class="co">#&gt; 2 Afghanistan  2000   2666   20595360</span>
<span class="co">#&gt; 3 Brazil       1999  37737  172006362</span>
<span class="co">#&gt; 4 Brazil       2000  80488  174504898</span>
<span class="co">#&gt; 5 China        1999 212258 1272915272</span>
<span class="co">#&gt; 6 China        2000 213766 1280428583</span>
table2
<span class="co">#&gt; # A tibble: 12 x 4</span>
<span class="co">#&gt;   country      year type           count</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999 cases            745</span>
<span class="co">#&gt; 2 Afghanistan  1999 population  19987071</span>
<span class="co">#&gt; 3 Afghanistan  2000 cases           2666</span>
<span class="co">#&gt; 4 Afghanistan  2000 population  20595360</span>
<span class="co">#&gt; 5 Brazil       1999 cases          37737</span>
<span class="co">#&gt; 6 Brazil       1999 population 172006362</span>
<span class="co">#&gt; # … with 6 more rows</span>
table3
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country      year rate             </span>
<span class="co">#&gt; * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            </span>
<span class="co">#&gt; 1 Afghanistan  1999 745/19987071     </span>
<span class="co">#&gt; 2 Afghanistan  2000 2666/20595360    </span>
<span class="co">#&gt; 3 Brazil       1999 37737/172006362  </span>
<span class="co">#&gt; 4 Brazil       2000 80488/174504898  </span>
<span class="co">#&gt; 5 China        1999 212258/1272915272</span>
<span class="co">#&gt; 6 China        2000 213766/1280428583</span>

<span class="co"># Spread across two tibbles</span>
table4a  <span class="co"># cases</span>
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   country     `1999` `2000`</span>
<span class="co">#&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan    745   2666</span>
<span class="co">#&gt; 2 Brazil       37737  80488</span>
<span class="co">#&gt; 3 China       212258 213766</span>
table4b  <span class="co"># population</span>
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   country         `1999`     `2000`</span>
<span class="co">#&gt; * &lt;chr&gt;            &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan   19987071   20595360</span>
<span class="co">#&gt; 2 Brazil       172006362  174504898</span>
<span class="co">#&gt; 3 China       1272915272 1280428583</span></code></pre>
<p>These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with inside the tidyverse.</p>
<p>There are three interrelated rules which make a dataset tidy:</p>
<ol style="list-style-type: decimal">
<li>Each variable must have its own column.</li>
<li>Each observation must have its own row.</li>
<li>Each value must have its own cell.</li>
</ol>
<p>Figure <a href="#fig:tidy-structure">12.1</a> shows the rules visually.</p>
<div class="figure" style="text-align: center"><span id="fig:tidy-structure"></span>
<img src="images/tidy-1.png" alt="Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells." width="100%" />
<p class="caption">
Figure 12.1: Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells.
</p>
</div>
<p>These three rules are interrelated because it’s impossible to only satisfy two of the three. That interrelationship leads to an even simpler set of practical instructions:</p>
<ol style="list-style-type: decimal">
<li>Put each dataset in a tibble.</li>
<li>Put each variable in a column.</li>
</ol>
<p>In this example, only <code>table1</code> is tidy. It’s the only representation where each column is a variable.</p>
<p>Why ensure that your data is tidy? There are two main advantages:</p>
<ol style="list-style-type: decimal">
<li><p>There’s a general advantage to picking one consistent way of storing
data. If you have a consistent data structure, it’s easier to learn the
tools that work with it because they have an underlying uniformity.</p></li>
<li><p>There’s a specific advantage to placing variables in columns because
it allows R’s vectorised nature to shine. As you learned in
<a href="#mutate-funs">mutate</a> and <a href="#summary-funs">summary functions</a>, most
built-in R functions work with vectors of values. That makes transforming
tidy data feel particularly natural.</p></li>
</ol>
<p>dplyr, ggplot2, and all the other packages in the tidyverse are designed to work with tidy data. Here are a couple of small examples showing how you might work with <code>table1</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Compute rate per 10,000</span>
table1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">rate =</span> cases <span class="op">/</span><span class="st"> </span>population <span class="op">*</span><span class="st"> </span><span class="dv">10000</span>)
<span class="co">#&gt; # A tibble: 6 x 5</span>
<span class="co">#&gt;   country      year  cases population  rate</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999    745   19987071 0.373</span>
<span class="co">#&gt; 2 Afghanistan  2000   2666   20595360 1.29 </span>
<span class="co">#&gt; 3 Brazil       1999  37737  172006362 2.19 </span>
<span class="co">#&gt; 4 Brazil       2000  80488  174504898 4.61 </span>
<span class="co">#&gt; 5 China        1999 212258 1272915272 1.67 </span>
<span class="co">#&gt; 6 China        2000 213766 1280428583 1.67</span>

<span class="co"># Compute cases per year</span>
table1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(year, <span class="dt">wt =</span> cases)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;    year      n</span>
<span class="co">#&gt;   &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1  1999 250740</span>
<span class="co">#&gt; 2  2000 296920</span>

<span class="co"># Visualise changes over time</span>
<span class="kw">library</span>(ggplot2)
<span class="kw">ggplot</span>(table1, <span class="kw">aes</span>(year, cases)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country), <span class="dt">colour =</span> <span class="st">&quot;grey50&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> country))</code></pre>
<p><img src="tidy_files/figure-html/unnamed-chunk-3-1.png" width="50%" style="display: block; margin: auto;" /></p>
<div id="exercises-21" class="section level3">
<h3><span class="header-section-number">12.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Using prose, describe how the variables and observations are organised in
each of the sample tables.</p></li>
<li><p>Compute the <code>rate</code> for <code>table2</code>, and <code>table4a</code> + <code>table4b</code>.
You will need to perform four operations:</p>
<ol style="list-style-type: decimal">
<li>Extract the number of TB cases per country per year.</li>
<li>Extract the matching population per country per year.</li>
<li>Divide cases by population, and multiply by 10000.</li>
<li>Store back in the appropriate place.</li>
</ol>
<p>Which representation is easiest to work with? Which is hardest? Why?</p></li>
<li><p>Recreate the plot showing change in cases over time using <code>table2</code>
instead of <code>table1</code>. What do you need to do first?</p></li>
</ol>
</div>
</div>
<div id="spreading-and-gathering" class="section level2">
<h2><span class="header-section-number">12.3</span> Spreading and gathering</h2>
<p>The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. Unfortunately, however, most data that you will encounter will be untidy. There are two main reasons:</p>
<ol style="list-style-type: decimal">
<li><p>Most people aren’t familiar with the principles of tidy data, and it’s hard
to derive them yourself unless you spend a <em>lot</em> of time working with data.</p></li>
<li><p>Data is often organised to facilitate some use other than analysis. For
example, data is often organised to make entry as easy as possible.</p></li>
</ol>
<p>This means for most real analyses, you’ll need to do some tidying. The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data.
The second step is to resolve one of two common problems:</p>
<ol style="list-style-type: decimal">
<li><p>One variable might be spread across multiple columns.</p></li>
<li><p>One observation might be scattered across multiple rows.</p></li>
</ol>
<p>Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: <code>gather()</code> and <code>spread()</code>.</p>
<div id="gathering" class="section level3">
<h3><span class="header-section-number">12.3.1</span> Gathering</h3>
<p>A common problem is a dataset where some of the column names are not names of variables, but <em>values</em> of a variable. Take <code>table4a</code>: the column names <code>1999</code> and <code>2000</code> represent values of the <code>year</code> variable, and each row represents two observations, not one.</p>
<pre class="sourceCode r"><code class="sourceCode r">table4a
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   country     `1999` `2000`</span>
<span class="co">#&gt; * &lt;chr&gt;        &lt;int&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan    745   2666</span>
<span class="co">#&gt; 2 Brazil       37737  80488</span>
<span class="co">#&gt; 3 China       212258 213766</span></code></pre>
<p>To tidy a dataset like this, we need to <strong>gather</strong> those columns into a new pair of variables. To describe that operation we need three parameters:</p>
<ul>
<li><p>The set of columns that represent values, not variables. In this example,
those are the columns <code>1999</code> and <code>2000</code>.</p></li>
<li><p>The name of the variable whose values form the column names. I call that
the <code>key</code>, and here it is <code>year</code>.</p></li>
<li><p>The name of the variable whose values are spread over the cells. I call
that <code>value</code>, and here it’s the number of <code>cases</code>.</p></li>
</ul>
<p>Together those parameters generate the call to <code>gather()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country     year   cases</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan 1999     745</span>
<span class="co">#&gt; 2 Brazil      1999   37737</span>
<span class="co">#&gt; 3 China       1999  212258</span>
<span class="co">#&gt; 4 Afghanistan 2000    2666</span>
<span class="co">#&gt; 5 Brazil      2000   80488</span>
<span class="co">#&gt; 6 China       2000  213766</span></code></pre>
<p>The columns to gather are specified with <code>dplyr::select()</code> style notation. Here there are only two columns, so we list them individually. Note that “1999” and “2000” are non-syntactic names (because they don’t start with a letter) so we have to surround them in backticks. To refresh your memory of the other ways to select columns, see <a href="#select">select</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:tidy-gather"></span>
<img src="images/tidy-9.png" alt="Gathering `table4` into a tidy form." width="100%" />
<p class="caption">
Figure 12.2: Gathering <code>table4</code> into a tidy form.
</p>
</div>
<p>In the final result, the gathered columns are dropped, and we get new <code>key</code> and <code>value</code> columns. Otherwise, the relationships between the original variables are preserved. Visually, this is shown in Figure <a href="#fig:tidy-gather">12.2</a>. We can use <code>gather()</code> to tidy <code>table4b</code> in a similar fashion. The only difference is the variable stored in the cell values:</p>
<pre class="sourceCode r"><code class="sourceCode r">table4b <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;population&quot;</span>)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country     year  population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan 1999    19987071</span>
<span class="co">#&gt; 2 Brazil      1999   172006362</span>
<span class="co">#&gt; 3 China       1999  1272915272</span>
<span class="co">#&gt; 4 Afghanistan 2000    20595360</span>
<span class="co">#&gt; 5 Brazil      2000   174504898</span>
<span class="co">#&gt; 6 China       2000  1280428583</span></code></pre>
<p>To combine the tidied versions of <code>table4a</code> and <code>table4b</code> into a single tibble, we need to use <code>dplyr::left_join()</code>, which you’ll learn about in <a href="#relational-data">relational data</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">tidy4a &lt;-<span class="st"> </span>table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)
tidy4b &lt;-<span class="st"> </span>table4b <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">`</span><span class="dt">1999</span><span class="st">`</span>, <span class="st">`</span><span class="dt">2000</span><span class="st">`</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;population&quot;</span>)
<span class="kw">left_join</span>(tidy4a, tidy4b)
<span class="co">#&gt; Joining, by = c(&quot;country&quot;, &quot;year&quot;)</span>
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country     year   cases population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;  &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan 1999     745   19987071</span>
<span class="co">#&gt; 2 Brazil      1999   37737  172006362</span>
<span class="co">#&gt; 3 China       1999  212258 1272915272</span>
<span class="co">#&gt; 4 Afghanistan 2000    2666   20595360</span>
<span class="co">#&gt; 5 Brazil      2000   80488  174504898</span>
<span class="co">#&gt; 6 China       2000  213766 1280428583</span></code></pre>
</div>
<div id="spreading" class="section level3">
<h3><span class="header-section-number">12.3.2</span> Spreading</h3>
<p>Spreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. For example, take <code>table2</code>: an observation is a country in a year, but each observation is spread across two rows.</p>
<pre class="sourceCode r"><code class="sourceCode r">table2
<span class="co">#&gt; # A tibble: 12 x 4</span>
<span class="co">#&gt;   country      year type           count</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;          &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999 cases            745</span>
<span class="co">#&gt; 2 Afghanistan  1999 population  19987071</span>
<span class="co">#&gt; 3 Afghanistan  2000 cases           2666</span>
<span class="co">#&gt; 4 Afghanistan  2000 population  20595360</span>
<span class="co">#&gt; 5 Brazil       1999 cases          37737</span>
<span class="co">#&gt; 6 Brazil       1999 population 172006362</span>
<span class="co">#&gt; # … with 6 more rows</span></code></pre>
<p>To tidy this up, we first analyse the representation in similar way to <code>gather()</code>. This time, however, we only need two parameters:</p>
<ul>
<li><p>The column that contains variable names, the <code>key</code> column. Here, it’s
<code>type</code>.</p></li>
<li><p>The column that contains values from multiple variables, the <code>value</code>
column. Here it’s <code>count</code>.</p></li>
</ul>
<p>Once we’ve figured that out, we can use <code>spread()</code>, as shown programmatically below, and visually in Figure <a href="#fig:tidy-spread">12.3</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">table2 <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">spread</span>(<span class="dt">key =</span> type, <span class="dt">value =</span> count)
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country      year  cases population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999    745   19987071</span>
<span class="co">#&gt; 2 Afghanistan  2000   2666   20595360</span>
<span class="co">#&gt; 3 Brazil       1999  37737  172006362</span>
<span class="co">#&gt; 4 Brazil       2000  80488  174504898</span>
<span class="co">#&gt; 5 China        1999 212258 1272915272</span>
<span class="co">#&gt; 6 China        2000 213766 1280428583</span></code></pre>
<div class="figure" style="text-align: center"><span id="fig:tidy-spread"></span>
<img src="images/tidy-8.png" alt="Spreading `table2` makes it tidy" width="100%" />
<p class="caption">
Figure 12.3: Spreading <code>table2</code> makes it tidy
</p>
</div>
<p>As you might have guessed from the common <code>key</code> and <code>value</code> arguments, <code>spread()</code> and <code>gather()</code> are complements. <code>gather()</code> makes wide tables narrower and longer; <code>spread()</code> makes long tables shorter and wider.</p>
</div>
<div id="exercises-22" class="section level3">
<h3><span class="header-section-number">12.3.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why are <code>gather()</code> and <code>spread()</code> not perfectly symmetrical?<br />
Carefully consider the following example:</p>
<pre class="sourceCode r"><code class="sourceCode r">stocks &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">year   =</span> <span class="kw">c</span>(<span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2016</span>, <span class="dv">2016</span>),
  <span class="dt">half  =</span> <span class="kw">c</span>(   <span class="dv">1</span>,    <span class="dv">2</span>,     <span class="dv">1</span>,    <span class="dv">2</span>),
  <span class="dt">return =</span> <span class="kw">c</span>(<span class="fl">1.88</span>, <span class="fl">0.59</span>, <span class="fl">0.92</span>, <span class="fl">0.17</span>)
)
stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="st">&quot;year&quot;</span>, <span class="st">&quot;return&quot;</span>, <span class="st">`</span><span class="dt">2015</span><span class="st">`</span><span class="op">:</span><span class="st">`</span><span class="dt">2016</span><span class="st">`</span>)</code></pre>
<p>(Hint: look at the variable types and think about column <em>names</em>.)</p>
<p>Both <code>spread()</code> and <code>gather()</code> have a <code>convert</code> argument. What does it
do?</p></li>
<li><p>Why does this code fail?</p>
<pre class="sourceCode r"><code class="sourceCode r">table4a <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(<span class="dv">1999</span>, <span class="dv">2000</span>, <span class="dt">key =</span> <span class="st">&quot;year&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>)
<span class="co">#&gt; Error in inds_combine(.vars, ind_list): Position must be between 0 and n</span></code></pre></li>
<li><p>Why does spreading this tibble fail? How could you add a new column to fix
the problem?</p>
<pre class="sourceCode r"><code class="sourceCode r">people &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>name,             <span class="op">~</span>key,    <span class="op">~</span>value,
  <span class="co">#-----------------|--------|------</span>
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;age&quot;</span>,       <span class="dv">45</span>,
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;height&quot;</span>,   <span class="dv">186</span>,
  <span class="st">&quot;Phillip Woods&quot;</span>,   <span class="st">&quot;age&quot;</span>,       <span class="dv">50</span>,
  <span class="st">&quot;Jessica Cordero&quot;</span>, <span class="st">&quot;age&quot;</span>,       <span class="dv">37</span>,
  <span class="st">&quot;Jessica Cordero&quot;</span>, <span class="st">&quot;height&quot;</span>,   <span class="dv">156</span>
)</code></pre></li>
<li><p>Tidy the simple tibble below. Do you need to spread or gather it?
What are the variables?</p>
<pre class="sourceCode r"><code class="sourceCode r">preg &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>pregnant, <span class="op">~</span>male, <span class="op">~</span>female,
  <span class="st">&quot;yes&quot;</span>,     <span class="ot">NA</span>,    <span class="dv">10</span>,
  <span class="st">&quot;no&quot;</span>,      <span class="dv">20</span>,    <span class="dv">12</span>
)</code></pre></li>
</ol>
</div>
</div>
<div id="separating-and-uniting" class="section level2">
<h2><span class="header-section-number">12.4</span> Separating and uniting</h2>
<p>So far you’ve learned how to tidy <code>table2</code> and <code>table4</code>, but not <code>table3</code>. <code>table3</code> has a different problem: we have one column (<code>rate</code>) that contains two variables (<code>cases</code> and <code>population</code>). To fix this problem, we’ll need the <code>separate()</code> function. You’ll also learn about the complement of <code>separate()</code>: <code>unite()</code>, which you use if a single variable is spread across multiple columns.</p>
<div id="separate" class="section level3">
<h3><span class="header-section-number">12.4.1</span> Separate</h3>
<p><code>separate()</code> pulls apart one column into multiple columns, by splitting wherever a separator character appears. Take <code>table3</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">table3
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country      year rate             </span>
<span class="co">#&gt; * &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;            </span>
<span class="co">#&gt; 1 Afghanistan  1999 745/19987071     </span>
<span class="co">#&gt; 2 Afghanistan  2000 2666/20595360    </span>
<span class="co">#&gt; 3 Brazil       1999 37737/172006362  </span>
<span class="co">#&gt; 4 Brazil       2000 80488/174504898  </span>
<span class="co">#&gt; 5 China        1999 212258/1272915272</span>
<span class="co">#&gt; 6 China        2000 213766/1280428583</span></code></pre>
<p>The <code>rate</code> column contains both <code>cases</code> and <code>population</code> variables, and we need to split it into two variables. <code>separate()</code> takes the name of the column to separate, and the names of the columns to separate into, as shown in Figure <a href="#fig:tidy-separate">12.4</a> and the code below.</p>
<pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>))
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country      year cases  population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;     </span>
<span class="co">#&gt; 1 Afghanistan  1999 745    19987071  </span>
<span class="co">#&gt; 2 Afghanistan  2000 2666   20595360  </span>
<span class="co">#&gt; 3 Brazil       1999 37737  172006362 </span>
<span class="co">#&gt; 4 Brazil       2000 80488  174504898 </span>
<span class="co">#&gt; 5 China        1999 212258 1272915272</span>
<span class="co">#&gt; 6 China        2000 213766 1280428583</span></code></pre>
<div class="figure" style="text-align: center"><span id="fig:tidy-separate"></span>
<img src="images/tidy-17.png" alt="Separating `table3` makes it tidy" width="75%" />
<p class="caption">
Figure 12.4: Separating <code>table3</code> makes it tidy
</p>
</div>
<p>By default, <code>separate()</code> will split values wherever it sees a non-alphanumeric character (i.e. a character that isn’t a number or letter). For example, in the code above, <code>separate()</code> split the values of <code>rate</code> at the forward slash characters. If you wish to use a specific character to separate a column, you can pass the character to the <code>sep</code> argument of <code>separate()</code>. For example, we could rewrite the code above as:</p>
<pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;/&quot;</span>)</code></pre>
<p>(Formally, <code>sep</code> is a regular expression, which you’ll learn more about in <a href="#strings">strings</a>.)</p>
<p>Look carefully at the column types: you’ll notice that <code>cases</code> and <code>population</code> are character columns. This is the default behaviour in <code>separate()</code>: it leaves the type of the column as is. Here, however, it’s not very useful as those really are numbers. We can ask <code>separate()</code> to try and convert to better types using <code>convert = TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(rate, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;cases&quot;</span>, <span class="st">&quot;population&quot;</span>), <span class="dt">convert =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country      year  cases population</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt;  &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1999    745   19987071</span>
<span class="co">#&gt; 2 Afghanistan  2000   2666   20595360</span>
<span class="co">#&gt; 3 Brazil       1999  37737  172006362</span>
<span class="co">#&gt; 4 Brazil       2000  80488  174504898</span>
<span class="co">#&gt; 5 China        1999 212258 1272915272</span>
<span class="co">#&gt; 6 China        2000 213766 1280428583</span></code></pre>
<p>You can also pass a vector of integers to <code>sep</code>. <code>separate()</code> will interpret the integers as positions to split at. Positive values start at 1 on the far-left of the strings; negative value start at -1 on the far-right of the strings. When using integers to separate strings, the length of <code>sep</code> should be one less than the number of names in <code>into</code>.</p>
<p>You can use this arrangement to separate the last two digits of each year. This make this data less tidy, but is useful in other cases, as you’ll see in a little bit.</p>
<pre class="sourceCode r"><code class="sourceCode r">table3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(year, <span class="dt">into =</span> <span class="kw">c</span>(<span class="st">&quot;century&quot;</span>, <span class="st">&quot;year&quot;</span>), <span class="dt">sep =</span> <span class="dv">2</span>)
<span class="co">#&gt; # A tibble: 6 x 4</span>
<span class="co">#&gt;   country     century year  rate             </span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;            </span>
<span class="co">#&gt; 1 Afghanistan 19      99    745/19987071     </span>
<span class="co">#&gt; 2 Afghanistan 20      00    2666/20595360    </span>
<span class="co">#&gt; 3 Brazil      19      99    37737/172006362  </span>
<span class="co">#&gt; 4 Brazil      20      00    80488/174504898  </span>
<span class="co">#&gt; 5 China       19      99    212258/1272915272</span>
<span class="co">#&gt; 6 China       20      00    213766/1280428583</span></code></pre>
</div>
<div id="unite" class="section level3">
<h3><span class="header-section-number">12.4.2</span> Unite</h3>
<p><code>unite()</code> is the inverse of <code>separate()</code>: it combines multiple columns into a single column. You’ll need it much less frequently than <code>separate()</code>, but it’s still a useful tool to have in your back pocket.</p>
<div class="figure" style="text-align: center"><span id="fig:tidy-unite"></span>
<img src="images/tidy-18.png" alt="Uniting `table5` makes it tidy" width="75%" />
<p class="caption">
Figure 12.5: Uniting <code>table5</code> makes it tidy
</p>
</div>
<p>We can use <code>unite()</code> to rejoin the <em>century</em> and <em>year</em> columns that we created in the last example. That data is saved as <code>tidyr::table5</code>. <code>unite()</code> takes a data frame, the name of the new variable to create, and a set of columns to combine, again specified in <code>dplyr::select()</code> style:</p>
<pre class="sourceCode r"><code class="sourceCode r">table5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(new, century, year)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country     new   rate             </span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            </span>
<span class="co">#&gt; 1 Afghanistan 19_99 745/19987071     </span>
<span class="co">#&gt; 2 Afghanistan 20_00 2666/20595360    </span>
<span class="co">#&gt; 3 Brazil      19_99 37737/172006362  </span>
<span class="co">#&gt; 4 Brazil      20_00 80488/174504898  </span>
<span class="co">#&gt; 5 China       19_99 212258/1272915272</span>
<span class="co">#&gt; 6 China       20_00 213766/1280428583</span></code></pre>
<p>In this case we also need to use the <code>sep</code> argument. The default will place an underscore (<code>_</code>) between the values from different columns. Here we don’t want any separator so we use <code>&quot;&quot;</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">table5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unite</span>(new, century, year, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;   country     new   rate             </span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;            </span>
<span class="co">#&gt; 1 Afghanistan 1999  745/19987071     </span>
<span class="co">#&gt; 2 Afghanistan 2000  2666/20595360    </span>
<span class="co">#&gt; 3 Brazil      1999  37737/172006362  </span>
<span class="co">#&gt; 4 Brazil      2000  80488/174504898  </span>
<span class="co">#&gt; 5 China       1999  212258/1272915272</span>
<span class="co">#&gt; 6 China       2000  213766/1280428583</span></code></pre>
</div>
<div id="exercises-23" class="section level3">
<h3><span class="header-section-number">12.4.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What do the <code>extra</code> and <code>fill</code> arguments do in <code>separate()</code>?
Experiment with the various options for the following two toy datasets.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;a,b,c&quot;</span>, <span class="st">&quot;d,e,f,g&quot;</span>, <span class="st">&quot;h,i,j&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(x, <span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>))

<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="kw">c</span>(<span class="st">&quot;a,b,c&quot;</span>, <span class="st">&quot;d,e&quot;</span>, <span class="st">&quot;f,g,i&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(x, <span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>))</code></pre></li>
<li><p>Both <code>unite()</code> and <code>separate()</code> have a <code>remove</code> argument. What does it
do? Why would you set it to <code>FALSE</code>?</p></li>
<li><p>Compare and contrast <code>separate()</code> and <code>extract()</code>. Why are there
three variations of separation (by position, by separator, and with
groups), but only one unite?</p></li>
</ol>
</div>
</div>
<div id="missing-values-3" class="section level2">
<h2><span class="header-section-number">12.5</span> Missing values</h2>
<p>Changing the representation of a dataset brings up an important subtlety of missing values. Surprisingly, a value can be missing in one of two possible ways:</p>
<ul>
<li><strong>Explicitly</strong>, i.e. flagged with <code>NA</code>.</li>
<li><strong>Implicitly</strong>, i.e. simply not present in the data.</li>
</ul>
<p>Let’s illustrate this idea with a very simple data set:</p>
<pre class="sourceCode r"><code class="sourceCode r">stocks &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">year   =</span> <span class="kw">c</span>(<span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2015</span>, <span class="dv">2016</span>, <span class="dv">2016</span>, <span class="dv">2016</span>),
  <span class="dt">qtr    =</span> <span class="kw">c</span>(   <span class="dv">1</span>,    <span class="dv">2</span>,    <span class="dv">3</span>,    <span class="dv">4</span>,    <span class="dv">2</span>,    <span class="dv">3</span>,    <span class="dv">4</span>),
  <span class="dt">return =</span> <span class="kw">c</span>(<span class="fl">1.88</span>, <span class="fl">0.59</span>, <span class="fl">0.35</span>,   <span class="ot">NA</span>, <span class="fl">0.92</span>, <span class="fl">0.17</span>, <span class="fl">2.66</span>)
)</code></pre>
<p>There are two missing values in this dataset:</p>
<ul>
<li><p>The return for the fourth quarter of 2015 is explicitly missing, because
the cell where its value should be instead contains <code>NA</code>.</p></li>
<li><p>The return for the first quarter of 2016 is implicitly missing, because it
simply does not appear in the dataset.</p></li>
</ul>
<p>One way to think about the difference is with this Zen-like koan: An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence.</p>
<p>The way that a dataset is represented can make implicit values explicit. For example, we can make the implicit missing value explicit by putting years in the columns:</p>
<pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return)
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt;     qtr `2015` `2016`</span>
<span class="co">#&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1   1.88  NA   </span>
<span class="co">#&gt; 2     2   0.59   0.92</span>
<span class="co">#&gt; 3     3   0.35   0.17</span>
<span class="co">#&gt; 4     4  NA      2.66</span></code></pre>
<p>Because these explicit missing values may not be important in other representations of the data, you can set <code>na.rm = TRUE</code> in <code>gather()</code> to turn explicit missing values implicit:</p>
<pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(year, return) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(year, return, <span class="st">`</span><span class="dt">2015</span><span class="st">`</span><span class="op">:</span><span class="st">`</span><span class="dt">2016</span><span class="st">`</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;     qtr year  return</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1 2015    1.88</span>
<span class="co">#&gt; 2     2 2015    0.59</span>
<span class="co">#&gt; 3     3 2015    0.35</span>
<span class="co">#&gt; 4     2 2016    0.92</span>
<span class="co">#&gt; 5     3 2016    0.17</span>
<span class="co">#&gt; 6     4 2016    2.66</span></code></pre>
<p>Another important tool for making missing values explicit in tidy data is <code>complete()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">stocks <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">complete</span>(year, qtr)
<span class="co">#&gt; # A tibble: 8 x 3</span>
<span class="co">#&gt;    year   qtr return</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2015     1   1.88</span>
<span class="co">#&gt; 2  2015     2   0.59</span>
<span class="co">#&gt; 3  2015     3   0.35</span>
<span class="co">#&gt; 4  2015     4  NA   </span>
<span class="co">#&gt; 5  2016     1  NA   </span>
<span class="co">#&gt; 6  2016     2   0.92</span>
<span class="co">#&gt; # … with 2 more rows</span></code></pre>
<p><code>complete()</code> takes a set of columns, and finds all unique combinations. It then ensures the original dataset contains all those values, filling in explicit <code>NA</code>s where necessary.</p>
<p>There’s one other important tool that you should know for working with missing values. Sometimes when a data source has primarily been used for data entry, missing values indicate that the previous value should be carried forward:</p>
<pre class="sourceCode r"><code class="sourceCode r">treatment &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span><span class="st"> </span>person,           <span class="op">~</span><span class="st"> </span>treatment, <span class="op">~</span>response,
  <span class="st">&quot;Derrick Whitmore&quot;</span>, <span class="dv">1</span>,           <span class="dv">7</span>,
  <span class="ot">NA</span>,                 <span class="dv">2</span>,           <span class="dv">10</span>,
  <span class="ot">NA</span>,                 <span class="dv">3</span>,           <span class="dv">9</span>,
  <span class="st">&quot;Katherine Burke&quot;</span>,  <span class="dv">1</span>,           <span class="dv">4</span>
)</code></pre>
<p>You can fill in these missing values with <code>fill()</code>. It takes a set of columns where you want missing values to be replaced by the most recent non-missing value (sometimes called last observation carried forward).</p>
<pre class="sourceCode r"><code class="sourceCode r">treatment <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">fill</span>(person)
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt;   person           treatment response</span>
<span class="co">#&gt;   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Derrick Whitmore         1        7</span>
<span class="co">#&gt; 2 Derrick Whitmore         2       10</span>
<span class="co">#&gt; 3 Derrick Whitmore         3        9</span>
<span class="co">#&gt; 4 Katherine Burke          1        4</span></code></pre>
<div id="exercises-24" class="section level3">
<h3><span class="header-section-number">12.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Compare and contrast the <code>fill</code> arguments to <code>spread()</code> and <code>complete()</code>.</p></li>
<li><p>What does the direction argument to <code>fill()</code> do?</p></li>
</ol>
</div>
</div>
<div id="case-study" class="section level2">
<h2><span class="header-section-number">12.6</span> Case Study</h2>
<p>To finish off the chapter, let’s pull together everything you’ve learned to tackle a realistic data tidying problem. The <code>tidyr::who</code> dataset contains tuberculosis (TB) cases broken down by year, country, age, gender, and diagnosis method. The data comes from the <em>2014 World Health Organization Global Tuberculosis Report</em>, available at <a href="http://www.who.int/tb/country/data/download/en/" class="uri">http://www.who.int/tb/country/data/download/en/</a>.</p>
<p>There’s a wealth of epidemiological information in this dataset, but it’s challenging to work with the data in the form that it’s provided:</p>
<pre class="sourceCode r"><code class="sourceCode r">who
<span class="co">#&gt; # A tibble: 7,240 x 60</span>
<span class="co">#&gt;   country iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534</span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;int&gt;       &lt;int&gt;        &lt;int&gt;        &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghan… AF    AFG    1980          NA           NA           NA</span>
<span class="co">#&gt; 2 Afghan… AF    AFG    1981          NA           NA           NA</span>
<span class="co">#&gt; 3 Afghan… AF    AFG    1982          NA           NA           NA</span>
<span class="co">#&gt; 4 Afghan… AF    AFG    1983          NA           NA           NA</span>
<span class="co">#&gt; 5 Afghan… AF    AFG    1984          NA           NA           NA</span>
<span class="co">#&gt; 6 Afghan… AF    AFG    1985          NA           NA           NA</span>
<span class="co">#&gt; # … with 7,234 more rows, and 53 more variables: new_sp_m3544 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sp_m4554 &lt;int&gt;, new_sp_m5564 &lt;int&gt;, new_sp_m65 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;, new_sp_f2534 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;, new_sp_f5564 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;, new_sn_m1524 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;, new_sn_m4554 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;, new_sn_f014 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;, new_sn_f3544 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_sn_f4554 &lt;int&gt;, new_sn_f5564 &lt;int&gt;, new_sn_f65 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_ep_m014 &lt;int&gt;, new_ep_m1524 &lt;int&gt;, new_ep_m2534 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_ep_m3544 &lt;int&gt;, new_ep_m4554 &lt;int&gt;, new_ep_m5564 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_ep_m65 &lt;int&gt;, new_ep_f014 &lt;int&gt;, new_ep_f1524 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_ep_f2534 &lt;int&gt;, new_ep_f3544 &lt;int&gt;, new_ep_f4554 &lt;int&gt;,</span>
<span class="co">#&gt; #   new_ep_f5564 &lt;int&gt;, new_ep_f65 &lt;int&gt;, newrel_m014 &lt;int&gt;,</span>
<span class="co">#&gt; #   newrel_m1524 &lt;int&gt;, newrel_m2534 &lt;int&gt;, newrel_m3544 &lt;int&gt;,</span>
<span class="co">#&gt; #   newrel_m4554 &lt;int&gt;, newrel_m5564 &lt;int&gt;, newrel_m65 &lt;int&gt;,</span>
<span class="co">#&gt; #   newrel_f014 &lt;int&gt;, newrel_f1524 &lt;int&gt;, newrel_f2534 &lt;int&gt;,</span>
<span class="co">#&gt; #   newrel_f3544 &lt;int&gt;, newrel_f4554 &lt;int&gt;, newrel_f5564 &lt;int&gt;,</span>
<span class="co">#&gt; #   newrel_f65 &lt;int&gt;</span></code></pre>
<p>This is a very typical real-life example dataset. It contains redundant columns, odd variable codes, and many missing values. In short, <code>who</code> is messy, and we’ll need multiple steps to tidy it. Like dplyr, tidyr is designed so that each function does one thing well. That means in real-life situations you’ll usually need to string together multiple verbs into a pipeline.</p>
<p>The best place to start is almost always to gather together the columns that are not variables. Let’s have a look at what we’ve got:</p>
<ul>
<li><p>It looks like <code>country</code>, <code>iso2</code>, and <code>iso3</code> are three variables that
redundantly specify the country.</p></li>
<li><p><code>year</code> is clearly also a variable.</p></li>
<li><p>We don’t know what all the other columns are yet, but given the structure
in the variable names (e.g. <code>new_sp_m014</code>, <code>new_ep_m014</code>, <code>new_ep_f014</code>)
these are likely to be values, not variables.</p></li>
</ul>
<p>So we need to gather together all the columns from <code>new_sp_m014</code> to <code>newrel_f65</code>. We don’t know what those values represent yet, so we’ll give them the generic name <code>&quot;key&quot;</code>. We know the cells represent the count of cases, so we’ll use the variable <code>cases</code>. There are a lot of missing values in the current representation, so for now we’ll use <code>na.rm</code> just so we can focus on the values that are present.</p>
<pre class="sourceCode r"><code class="sourceCode r">who1 &lt;-<span class="st"> </span>who <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(new_sp_m014<span class="op">:</span>newrel_f65, <span class="dt">key =</span> <span class="st">&quot;key&quot;</span>, <span class="dt">value =</span> <span class="st">&quot;cases&quot;</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
who1
<span class="co">#&gt; # A tibble: 76,046 x 6</span>
<span class="co">#&gt;   country     iso2  iso3   year key         cases</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;       &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan AF    AFG    1997 new_sp_m014     0</span>
<span class="co">#&gt; 2 Afghanistan AF    AFG    1998 new_sp_m014    30</span>
<span class="co">#&gt; 3 Afghanistan AF    AFG    1999 new_sp_m014     8</span>
<span class="co">#&gt; 4 Afghanistan AF    AFG    2000 new_sp_m014    52</span>
<span class="co">#&gt; 5 Afghanistan AF    AFG    2001 new_sp_m014   129</span>
<span class="co">#&gt; 6 Afghanistan AF    AFG    2002 new_sp_m014    90</span>
<span class="co">#&gt; # … with 7.604e+04 more rows</span></code></pre>
<p>We can get some hint of the structure of the values in the new <code>key</code> column by counting them:</p>
<pre class="sourceCode r"><code class="sourceCode r">who1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(key)
<span class="co">#&gt; # A tibble: 56 x 2</span>
<span class="co">#&gt;   key              n</span>
<span class="co">#&gt;   &lt;chr&gt;        &lt;int&gt;</span>
<span class="co">#&gt; 1 new_ep_f014   1032</span>
<span class="co">#&gt; 2 new_ep_f1524  1021</span>
<span class="co">#&gt; 3 new_ep_f2534  1021</span>
<span class="co">#&gt; 4 new_ep_f3544  1021</span>
<span class="co">#&gt; 5 new_ep_f4554  1017</span>
<span class="co">#&gt; 6 new_ep_f5564  1017</span>
<span class="co">#&gt; # … with 50 more rows</span></code></pre>
<p>You might be able to parse this out by yourself with a little thought and some experimentation, but luckily we have the data dictionary handy. It tells us:</p>
<ol style="list-style-type: decimal">
<li><p>The first three letters of each column denote whether the column
contains new or old cases of TB. In this dataset, each column contains
new cases.</p></li>
<li><p>The next two letters describe the type of TB:</p>
<ul>
<li><code>rel</code> stands for cases of relapse</li>
<li><code>ep</code> stands for cases of extrapulmonary TB</li>
<li><code>sn</code> stands for cases of pulmonary TB that could not be diagnosed by
a pulmonary smear (smear negative)</li>
<li><code>sp</code> stands for cases of pulmonary TB that could be diagnosed be
a pulmonary smear (smear positive)</li>
</ul></li>
<li><p>The sixth letter gives the sex of TB patients. The dataset groups
cases by males (<code>m</code>) and females (<code>f</code>).</p></li>
<li><p>The remaining numbers gives the age group. The dataset groups cases into
seven age groups:</p>
<ul>
<li><code>014</code> = 0 – 14 years old</li>
<li><code>1524</code> = 15 – 24 years old</li>
<li><code>2534</code> = 25 – 34 years old</li>
<li><code>3544</code> = 35 – 44 years old</li>
<li><code>4554</code> = 45 – 54 years old</li>
<li><code>5564</code> = 55 – 64 years old</li>
<li><code>65</code> = 65 or older</li>
</ul></li>
</ol>
<p>We need to make a minor fix to the format of the column names: unfortunately the names are slightly inconsistent because instead of <code>new_rel</code> we have <code>newrel</code> (it’s hard to spot this here but if you don’t fix it we’ll get errors in subsequent steps). You’ll learn about <code>str_replace()</code> in <a href="#strings">strings</a>, but the basic idea is pretty simple: replace the characters “newrel” with “new_rel”. This makes all variable names consistent.</p>
<pre class="sourceCode r"><code class="sourceCode r">who2 &lt;-<span class="st"> </span>who1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">key =</span> stringr<span class="op">::</span><span class="kw">str_replace</span>(key, <span class="st">&quot;newrel&quot;</span>, <span class="st">&quot;new_rel&quot;</span>))
who2
<span class="co">#&gt; # A tibble: 76,046 x 6</span>
<span class="co">#&gt;   country     iso2  iso3   year key         cases</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;       &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan AF    AFG    1997 new_sp_m014     0</span>
<span class="co">#&gt; 2 Afghanistan AF    AFG    1998 new_sp_m014    30</span>
<span class="co">#&gt; 3 Afghanistan AF    AFG    1999 new_sp_m014     8</span>
<span class="co">#&gt; 4 Afghanistan AF    AFG    2000 new_sp_m014    52</span>
<span class="co">#&gt; 5 Afghanistan AF    AFG    2001 new_sp_m014   129</span>
<span class="co">#&gt; 6 Afghanistan AF    AFG    2002 new_sp_m014    90</span>
<span class="co">#&gt; # … with 7.604e+04 more rows</span></code></pre>
<p>We can separate the values in each code with two passes of <code>separate()</code>. The first pass will split the codes at each underscore.</p>
<pre class="sourceCode r"><code class="sourceCode r">who3 &lt;-<span class="st"> </span>who2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(key, <span class="kw">c</span>(<span class="st">&quot;new&quot;</span>, <span class="st">&quot;type&quot;</span>, <span class="st">&quot;sexage&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;_&quot;</span>)
who3
<span class="co">#&gt; # A tibble: 76,046 x 8</span>
<span class="co">#&gt;   country     iso2  iso3   year new   type  sexage cases</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan AF    AFG    1997 new   sp    m014       0</span>
<span class="co">#&gt; 2 Afghanistan AF    AFG    1998 new   sp    m014      30</span>
<span class="co">#&gt; 3 Afghanistan AF    AFG    1999 new   sp    m014       8</span>
<span class="co">#&gt; 4 Afghanistan AF    AFG    2000 new   sp    m014      52</span>
<span class="co">#&gt; 5 Afghanistan AF    AFG    2001 new   sp    m014     129</span>
<span class="co">#&gt; 6 Afghanistan AF    AFG    2002 new   sp    m014      90</span>
<span class="co">#&gt; # … with 7.604e+04 more rows</span></code></pre>
<p>Then we might as well drop the <code>new</code> column because it’s constant in this dataset. While we’re dropping columns, let’s also drop <code>iso2</code> and <code>iso3</code> since they’re redundant.</p>
<pre class="sourceCode r"><code class="sourceCode r">who3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(new)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;   new       n</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 new   76046</span>
who4 &lt;-<span class="st"> </span>who3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>new, <span class="op">-</span>iso2, <span class="op">-</span>iso3)</code></pre>
<p>Next we’ll separate <code>sexage</code> into <code>sex</code> and <code>age</code> by splitting after the first character:</p>
<pre class="sourceCode r"><code class="sourceCode r">who5 &lt;-<span class="st"> </span>who4 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(sexage, <span class="kw">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;age&quot;</span>), <span class="dt">sep =</span> <span class="dv">1</span>)
who5
<span class="co">#&gt; # A tibble: 76,046 x 6</span>
<span class="co">#&gt;   country      year type  sex   age   cases</span>
<span class="co">#&gt;   &lt;chr&gt;       &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghanistan  1997 sp    m     014       0</span>
<span class="co">#&gt; 2 Afghanistan  1998 sp    m     014      30</span>
<span class="co">#&gt; 3 Afghanistan  1999 sp    m     014       8</span>
<span class="co">#&gt; 4 Afghanistan  2000 sp    m     014      52</span>
<span class="co">#&gt; 5 Afghanistan  2001 sp    m     014     129</span>
<span class="co">#&gt; 6 Afghanistan  2002 sp    m     014      90</span>
<span class="co">#&gt; # … with 7.604e+04 more rows</span></code></pre>
<p>The <code>who</code> dataset is now tidy!</p>
<p>I’ve shown you the code a piece at a time, assigning each interim result to a new variable. This typically isn’t how you’d work interactively. Instead, you’d gradually build up a complex pipe:</p>
<pre class="sourceCode r"><code class="sourceCode r">who <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">gather</span>(key, value, new_sp_m014<span class="op">:</span>newrel_f65, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">key =</span> stringr<span class="op">::</span><span class="kw">str_replace</span>(key, <span class="st">&quot;newrel&quot;</span>, <span class="st">&quot;new_rel&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">separate</span>(key, <span class="kw">c</span>(<span class="st">&quot;new&quot;</span>, <span class="st">&quot;var&quot;</span>, <span class="st">&quot;sexage&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>new, <span class="op">-</span>iso2, <span class="op">-</span>iso3) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(sexage, <span class="kw">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;age&quot;</span>), <span class="dt">sep =</span> <span class="dv">1</span>)</code></pre>
<div id="exercises-25" class="section level3">
<h3><span class="header-section-number">12.6.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In this case study I set <code>na.rm = TRUE</code> just to make it easier to
check that we had the correct values. Is this reasonable? Think about
how missing values are represented in this dataset. Are there implicit
missing values? What’s the difference between an <code>NA</code> and zero?</p></li>
<li><p>What happens if you neglect the <code>mutate()</code> step?
(<code>mutate(key = stringr::str_replace(key, &quot;newrel&quot;, &quot;new_rel&quot;))</code>)</p></li>
<li><p>I claimed that <code>iso2</code> and <code>iso3</code> were redundant with <code>country</code>.
Confirm this claim.</p></li>
<li><p>For each country, year, and sex compute the total number of cases of
TB. Make an informative visualisation of the data.</p></li>
</ol>
</div>
</div>
<div id="non-tidy-data" class="section level2">
<h2><span class="header-section-number">12.7</span> Non-tidy data</h2>
<p>Before we continue on to other topics, it’s worth talking briefly about non-tidy data. Earlier in the chapter, I used the pejorative term “messy” to refer to non-tidy data. That’s an oversimplification: there are lots of useful and well-founded data structures that are not tidy data. There are two main reasons to use other data structures:</p>
<ul>
<li><p>Alternative representations may have substantial performance or space
advantages.</p></li>
<li><p>Specialised fields have evolved their own conventions for storing data
that may be quite different to the conventions of tidy data.</p></li>
</ul>
<p>Either of these reasons means you’ll need something other than a tibble (or data frame). If your data does fit naturally into a rectangular structure composed of observations and variables, I think tidy data should be your default choice. But there are good reasons to use other structures; tidy data is not the only way.</p>
<p>If you’d like to learn more about non-tidy data, I’d highly recommend this thoughtful blog post by Jeff Leek: <a href="http://simplystatistics.org/2016/02/17/non-tidy-data/" class="uri">http://simplystatistics.org/2016/02/17/non-tidy-data/</a></p>
<!--chapter:end:tidy.Rmd-->
</div>
</div>
<div id="relational-data" class="section level1">
<h1><span class="header-section-number">13</span> Relational data</h1>
<div id="introduction-7" class="section level2">
<h2><span class="header-section-number">13.1</span> Introduction</h2>
<p>It’s rare that a data analysis involves only a single table of data. Typically you have many tables of data, and you must combine them to answer the questions that you’re interested in. Collectively, multiple tables of data are called <strong>relational data</strong> because it is the relations, not just the individual datasets, that are important.</p>
<p>Relations are always defined between a pair of tables. All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair. Sometimes both elements of a pair can be the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents.</p>
<p>To work with relational data you need verbs that work with pairs of tables. There are three families of verbs designed to work with relational data:</p>
<ul>
<li><p><strong>Mutating joins</strong>, which add new variables to one data frame from matching
observations in another.</p></li>
<li><p><strong>Filtering joins</strong>, which filter observations from one data frame based on
whether or not they match an observation in the other table.</p></li>
<li><p><strong>Set operations</strong>, which treat observations as if they were set elements.</p></li>
</ul>
<p>The most common place to find relational data is in a <em>relational</em> database management system (or RDBMS), a term that encompasses almost all modern databases. If you’ve used a database before, you’ve almost certainly used SQL. If so, you should find the concepts in this chapter familiar, although their expression in dplyr is a little different. Generally, dplyr is a little easier to use than SQL because dplyr is specialised to do data analysis: it makes common data analysis operations easier, at the expense of making it more difficult to do other things that aren’t commonly needed for data analysis.</p>
<div id="prerequisites-7" class="section level3">
<h3><span class="header-section-number">13.1.1</span> Prerequisites</h3>
<p>We will explore relational data from <code>nycflights13</code> using the two-table verbs from dplyr.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(nycflights13)</code></pre>
</div>
</div>
<div id="nycflights13-relational" class="section level2">
<h2><span class="header-section-number">13.2</span> nycflights13</h2>
<p>We will use the nycflights13 package to learn about relational data. nycflights13 contains four tibbles that are related to the <code>flights</code> table that you used in <a href="#transform">data transformation</a>:</p>
<ul>
<li><p><code>airlines</code> lets you look up the full carrier name from its abbreviated
code:</p>
<pre class="sourceCode r"><code class="sourceCode r">airlines
<span class="co">#&gt; # A tibble: 16 x 2</span>
<span class="co">#&gt;   carrier name                    </span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;                   </span>
<span class="co">#&gt; 1 9E      Endeavor Air Inc.       </span>
<span class="co">#&gt; 2 AA      American Airlines Inc.  </span>
<span class="co">#&gt; 3 AS      Alaska Airlines Inc.    </span>
<span class="co">#&gt; 4 B6      JetBlue Airways         </span>
<span class="co">#&gt; 5 DL      Delta Air Lines Inc.    </span>
<span class="co">#&gt; 6 EV      ExpressJet Airlines Inc.</span>
<span class="co">#&gt; # … with 10 more rows</span></code></pre></li>
<li><p><code>airports</code> gives information about each airport, identified by the <code>faa</code>
airport code:</p>
<pre class="sourceCode r"><code class="sourceCode r">airports
<span class="co">#&gt; # A tibble: 1,458 x 8</span>
<span class="co">#&gt;   faa   name                       lat   lon   alt    tz dst   tzone       </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;chr&gt;                    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;       </span>
<span class="co">#&gt; 1 04G   Lansdowne Airport         41.1 -80.6  1044    -5 A     America/New…</span>
<span class="co">#&gt; 2 06A   Moton Field Municipal A…  32.5 -85.7   264    -6 A     America/Chi…</span>
<span class="co">#&gt; 3 06C   Schaumburg Regional       42.0 -88.1   801    -6 A     America/Chi…</span>
<span class="co">#&gt; 4 06N   Randall Airport           41.4 -74.4   523    -5 A     America/New…</span>
<span class="co">#&gt; 5 09J   Jekyll Island Airport     31.1 -81.4    11    -5 A     America/New…</span>
<span class="co">#&gt; 6 0A9   Elizabethton Municipal …  36.4 -82.2  1593    -5 A     America/New…</span>
<span class="co">#&gt; # … with 1,452 more rows</span></code></pre></li>
<li><p><code>planes</code> gives information about each plane, identified by its <code>tailnum</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">planes
<span class="co">#&gt; # A tibble: 3,322 x 9</span>
<span class="co">#&gt;   tailnum  year type       manufacturer   model  engines seats speed engine</span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; </span>
<span class="co">#&gt; 1 N10156   2004 Fixed win… EMBRAER        EMB-1…       2    55    NA Turbo…</span>
<span class="co">#&gt; 2 N102UW   1998 Fixed win… AIRBUS INDUST… A320-…       2   182    NA Turbo…</span>
<span class="co">#&gt; 3 N103US   1999 Fixed win… AIRBUS INDUST… A320-…       2   182    NA Turbo…</span>
<span class="co">#&gt; 4 N104UW   1999 Fixed win… AIRBUS INDUST… A320-…       2   182    NA Turbo…</span>
<span class="co">#&gt; 5 N10575   2002 Fixed win… EMBRAER        EMB-1…       2    55    NA Turbo…</span>
<span class="co">#&gt; 6 N105UW   1999 Fixed win… AIRBUS INDUST… A320-…       2   182    NA Turbo…</span>
<span class="co">#&gt; # … with 3,316 more rows</span></code></pre></li>
<li><p><code>weather</code> gives the weather at each NYC airport for each hour:</p>
<pre class="sourceCode r"><code class="sourceCode r">weather
<span class="co">#&gt; # A tibble: 26,115 x 15</span>
<span class="co">#&gt;   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed</span>
<span class="co">#&gt;   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;</span>
<span class="co">#&gt; 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 </span>
<span class="co">#&gt; 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06</span>
<span class="co">#&gt; 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 </span>
<span class="co">#&gt; 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 </span>
<span class="co">#&gt; 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 </span>
<span class="co">#&gt; 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 </span>
<span class="co">#&gt; # … with 2.611e+04 more rows, and 5 more variables: wind_gust &lt;dbl&gt;,</span>
<span class="co">#&gt; #   precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre></li>
</ul>
<p>One way to show the relationships between the different tables is with a drawing:</p>
<p><img src="diagrams/relational-nycflights.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This diagram is a little overwhelming, but it’s simple compared to some you’ll see in the wild! The key to understanding diagrams like this is to remember each relation always concerns a pair of tables. You don’t need to understand the whole thing; you just need to understand the chain of relations between the tables that you are interested in.</p>
<p>For nycflights13:</p>
<ul>
<li><p><code>flights</code> connects to <code>planes</code> via a single variable, <code>tailnum</code>.</p></li>
<li><p><code>flights</code> connects to <code>airlines</code> through the <code>carrier</code> variable.</p></li>
<li><p><code>flights</code> connects to <code>airports</code> in two ways: via the <code>origin</code> and
<code>dest</code> variables.</p></li>
<li><p><code>flights</code> connects to <code>weather</code> via <code>origin</code> (the location), and
<code>year</code>, <code>month</code>, <code>day</code> and <code>hour</code> (the time).</p></li>
</ul>
<div id="exercises-26" class="section level3">
<h3><span class="header-section-number">13.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Imagine you wanted to draw (approximately) the route each plane flies from
its origin to its destination. What variables would you need? What tables
would you need to combine?</p></li>
<li><p>I forgot to draw the relationship between <code>weather</code> and <code>airports</code>.
What is the relationship and how should it appear in the diagram?</p></li>
<li><p><code>weather</code> only contains information for the origin (NYC) airports. If
it contained weather records for all airports in the USA, what additional
relation would it define with <code>flights</code>?</p></li>
<li><p>We know that some days of the year are “special”, and fewer people than
usual fly on them. How might you represent that data as a data frame?
What would be the primary keys of that table? How would it connect to the
existing tables?</p></li>
</ol>
</div>
</div>
<div id="keys" class="section level2">
<h2><span class="header-section-number">13.3</span> Keys</h2>
<p>The variables used to connect each pair of tables are called <strong>keys</strong>. A key is a variable (or set of variables) that uniquely identifies an observation. In simple cases, a single variable is sufficient to identify an observation. For example, each plane is uniquely identified by its <code>tailnum</code>. In other cases, multiple variables may be needed. For example, to identify an observation in <code>weather</code> you need five variables: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, and <code>origin</code>.</p>
<p>There are two types of keys:</p>
<ul>
<li><p>A <strong>primary key</strong> uniquely identifies an observation in its own table.
For example, <code>planes$tailnum</code> is a primary key because it uniquely identifies
each plane in the <code>planes</code> table.</p></li>
<li><p>A <strong>foreign key</strong> uniquely identifies an observation in another table.
For example, the <code>flights$tailnum</code> is a foreign key because it appears in the
<code>flights</code> table where it matches each flight to a unique plane.</p></li>
</ul>
<p>A variable can be both a primary key <em>and</em> a foreign key. For example, <code>origin</code> is part of the <code>weather</code> primary key, and is also a foreign key for the <code>airport</code> table.</p>
<p>Once you’ve identified the primary keys in your tables, it’s good practice to verify that they do indeed uniquely identify each observation. One way to do that is to <code>count()</code> the primary keys and look for entries where <code>n</code> is greater than one:</p>
<pre class="sourceCode r"><code class="sourceCode r">planes <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(tailnum) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 0 x 2</span>
<span class="co">#&gt; # … with 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;</span>

weather <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(year, month, day, hour, origin) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 3 x 6</span>
<span class="co">#&gt;    year month   day  hour origin     n</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;  &lt;int&gt;</span>
<span class="co">#&gt; 1  2013    11     3     1 EWR        2</span>
<span class="co">#&gt; 2  2013    11     3     1 JFK        2</span>
<span class="co">#&gt; 3  2013    11     3     1 LGA        2</span></code></pre>
<p>Sometimes a table doesn’t have an explicit primary key: each row is an observation, but no combination of variables reliably identifies it. For example, what’s the primary key in the <code>flights</code> table? You might think it would be the date plus the flight or tail number, but neither of those are unique:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(year, month, day, flight) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 29,768 x 5</span>
<span class="co">#&gt;    year month   day flight     n</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      1     2</span>
<span class="co">#&gt; 2  2013     1     1      3     2</span>
<span class="co">#&gt; 3  2013     1     1      4     2</span>
<span class="co">#&gt; 4  2013     1     1     11     3</span>
<span class="co">#&gt; 5  2013     1     1     15     2</span>
<span class="co">#&gt; 6  2013     1     1     21     2</span>
<span class="co">#&gt; # … with 2.976e+04 more rows</span>

flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(year, month, day, tailnum) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 64,928 x 5</span>
<span class="co">#&gt;    year month   day tailnum     n</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1 N0EGMQ      2</span>
<span class="co">#&gt; 2  2013     1     1 N11189      2</span>
<span class="co">#&gt; 3  2013     1     1 N11536      2</span>
<span class="co">#&gt; 4  2013     1     1 N11544      3</span>
<span class="co">#&gt; 5  2013     1     1 N11551      2</span>
<span class="co">#&gt; 6  2013     1     1 N12540      2</span>
<span class="co">#&gt; # … with 6.492e+04 more rows</span></code></pre>
<p>When starting to work with this data, I had naively assumed that each flight number would be only used once per day: that would make it much easier to communicate problems with a specific flight. Unfortunately that is not the case! If a table lacks a primary key, it’s sometimes useful to add one with <code>mutate()</code> and <code>row_number()</code>. That makes it easier to match observations if you’ve done some filtering and want to check back in with the original data. This is called a <strong>surrogate key</strong>.</p>
<p>A primary key and the corresponding foreign key in another table form a <strong>relation</strong>. Relations are typically one-to-many. For example, each flight has one plane, but each plane has many flights. In other data, you’ll occasionally see a 1-to-1 relationship. You can think of this as a special case of 1-to-many. You can model many-to-many relations with a many-to-1 relation plus a 1-to-many relation. For example, in this data there’s a many-to-many relationship between airlines and airports: each airline flies to many airports; each airport hosts many airlines.</p>
<div id="exercises-27" class="section level3">
<h3><span class="header-section-number">13.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Add a surrogate key to <code>flights</code>.</p></li>
<li><p>Identify the keys in the following datasets</p>
<ol style="list-style-type: decimal">
<li><code>Lahman::Batting</code>,</li>
<li><code>babynames::babynames</code></li>
<li><code>nasaweather::atmos</code></li>
<li><code>fueleconomy::vehicles</code></li>
<li><code>ggplot2::diamonds</code></li>
</ol>
<p>(You might need to install some packages and read some documentation.)</p></li>
<li><p>Draw a diagram illustrating the connections between the <code>Batting</code>,
<code>Master</code>, and <code>Salaries</code> tables in the Lahman package. Draw another diagram
that shows the relationship between <code>Master</code>, <code>Managers</code>, <code>AwardsManagers</code>.</p>
<p>How would you characterise the relationship between the <code>Batting</code>,
<code>Pitching</code>, and <code>Fielding</code> tables?</p></li>
</ol>
</div>
</div>
<div id="mutating-joins" class="section level2">
<h2><span class="header-section-number">13.4</span> Mutating joins</h2>
<p>The first tool we’ll look at for combining a pair of tables is the <strong>mutating join</strong>. A mutating join allows you to combine variables from two tables. It first matches observations by their keys, then copies across variables from one table to the other.</p>
<p>Like <code>mutate()</code>, the join functions add variables to the right, so if you have a lot of variables already, the new variables won’t get printed out. For these examples, we’ll make it easier to see what’s going on in the examples by creating a narrower dataset:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(year<span class="op">:</span>day, hour, origin, dest, tailnum, carrier)
flights2
<span class="co">#&gt; # A tibble: 336,776 x 8</span>
<span class="co">#&gt;    year month   day  hour origin dest  tailnum carrier</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  </span>
<span class="co">#&gt; 1  2013     1     1     5 EWR    IAH   N14228  UA     </span>
<span class="co">#&gt; 2  2013     1     1     5 LGA    IAH   N24211  UA     </span>
<span class="co">#&gt; 3  2013     1     1     5 JFK    MIA   N619AA  AA     </span>
<span class="co">#&gt; 4  2013     1     1     5 JFK    BQN   N804JB  B6     </span>
<span class="co">#&gt; 5  2013     1     1     6 LGA    ATL   N668DN  DL     </span>
<span class="co">#&gt; 6  2013     1     1     5 EWR    ORD   N39463  UA     </span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>(Remember, when you’re in RStudio, you can also use <code>View()</code> to avoid this problem.)</p>
<p>Imagine you want to add the full airline name to the <code>flights2</code> data. You can combine the <code>airlines</code> and <code>flights2</code> data frames with <code>left_join()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>origin, <span class="op">-</span>dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(airlines, <span class="dt">by =</span> <span class="st">&quot;carrier&quot;</span>)
<span class="co">#&gt; # A tibble: 336,776 x 7</span>
<span class="co">#&gt;    year month   day  hour tailnum carrier name                  </span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 </span>
<span class="co">#&gt; 1  2013     1     1     5 N14228  UA      United Air Lines Inc. </span>
<span class="co">#&gt; 2  2013     1     1     5 N24211  UA      United Air Lines Inc. </span>
<span class="co">#&gt; 3  2013     1     1     5 N619AA  AA      American Airlines Inc.</span>
<span class="co">#&gt; 4  2013     1     1     5 N804JB  B6      JetBlue Airways       </span>
<span class="co">#&gt; 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc.  </span>
<span class="co">#&gt; 6  2013     1     1     5 N39463  UA      United Air Lines Inc. </span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>The result of joining airlines to flights2 is an additional variable: <code>name</code>. This is why I call this type of join a mutating join. In this case, you could have got to the same place using <code>mutate()</code> and R’s base subsetting:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(<span class="op">-</span>origin, <span class="op">-</span>dest) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">name =</span> airlines<span class="op">$</span>name[<span class="kw">match</span>(carrier, airlines<span class="op">$</span>carrier)])
<span class="co">#&gt; # A tibble: 336,776 x 7</span>
<span class="co">#&gt;    year month   day  hour tailnum carrier name                  </span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 </span>
<span class="co">#&gt; 1  2013     1     1     5 N14228  UA      United Air Lines Inc. </span>
<span class="co">#&gt; 2  2013     1     1     5 N24211  UA      United Air Lines Inc. </span>
<span class="co">#&gt; 3  2013     1     1     5 N619AA  AA      American Airlines Inc.</span>
<span class="co">#&gt; 4  2013     1     1     5 N804JB  B6      JetBlue Airways       </span>
<span class="co">#&gt; 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc.  </span>
<span class="co">#&gt; 6  2013     1     1     5 N39463  UA      United Air Lines Inc. </span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>But this is hard to generalise when you need to match multiple variables, and takes close reading to figure out the overall intent.</p>
<p>The following sections explain, in detail, how mutating joins work. You’ll start by learning a useful visual representation of joins. We’ll then use that to explain the four mutating join functions: the inner join, and the three outer joins. When working with real data, keys don’t always uniquely identify observations, so next we’ll talk about what happens when there isn’t a unique match. Finally, you’ll learn how to tell dplyr which variables are the keys for a given join.</p>
<div id="understanding-joins" class="section level3">
<h3><span class="header-section-number">13.4.1</span> Understanding joins</h3>
<p>To help you learn how joins work, I’m going to use a visual representation:</p>
<p><img src="diagrams/join-setup.png" width="118" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_x,
     <span class="dv">1</span>, <span class="st">&quot;x1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;x2&quot;</span>,
     <span class="dv">3</span>, <span class="st">&quot;x3&quot;</span>
)
y &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_y,
     <span class="dv">1</span>, <span class="st">&quot;y1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;y2&quot;</span>,
     <span class="dv">4</span>, <span class="st">&quot;y3&quot;</span>
)</code></pre>
<p>The coloured column represents the “key” variable: these are used to match the rows between the tables. The grey column represents the “value” column that is carried along for the ride. In these examples I’ll show a single key variable, but the idea generalises in a straightforward way to multiple keys and multiple values.</p>
<p>A join is a way of connecting each row in <code>x</code> to zero, one, or more rows in <code>y</code>. The following diagram shows each potential match as an intersection of a pair of lines.</p>
<p><img src="diagrams/join-setup2.png" width="166" style="display: block; margin: auto;" /></p>
<p>(If you look closely, you might notice that we’ve switched the order of the key and value columns in <code>x</code>. This is to emphasise that joins match based on the key; the value is just carried along for the ride.)</p>
<p>In an actual join, matches will be indicated with dots. The number of dots = the number of matches = the number of rows in the output.</p>
<p><img src="diagrams/join-inner.png" width="338" style="display: block; margin: auto;" /></p>
</div>
<div id="inner-join" class="section level3">
<h3><span class="header-section-number">13.4.2</span> Inner join</h3>
<p>The simplest type of join is the <strong>inner join</strong>. An inner join matches pairs of observations whenever their keys are equal:</p>
<p><img src="diagrams/join-inner.png" width="338" style="display: block; margin: auto;" /></p>
<p>(To be precise, this is an inner <strong>equijoin</strong> because the keys are matched using the equality operator. Since most joins are equijoins we usually drop that specification.)</p>
<p>The output of an inner join is a new data frame that contains the key, the x values, and the y values. We use <code>by</code> to tell dplyr which variable is the key:</p>
<pre class="sourceCode r"><code class="sourceCode r">x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">inner_join</span>(y, <span class="dt">by =</span> <span class="st">&quot;key&quot;</span>)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;     key val_x val_y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1     1 x1    y1   </span>
<span class="co">#&gt; 2     2 x2    y2</span></code></pre>
<p>The most important property of an inner join is that unmatched rows are not included in the result. This means that generally inner joins are usually not appropriate for use in analysis because it’s too easy to lose observations.</p>
</div>
<div id="outer-join" class="section level3">
<h3><span class="header-section-number">13.4.3</span> Outer joins</h3>
<p>An inner join keeps observations that appear in both tables. An <strong>outer join</strong> keeps observations that appear in at least one of the tables. There are three types of outer joins:</p>
<ul>
<li>A <strong>left join</strong> keeps all observations in <code>x</code>.</li>
<li>A <strong>right join</strong> keeps all observations in <code>y</code>.</li>
<li>A <strong>full join</strong> keeps all observations in <code>x</code> and <code>y</code>.</li>
</ul>
<p>These joins work by adding an additional “virtual” observation to each table. This observation has a key that always matches (if no other key matches), and a value filled with <code>NA</code>.</p>
<p>Graphically, that looks like:</p>
<p><img src="diagrams/join-outer.png" width="355" style="display: block; margin: auto;" /></p>
<p>The most commonly used join is the left join: you use this whenever you look up additional data from another table, because it preserves the original observations even when there isn’t a match. The left join should be your default join: use it unless you have a strong reason to prefer one of the others.</p>
<p>Another way to depict the different types of joins is with a Venn diagram:</p>
<p><img src="diagrams/join-venn.png" width="551" style="display: block; margin: auto;" /></p>
<p>However, this is not a great representation. It might jog your memory about which join preserves the observations in which table, but it suffers from a major limitation: a Venn diagram can’t show what happens when keys don’t uniquely identify an observation.</p>
</div>
<div id="join-matches" class="section level3">
<h3><span class="header-section-number">13.4.4</span> Duplicate keys</h3>
<p>So far all the diagrams have assumed that the keys are unique. But that’s not always the case. This section explains what happens when the keys are not unique. There are two possibilities:</p>
<ol style="list-style-type: decimal">
<li><p>One table has duplicate keys. This is useful when you want to
add in additional information as there is typically a one-to-many
relationship.</p>
<p><img src="diagrams/join-one-to-many.png" width="279" style="display: block; margin: auto;" /></p>
<p>Note that I’ve put the key column in a slightly different position
in the output. This reflects that the key is a primary key in <code>y</code>
and a foreign key in <code>x</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_x,
     <span class="dv">1</span>, <span class="st">&quot;x1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;x2&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;x3&quot;</span>,
     <span class="dv">1</span>, <span class="st">&quot;x4&quot;</span>
)
y &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_y,
     <span class="dv">1</span>, <span class="st">&quot;y1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;y2&quot;</span>
)
<span class="kw">left_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;key&quot;</span>)
<span class="co">#&gt; # A tibble: 4 x 3</span>
<span class="co">#&gt;     key val_x val_y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1     1 x1    y1   </span>
<span class="co">#&gt; 2     2 x2    y2   </span>
<span class="co">#&gt; 3     2 x3    y2   </span>
<span class="co">#&gt; 4     1 x4    y1</span></code></pre></li>
<li><p>Both tables have duplicate keys. This is usually an error because in
neither table do the keys uniquely identify an observation. When you join
duplicated keys, you get all possible combinations, the Cartesian product:</p>
<p><img src="diagrams/join-many-to-many.png" width="342" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_x,
     <span class="dv">1</span>, <span class="st">&quot;x1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;x2&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;x3&quot;</span>,
     <span class="dv">3</span>, <span class="st">&quot;x4&quot;</span>
)
y &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>key, <span class="op">~</span>val_y,
     <span class="dv">1</span>, <span class="st">&quot;y1&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;y2&quot;</span>,
     <span class="dv">2</span>, <span class="st">&quot;y3&quot;</span>,
     <span class="dv">3</span>, <span class="st">&quot;y4&quot;</span>
)
<span class="kw">left_join</span>(x, y, <span class="dt">by =</span> <span class="st">&quot;key&quot;</span>)
<span class="co">#&gt; # A tibble: 6 x 3</span>
<span class="co">#&gt;     key val_x val_y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1     1 x1    y1   </span>
<span class="co">#&gt; 2     2 x2    y2   </span>
<span class="co">#&gt; 3     2 x2    y3   </span>
<span class="co">#&gt; 4     2 x3    y2   </span>
<span class="co">#&gt; 5     2 x3    y3   </span>
<span class="co">#&gt; 6     3 x4    y4</span></code></pre></li>
</ol>
</div>
<div id="join-by" class="section level3">
<h3><span class="header-section-number">13.4.5</span> Defining the key columns</h3>
<p>So far, the pairs of tables have always been joined by a single variable, and that variable has the same name in both tables. That constraint was encoded by <code>by = &quot;key&quot;</code>. You can use other values for <code>by</code> to connect the tables in other ways:</p>
<ul>
<li><p>The default, <code>by = NULL</code>, uses all variables that appear in both tables,
the so called <strong>natural</strong> join. For example, the flights and weather tables
match on their common variables: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> and
<code>origin</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(weather)
<span class="co">#&gt; Joining, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;origin&quot;)</span>
<span class="co">#&gt; # A tibble: 336,776 x 18</span>
<span class="co">#&gt;    year month   day  hour origin dest  tailnum carrier  temp  dewp humid</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1     5 EWR    IAH   N14228  UA       39.0  28.0  64.4</span>
<span class="co">#&gt; 2  2013     1     1     5 LGA    IAH   N24211  UA       39.9  25.0  54.8</span>
<span class="co">#&gt; 3  2013     1     1     5 JFK    MIA   N619AA  AA       39.0  27.0  61.6</span>
<span class="co">#&gt; 4  2013     1     1     5 JFK    BQN   N804JB  B6       39.0  27.0  61.6</span>
<span class="co">#&gt; 5  2013     1     1     6 LGA    ATL   N668DN  DL       39.9  25.0  54.8</span>
<span class="co">#&gt; 6  2013     1     1     5 EWR    ORD   N39463  UA       39.0  28.0  64.4</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 7 more variables: wind_dir &lt;dbl&gt;,</span>
<span class="co">#&gt; #   wind_speed &lt;dbl&gt;, wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,</span>
<span class="co">#&gt; #   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre></li>
<li><p>A character vector, <code>by = &quot;x&quot;</code>. This is like a natural join, but uses only
some of the common variables. For example, <code>flights</code> and <code>planes</code> have
<code>year</code> variables, but they mean different things so we only want to join by
<code>tailnum</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(planes, <span class="dt">by =</span> <span class="st">&quot;tailnum&quot;</span>)
<span class="co">#&gt; # A tibble: 336,776 x 16</span>
<span class="co">#&gt;   year.x month   day  hour origin dest  tailnum carrier year.y type </span>
<span class="co">#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;</span>
<span class="co">#&gt; 1   2013     1     1     5 EWR    IAH   N14228  UA        1999 Fixe…</span>
<span class="co">#&gt; 2   2013     1     1     5 LGA    IAH   N24211  UA        1998 Fixe…</span>
<span class="co">#&gt; 3   2013     1     1     5 JFK    MIA   N619AA  AA        1990 Fixe…</span>
<span class="co">#&gt; 4   2013     1     1     5 JFK    BQN   N804JB  B6        2012 Fixe…</span>
<span class="co">#&gt; 5   2013     1     1     6 LGA    ATL   N668DN  DL        1991 Fixe…</span>
<span class="co">#&gt; 6   2013     1     1     5 EWR    ORD   N39463  UA        2012 Fixe…</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 6 more variables: manufacturer &lt;chr&gt;,</span>
<span class="co">#&gt; #   model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;</span></code></pre>
<p>Note that the <code>year</code> variables (which appear in both input data frames,
but are not constrained to be equal) are disambiguated in the output with
a suffix.</p></li>
<li><p>A named character vector: <code>by = c(&quot;a&quot; = &quot;b&quot;)</code>. This will
match variable <code>a</code> in table <code>x</code> to variable <code>b</code> in table <code>y</code>. The
variables from <code>x</code> will be used in the output.</p>
<p>For example, if we want to draw a map we need to combine the flights data
with the airports data which contains the location (<code>lat</code> and <code>lon</code>) of
each airport. Each flight has an origin and destination <code>airport</code>, so we
need to specify which one we want to join to:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(airports, <span class="kw">c</span>(<span class="st">&quot;dest&quot;</span> =<span class="st"> &quot;faa&quot;</span>))
<span class="co">#&gt; # A tibble: 336,776 x 15</span>
<span class="co">#&gt;    year month   day  hour origin dest  tailnum carrier name    lat   lon</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1     5 EWR    IAH   N14228  UA      Geor…  30.0 -95.3</span>
<span class="co">#&gt; 2  2013     1     1     5 LGA    IAH   N24211  UA      Geor…  30.0 -95.3</span>
<span class="co">#&gt; 3  2013     1     1     5 JFK    MIA   N619AA  AA      Miam…  25.8 -80.3</span>
<span class="co">#&gt; 4  2013     1     1     5 JFK    BQN   N804JB  B6      &lt;NA&gt;   NA    NA  </span>
<span class="co">#&gt; 5  2013     1     1     6 LGA    ATL   N668DN  DL      Hart…  33.6 -84.4</span>
<span class="co">#&gt; 6  2013     1     1     5 EWR    ORD   N39463  UA      Chic…  42.0 -87.9</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 4 more variables: alt &lt;int&gt;, tz &lt;dbl&gt;,</span>
<span class="co">#&gt; #   dst &lt;chr&gt;, tzone &lt;chr&gt;</span>

flights2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">left_join</span>(airports, <span class="kw">c</span>(<span class="st">&quot;origin&quot;</span> =<span class="st"> &quot;faa&quot;</span>))
<span class="co">#&gt; # A tibble: 336,776 x 15</span>
<span class="co">#&gt;    year month   day  hour origin dest  tailnum carrier name    lat   lon</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1     5 EWR    IAH   N14228  UA      Newa…  40.7 -74.2</span>
<span class="co">#&gt; 2  2013     1     1     5 LGA    IAH   N24211  UA      La G…  40.8 -73.9</span>
<span class="co">#&gt; 3  2013     1     1     5 JFK    MIA   N619AA  AA      John…  40.6 -73.8</span>
<span class="co">#&gt; 4  2013     1     1     5 JFK    BQN   N804JB  B6      John…  40.6 -73.8</span>
<span class="co">#&gt; 5  2013     1     1     6 LGA    ATL   N668DN  DL      La G…  40.8 -73.9</span>
<span class="co">#&gt; 6  2013     1     1     5 EWR    ORD   N39463  UA      Newa…  40.7 -74.2</span>
<span class="co">#&gt; # … with 3.368e+05 more rows, and 4 more variables: alt &lt;int&gt;, tz &lt;dbl&gt;,</span>
<span class="co">#&gt; #   dst &lt;chr&gt;, tzone &lt;chr&gt;</span></code></pre></li>
</ul>
</div>
<div id="exercises-28" class="section level3">
<h3><span class="header-section-number">13.4.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Compute the average delay by destination, then join on the <code>airports</code>
data frame so you can show the spatial distribution of delays. Here’s an
easy way to draw a map of the United States:</p>
<pre class="sourceCode r"><code class="sourceCode r">airports <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">semi_join</span>(flights, <span class="kw">c</span>(<span class="st">&quot;faa&quot;</span> =<span class="st"> &quot;dest&quot;</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(lon, lat)) <span class="op">+</span>
<span class="st">    </span><span class="kw">borders</span>(<span class="st">&quot;state&quot;</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">coord_quickmap</span>()</code></pre>
<p>(Don’t worry if you don’t understand what <code>semi_join()</code> does — you’ll
learn about it next.)</p>
<p>You might want to use the <code>size</code> or <code>colour</code> of the points to display
the average delay for each airport.</p></li>
<li><p>Add the location of the origin <em>and</em> destination (i.e. the <code>lat</code> and <code>lon</code>)
to <code>flights</code>.</p></li>
<li><p>Is there a relationship between the age of a plane and its delays?</p></li>
<li><p>What weather conditions make it more likely to see a delay?</p></li>
<li><p>What happened on June 13 2013? Display the spatial pattern of delays,
and then use Google to cross-reference with the weather.</p></li>
</ol>
</div>
<div id="other-implementations" class="section level3">
<h3><span class="header-section-number">13.4.7</span> Other implementations</h3>
<p><code>base::merge()</code> can perform all four types of mutating join:</p>
<table>
<thead>
<tr class="header">
<th>dplyr</th>
<th>merge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inner_join(x, y)</code></td>
<td><code>merge(x, y)</code></td>
</tr>
<tr class="even">
<td><code>left_join(x, y)</code></td>
<td><code>merge(x, y, all.x = TRUE)</code></td>
</tr>
<tr class="odd">
<td><code>right_join(x, y)</code></td>
<td><code>merge(x, y, all.y = TRUE)</code>,</td>
</tr>
<tr class="even">
<td><code>full_join(x, y)</code></td>
<td><code>merge(x, y, all.x = TRUE, all.y = TRUE)</code></td>
</tr>
</tbody>
</table>
<p>The advantages of the specific dplyr verbs is that they more clearly convey the intent of your code: the difference between the joins is really important but concealed in the arguments of <code>merge()</code>. dplyr’s joins are considerably faster and don’t mess with the order of the rows.</p>
<p>SQL is the inspiration for dplyr’s conventions, so the translation is straightforward:</p>
<table>
<thead>
<tr class="header">
<th>dplyr</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inner_join(x, y, by = &quot;z&quot;)</code></td>
<td><code>SELECT * FROM x INNER JOIN y USING (z)</code></td>
</tr>
<tr class="even">
<td><code>left_join(x, y, by = &quot;z&quot;)</code></td>
<td><code>SELECT * FROM x LEFT OUTER JOIN y USING (z)</code></td>
</tr>
<tr class="odd">
<td><code>right_join(x, y, by = &quot;z&quot;)</code></td>
<td><code>SELECT * FROM x RIGHT OUTER JOIN y USING (z)</code></td>
</tr>
<tr class="even">
<td><code>full_join(x, y, by = &quot;z&quot;)</code></td>
<td><code>SELECT * FROM x FULL OUTER JOIN y USING (z)</code></td>
</tr>
</tbody>
</table>
<p>Note that “INNER” and “OUTER” are optional, and often omitted.</p>
<p>Joining different variables between the tables, e.g. <code>inner_join(x, y, by = c(&quot;a&quot; = &quot;b&quot;))</code> uses a slightly different syntax in SQL: <code>SELECT * FROM x INNER JOIN y ON x.a = y.b</code>. As this syntax suggests, SQL supports a wider range of join types than dplyr because you can connect the tables using constraints other than equality (sometimes called non-equijoins).</p>
</div>
</div>
<div id="filtering-joins" class="section level2">
<h2><span class="header-section-number">13.5</span> Filtering joins</h2>
<p>Filtering joins match observations in the same way as mutating joins, but affect the observations, not the variables. There are two types:</p>
<ul>
<li><code>semi_join(x, y)</code> <strong>keeps</strong> all observations in <code>x</code> that have a match in <code>y</code>.</li>
<li><code>anti_join(x, y)</code> <strong>drops</strong> all observations in <code>x</code> that have a match in <code>y</code>.</li>
</ul>
<p>Semi-joins are useful for matching filtered summary tables back to the original rows. For example, imagine you’ve found the top ten most popular destinations:</p>
<pre class="sourceCode r"><code class="sourceCode r">top_dest &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(dest, <span class="dt">sort =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)
top_dest
<span class="co">#&gt; # A tibble: 10 x 2</span>
<span class="co">#&gt;   dest      n</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 ORD   17283</span>
<span class="co">#&gt; 2 ATL   17215</span>
<span class="co">#&gt; 3 LAX   16174</span>
<span class="co">#&gt; 4 BOS   15508</span>
<span class="co">#&gt; 5 MCO   14082</span>
<span class="co">#&gt; 6 CLT   14064</span>
<span class="co">#&gt; # … with 4 more rows</span></code></pre>
<p>Now you want to find each flight that went to one of those destinations. You could construct a filter yourself:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(dest <span class="op">%in%</span><span class="st"> </span>top_dest<span class="op">$</span>dest)
<span class="co">#&gt; # A tibble: 141,145 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 2  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 3  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; 4  2013     1     1      555            600        -5      913</span>
<span class="co">#&gt; 5  2013     1     1      557            600        -3      838</span>
<span class="co">#&gt; 6  2013     1     1      558            600        -2      753</span>
<span class="co">#&gt; # … with 1.411e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>But it’s difficult to extend that approach to multiple variables. For example, imagine that you’d found the 10 days with highest average delays. How would you construct the filter statement that used <code>year</code>, <code>month</code>, and <code>day</code> to match it back to <code>flights</code>?</p>
<p>Instead you can use a semi-join, which connects the two tables like a mutating join, but instead of adding new columns, only keeps the rows in <code>x</code> that have a match in <code>y</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">semi_join</span>(top_dest)
<span class="co">#&gt; Joining, by = &quot;dest&quot;</span>
<span class="co">#&gt; # A tibble: 141,145 x 19</span>
<span class="co">#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;</span>
<span class="co">#&gt; 1  2013     1     1      542            540         2      923</span>
<span class="co">#&gt; 2  2013     1     1      554            600        -6      812</span>
<span class="co">#&gt; 3  2013     1     1      554            558        -4      740</span>
<span class="co">#&gt; 4  2013     1     1      555            600        -5      913</span>
<span class="co">#&gt; 5  2013     1     1      557            600        -3      838</span>
<span class="co">#&gt; 6  2013     1     1      558            600        -2      753</span>
<span class="co">#&gt; # … with 1.411e+05 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,</span>
<span class="co">#&gt; #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,</span>
<span class="co">#&gt; #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</span></code></pre>
<p>Graphically, a semi-join looks like this:</p>
<p><img src="diagrams/join-semi.png" width="307" style="display: block; margin: auto;" /></p>
<p>Only the existence of a match is important; it doesn’t matter which observation is matched. This means that filtering joins never duplicate rows like mutating joins do:</p>
<p><img src="diagrams/join-semi-many.png" width="312" style="display: block; margin: auto;" /></p>
<p>The inverse of a semi-join is an anti-join. An anti-join keeps the rows that <em>don’t</em> have a match:</p>
<p><img src="diagrams/join-anti.png" width="307" style="display: block; margin: auto;" /></p>
<p>Anti-joins are useful for diagnosing join mismatches. For example, when connecting <code>flights</code> and <code>planes</code>, you might be interested to know that there are many <code>flights</code> that don’t have a match in <code>planes</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">anti_join</span>(planes, <span class="dt">by =</span> <span class="st">&quot;tailnum&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(tailnum, <span class="dt">sort =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; # A tibble: 722 x 2</span>
<span class="co">#&gt;   tailnum     n</span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1 &lt;NA&gt;     2512</span>
<span class="co">#&gt; 2 N725MQ    575</span>
<span class="co">#&gt; 3 N722MQ    513</span>
<span class="co">#&gt; 4 N723MQ    507</span>
<span class="co">#&gt; 5 N713MQ    483</span>
<span class="co">#&gt; 6 N735MQ    396</span>
<span class="co">#&gt; # … with 716 more rows</span></code></pre>
<div id="exercises-29" class="section level3">
<h3><span class="header-section-number">13.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does it mean for a flight to have a missing <code>tailnum</code>? What do the
tail numbers that don’t have a matching record in <code>planes</code> have in common?
(Hint: one variable explains ~90% of the problems.)</p></li>
<li><p>Filter flights to only show flights with planes that have flown at least 100
flights.</p></li>
<li><p>Combine <code>fueleconomy::vehicles</code> and <code>fueleconomy::common</code> to find only the
records for the most common models.</p></li>
<li><p>Find the 48 hours (over the course of the whole year) that have the worst
delays. Cross-reference it with the <code>weather</code> data. Can you see any
patterns?</p></li>
<li><p>What does <code>anti_join(flights, airports, by = c(&quot;dest&quot; = &quot;faa&quot;))</code> tell you?
What does <code>anti_join(airports, flights, by = c(&quot;faa&quot; = &quot;dest&quot;))</code> tell you?</p></li>
<li><p>You might expect that there’s an implicit relationship between plane
and airline, because each plane is flown by a single airline. Confirm
or reject this hypothesis using the tools you’ve learned above.</p></li>
</ol>
</div>
</div>
<div id="join-problems" class="section level2">
<h2><span class="header-section-number">13.6</span> Join problems</h2>
<p>The data you’ve been working with in this chapter has been cleaned up so that you’ll have as few problems as possible. Your own data is unlikely to be so nice, so there are a few things that you should do with your own data to make your joins go smoothly.</p>
<ol style="list-style-type: decimal">
<li><p>Start by identifying the variables that form the primary key in each table.
You should usually do this based on your understanding of the data, not
empirically by looking for a combination of variables that give a
unique identifier. If you just look for variables without thinking about
what they mean, you might get (un)lucky and find a combination that’s
unique in your current data but the relationship might not be true in
general.</p>
<p>For example, the altitude and longitude uniquely identify each airport,
but they are not good identifiers!</p>
<pre class="sourceCode r"><code class="sourceCode r">airports <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(alt, lon) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(n <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 0 x 3</span>
<span class="co">#&gt; # … with 3 variables: alt &lt;int&gt;, lon &lt;dbl&gt;, n &lt;int&gt;</span></code></pre></li>
<li><p>Check that none of the variables in the primary key are missing. If
a value is missing then it can’t identify an observation!</p></li>
<li><p>Check that your foreign keys match primary keys in another table. The
best way to do this is with an <code>anti_join()</code>. It’s common for keys
not to match because of data entry errors. Fixing these is often a lot of
work.</p>
<p>If you do have missing keys, you’ll need to be thoughtful about your
use of inner vs. outer joins, carefully considering whether or not you
want to drop rows that don’t have a match.</p></li>
</ol>
<p>Be aware that simply checking the number of rows before and after the join is not sufficient to ensure that your join has gone smoothly. If you have an inner join with duplicate keys in both tables, you might get unlucky as the number of dropped rows might exactly equal the number of duplicated rows!</p>
</div>
<div id="set-operations" class="section level2">
<h2><span class="header-section-number">13.7</span> Set operations</h2>
<p>The final type of two-table verb are the set operations. Generally, I use these the least frequently, but they are occasionally useful when you want to break a single complex filter into simpler pieces. All these operations work with a complete row, comparing the values of every variable. These expect the <code>x</code> and <code>y</code> inputs to have the same variables, and treat the observations like sets:</p>
<ul>
<li><code>intersect(x, y)</code>: return only observations in both <code>x</code> and <code>y</code>.</li>
<li><code>union(x, y)</code>: return unique observations in <code>x</code> and <code>y</code>.</li>
<li><code>setdiff(x, y)</code>: return observations in <code>x</code>, but not in <code>y</code>.</li>
</ul>
<p>Given this simple data:</p>
<pre class="sourceCode r"><code class="sourceCode r">df1 &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y,
   <span class="dv">1</span>,  <span class="dv">1</span>,
   <span class="dv">2</span>,  <span class="dv">1</span>
)
df2 &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y,
   <span class="dv">1</span>,  <span class="dv">1</span>,
   <span class="dv">1</span>,  <span class="dv">2</span>
)</code></pre>
<p>The four possibilities are:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">intersect</span>(df1, df2)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     1</span>

<span class="co"># Note that we get 3 rows, not 4</span>
<span class="kw">union</span>(df1, df2)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2</span>
<span class="co">#&gt; 2     2     1</span>
<span class="co">#&gt; 3     1     1</span>

<span class="kw">setdiff</span>(df1, df2)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     2     1</span>

<span class="kw">setdiff</span>(df2, df1)
<span class="co">#&gt; # A tibble: 1 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     2</span></code></pre>
<!--chapter:end:relational-data.Rmd-->
</div>
</div>
<div id="strings" class="section level1">
<h1><span class="header-section-number">14</span> Strings</h1>
<div id="introduction-8" class="section level2">
<h2><span class="header-section-number">14.1</span> Introduction</h2>
<p>This chapter introduces you to string manipulation in R. You’ll learn the basics of how strings work and how to create them by hand, but the focus of this chapter will be on regular expressions, or regexps for short. Regular expressions are useful because strings usually contain unstructured or semi-structured data, and regexps are a concise language for describing patterns in strings. When you first look at a regexp, you’ll think a cat walked across your keyboard, but as your understanding improves they will soon start to make sense.</p>
<div id="prerequisites-8" class="section level3">
<h3><span class="header-section-number">14.1.1</span> Prerequisites</h3>
<p>This chapter will focus on the <strong>stringr</strong> package for string manipulation. stringr is not part of the core tidyverse because you don’t always have textual data, so we need to load it explicitly.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(stringr)</code></pre>
</div>
</div>
<div id="string-basics" class="section level2">
<h2><span class="header-section-number">14.2</span> String basics</h2>
<p>You can create strings with either single quotes or double quotes. Unlike other languages, there is no difference in behaviour. I recommend always using <code>&quot;</code>, unless you want to create a string that contains multiple <code>&quot;</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">string1 &lt;-<span class="st"> &quot;This is a string&quot;</span>
string2 &lt;-<span class="st"> &#39;If I want to include a &quot;quote&quot; inside a string, I use single quotes&#39;</span></code></pre>
<p>If you forget to close a quote, you’ll see <code>+</code>, the continuation character:</p>
<pre><code>&gt; &quot;This is a string without a closing quote
+ 
+ 
+ HELP I&#39;M STUCK</code></pre>
<p>If this happen to you, press Escape and try again!</p>
<p>To include a literal single or double quote in a string you can use <code>\</code> to “escape” it:</p>
<pre class="sourceCode r"><code class="sourceCode r">double_quote &lt;-<span class="st"> &quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span> <span class="co"># or &#39;&quot;&#39;</span>
single_quote &lt;-<span class="st"> &#39;</span><span class="ch">\&#39;</span><span class="st">&#39;</span> <span class="co"># or &quot;&#39;&quot;</span></code></pre>
<p>That means if you want to include a literal backslash, you’ll need to double it up: <code>&quot;\\&quot;</code>.</p>
<p>Beware that the printed representation of a string is not the same as string itself, because the printed representation shows the escapes. To see the raw contents of the string, use <code>writeLines()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;</span><span class="ch">\&quot;</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">&quot;</span>)
x
<span class="co">#&gt; [1] &quot;\&quot;&quot; &quot;\\&quot;</span>
<span class="kw">writeLines</span>(x)
<span class="co">#&gt; &quot;</span>
<span class="co">#&gt; \</span></code></pre>
<p>There are a handful of other special characters. The most common are <code>&quot;\n&quot;</code>, newline, and <code>&quot;\t&quot;</code>, tab, but you can see the complete list by requesting help on <code>&quot;</code>: <code>?'&quot;'</code>, or <code>?&quot;'&quot;</code>. You’ll also sometimes see strings like <code>&quot;\u00b5&quot;</code>, this is a way of writing non-English characters that works on all platforms:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;\u00b5&quot;</span>
x
<span class="co">#&gt; [1] &quot;µ&quot;</span></code></pre>
<p>Multiple strings are often stored in a character vector, which you can create with <code>c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>)
<span class="co">#&gt; [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot;</span></code></pre>
<div id="string-length" class="section level3">
<h3><span class="header-section-number">14.2.1</span> String length</h3>
<p>Base R contains many functions to work with strings but we’ll avoid them because they can be inconsistent, which makes them hard to remember. Instead we’ll use functions from stringr. These have more intuitive names, and all start with <code>str_</code>. For example, <code>str_length()</code> tells you the number of characters in a string:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_length</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;R for data science&quot;</span>, <span class="ot">NA</span>))
<span class="co">#&gt; [1]  1 18 NA</span></code></pre>
<p>The common <code>str_</code> prefix is particularly useful if you use RStudio, because typing <code>str_</code> will trigger autocomplete, allowing you to see all stringr functions:</p>
<p><img src="screenshots/stringr-autocomplete.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="combining-strings" class="section level3">
<h3><span class="header-section-number">14.2.2</span> Combining strings</h3>
<p>To combine two or more strings, use <code>str_c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>)
<span class="co">#&gt; [1] &quot;xy&quot;</span>
<span class="kw">str_c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>)
<span class="co">#&gt; [1] &quot;xyz&quot;</span></code></pre>
<p>Use the <code>sep</code> argument to control how they’re separated:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;, &quot;</span>)
<span class="co">#&gt; [1] &quot;x, y&quot;</span></code></pre>
<p>Like most other functions in R, missing values are contagious. If you want them to print as <code>&quot;NA&quot;</code>, use <code>str_replace_na()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="ot">NA</span>)
<span class="kw">str_c</span>(<span class="st">&quot;|-&quot;</span>, x, <span class="st">&quot;-|&quot;</span>)
<span class="co">#&gt; [1] &quot;|-abc-|&quot; NA</span>
<span class="kw">str_c</span>(<span class="st">&quot;|-&quot;</span>, <span class="kw">str_replace_na</span>(x), <span class="st">&quot;-|&quot;</span>)
<span class="co">#&gt; [1] &quot;|-abc-|&quot; &quot;|-NA-|&quot;</span></code></pre>
<p>As shown above, <code>str_c()</code> is vectorised, and it automatically recycles shorter vectors to the same length as the longest:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_c</span>(<span class="st">&quot;prefix-&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>), <span class="st">&quot;-suffix&quot;</span>)
<span class="co">#&gt; [1] &quot;prefix-a-suffix&quot; &quot;prefix-b-suffix&quot; &quot;prefix-c-suffix&quot;</span></code></pre>
<p>Objects of length 0 are silently dropped. This is particularly useful in conjunction with <code>if</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">name &lt;-<span class="st"> &quot;Hadley&quot;</span>
time_of_day &lt;-<span class="st"> &quot;morning&quot;</span>
birthday &lt;-<span class="st"> </span><span class="ot">FALSE</span>

<span class="kw">str_c</span>(
  <span class="st">&quot;Good &quot;</span>, time_of_day, <span class="st">&quot; &quot;</span>, name,
  <span class="cf">if</span> (birthday) <span class="st">&quot; and HAPPY BIRTHDAY&quot;</span>,
  <span class="st">&quot;.&quot;</span>
)
<span class="co">#&gt; [1] &quot;Good morning Hadley.&quot;</span></code></pre>
<p>To collapse a vector of strings into a single string, use <code>collapse</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_c</span>(<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>, <span class="st">&quot;z&quot;</span>), <span class="dt">collapse =</span> <span class="st">&quot;, &quot;</span>)
<span class="co">#&gt; [1] &quot;x, y, z&quot;</span></code></pre>
</div>
<div id="subsetting-strings" class="section level3">
<h3><span class="header-section-number">14.2.3</span> Subsetting strings</h3>
<p>You can extract parts of a string using <code>str_sub()</code>. As well as the string, <code>str_sub()</code> takes <code>start</code> and <code>end</code> arguments which give the (inclusive) position of the substring:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Apple&quot;</span>, <span class="st">&quot;Banana&quot;</span>, <span class="st">&quot;Pear&quot;</span>)
<span class="kw">str_sub</span>(x, <span class="dv">1</span>, <span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot;</span>
<span class="co"># negative numbers count backwards from end</span>
<span class="kw">str_sub</span>(x, <span class="dv">-3</span>, <span class="dv">-1</span>)
<span class="co">#&gt; [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot;</span></code></pre>
<p>Note that <code>str_sub()</code> won’t fail if the string is too short: it will just return as much as possible:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_sub</span>(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>, <span class="dv">5</span>)
<span class="co">#&gt; [1] &quot;a&quot;</span></code></pre>
<p>You can also use the assignment form of <code>str_sub()</code> to modify strings:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_sub</span>(x, <span class="dv">1</span>, <span class="dv">1</span>) &lt;-<span class="st"> </span><span class="kw">str_to_lower</span>(<span class="kw">str_sub</span>(x, <span class="dv">1</span>, <span class="dv">1</span>))
x
<span class="co">#&gt; [1] &quot;apple&quot;  &quot;banana&quot; &quot;pear&quot;</span></code></pre>
</div>
<div id="locales" class="section level3">
<h3><span class="header-section-number">14.2.4</span> Locales</h3>
<p>Above I used <code>str_to_lower()</code> to change the text to lower case. You can also use <code>str_to_upper()</code> or <code>str_to_title()</code>. However, changing case is more complicated than it might at first appear because different languages have different rules for changing case. You can pick which set of rules to use by specifying a locale:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Turkish has two i&#39;s: with and without a dot, and it</span>
<span class="co"># has a different rule for capitalising them:</span>
<span class="kw">str_to_upper</span>(<span class="kw">c</span>(<span class="st">&quot;i&quot;</span>, <span class="st">&quot;ı&quot;</span>))
<span class="co">#&gt; [1] &quot;I&quot; &quot;I&quot;</span>
<span class="kw">str_to_upper</span>(<span class="kw">c</span>(<span class="st">&quot;i&quot;</span>, <span class="st">&quot;ı&quot;</span>), <span class="dt">locale =</span> <span class="st">&quot;tr&quot;</span>)
<span class="co">#&gt; [1] &quot;İ&quot; &quot;I&quot;</span></code></pre>
<p>The locale is specified as a ISO 639 language code, which is a two or three letter abbreviation. If you don’t already know the code for your language, Wikipedia<span id="fn14" class="footnote" data-pagedown-footnote-number="14" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" class="uri">https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes</a></span> has a good list. If you leave the locale blank, it will use the current locale, as provided by your operating system.</p>
<p>Another important operation that’s affected by the locale is sorting. The base R <code>order()</code> and <code>sort()</code> functions sort strings using the current locale. If you want robust behaviour across different computers, you may want to use <code>str_sort()</code> and <code>str_order()</code> which take an additional <code>locale</code> argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;eggplant&quot;</span>, <span class="st">&quot;banana&quot;</span>)

<span class="kw">str_sort</span>(x, <span class="dt">locale =</span> <span class="st">&quot;en&quot;</span>)  <span class="co"># English</span>
<span class="co">#&gt; [1] &quot;apple&quot;    &quot;banana&quot;   &quot;eggplant&quot;</span>

<span class="kw">str_sort</span>(x, <span class="dt">locale =</span> <span class="st">&quot;haw&quot;</span>) <span class="co"># Hawaiian</span>
<span class="co">#&gt; [1] &quot;apple&quot;    &quot;eggplant&quot; &quot;banana&quot;</span></code></pre>
</div>
<div id="exercises-30" class="section level3">
<h3><span class="header-section-number">14.2.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In code that doesn’t use stringr, you’ll often see <code>paste()</code> and <code>paste0()</code>.
What’s the difference between the two functions? What stringr function are
they equivalent to? How do the functions differ in their handling of
<code>NA</code>?</p></li>
<li><p>In your own words, describe the difference between the <code>sep</code> and <code>collapse</code>
arguments to <code>str_c()</code>.</p></li>
<li><p>Use <code>str_length()</code> and <code>str_sub()</code> to extract the middle character from
a string. What will you do if the string has an even number of characters?</p></li>
<li><p>What does <code>str_wrap()</code> do? When might you want to use it?</p></li>
<li><p>What does <code>str_trim()</code> do? What’s the opposite of <code>str_trim()</code>?</p></li>
<li><p>Write a function that turns (e.g.) a vector <code>c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> into
the string <code>a, b, and c</code>. Think carefully about what it should do if
given a vector of length 0, 1, or 2.</p></li>
</ol>
</div>
</div>
<div id="matching-patterns-with-regular-expressions" class="section level2">
<h2><span class="header-section-number">14.3</span> Matching patterns with regular expressions</h2>
<p>Regexps are a very terse language that allow you to describe patterns in strings. They take a little while to get your head around, but once you understand them, you’ll find them extremely useful.</p>
<p>To learn regular expressions, we’ll use <code>str_view()</code> and <code>str_view_all()</code>. These functions take a character vector and a regular expression, and show you how they match. We’ll start with very simple regular expressions and then gradually get more and more complicated. Once you’ve mastered pattern matching, you’ll learn how to apply those ideas with various stringr functions.</p>
<div id="basic-matches" class="section level3">
<h3><span class="header-section-number">14.3.1</span> Basic matches</h3>
<p>The simplest patterns match exact strings:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;pear&quot;</span>)
<span class="kw">str_view</span>(x, <span class="st">&quot;an&quot;</span>)</code></pre>
<div id="htmlwidget-14d5992801777f4abbc5" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-14d5992801777f4abbc5">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li>b<span class='match'>an<\/span>ana<\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>The next step up in complexity is <code>.</code>, which matches any character (except a newline):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;.a.&quot;</span>)</code></pre>
<div id="htmlwidget-df2c08526632671063f9" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-df2c08526632671063f9">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li><span class='match'>ban<\/span>ana<\/li>\n  <li>p<span class='match'>ear<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>But if “<code>.</code>” matches any character, how do you match the character “<code>.</code>”? You need to use an “escape” to tell the regular expression you want to match it exactly, not use its special behaviour. Like strings, regexps use the backslash, <code>\</code>, to escape special behaviour. So to match an <code>.</code>, you need the regexp <code>\.</code>. Unfortunately this creates a problem. We use strings to represent regular expressions, and <code>\</code> is also used as an escape symbol in strings. So to create the regular expression <code>\.</code> we need the string <code>&quot;\\.&quot;</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># To create the regular expression, we need \\</span>
dot &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">.&quot;</span>

<span class="co"># But the expression itself only contains one:</span>
<span class="kw">writeLines</span>(dot)
<span class="co">#&gt; \.</span>

<span class="co"># And this tells R to look for an explicit .</span>
<span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;a.c&quot;</span>, <span class="st">&quot;bef&quot;</span>), <span class="st">&quot;a</span><span class="ch">\\</span><span class="st">.c&quot;</span>)</code></pre>
<div id="htmlwidget-4aadbc32fbbd0d87b2b0" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-4aadbc32fbbd0d87b2b0">{"x":{"html":"<ul>\n  <li>abc<\/li>\n  <li><span class='match'>a.c<\/span><\/li>\n  <li>bef<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>If <code>\</code> is used as an escape character in regular expressions, how do you match a literal <code>\</code>? Well you need to escape it, creating the regular expression <code>\\</code>. To create that regular expression, you need to use a string, which also needs to escape <code>\</code>. That means to match a literal <code>\</code> you need to write <code>&quot;\\\\&quot;</code> — you need four backslashes to match one!</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;a</span><span class="ch">\\</span><span class="st">b&quot;</span>
<span class="kw">writeLines</span>(x)
<span class="co">#&gt; a\b</span>

<span class="kw">str_view</span>(x, <span class="st">&quot;</span><span class="ch">\\\\</span><span class="st">&quot;</span>)</code></pre>
<div id="htmlwidget-07394da27a6eb4f22e37" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-07394da27a6eb4f22e37">{"x":{"html":"<ul>\n  <li>a<span class='match'>\\<\/span>b<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>In this book, I’ll write regular expression as <code>\.</code> and strings that represent the regular expression as <code>&quot;\\.&quot;</code>.</p>
<div id="exercises-31" class="section level4">
<h4><span class="header-section-number">14.3.1.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Explain why each of these strings don’t match a <code>\</code>: <code>&quot;\&quot;</code>, <code>&quot;\\&quot;</code>, <code>&quot;\\\&quot;</code>.</p></li>
<li><p>How would you match the sequence <code>&quot;'\</code>?</p></li>
<li><p>What patterns will the regular expression <code>\..\..\..</code> match?
How would you represent it as a string?</p></li>
</ol>
</div>
</div>
<div id="anchors" class="section level3">
<h3><span class="header-section-number">14.3.2</span> Anchors</h3>
<p>By default, regular expressions will match any part of a string. It’s often useful to <em>anchor</em> the regular expression so that it matches from the start or end of the string. You can use:</p>
<ul>
<li><code>^</code> to match the start of the string.</li>
<li><code>$</code> to match the end of the string.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;pear&quot;</span>)
<span class="kw">str_view</span>(x, <span class="st">&quot;^a&quot;</span>)</code></pre>
<div id="htmlwidget-ae7fa4a918c3c5fdf863" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ae7fa4a918c3c5fdf863">{"x":{"html":"<ul>\n  <li><span class='match'>a<\/span>pple<\/li>\n  <li>banana<\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;a$&quot;</span>)</code></pre>
<div id="htmlwidget-76502c887ec734b6105a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-76502c887ec734b6105a">{"x":{"html":"<ul>\n  <li>apple<\/li>\n  <li>banan<span class='match'>a<\/span><\/li>\n  <li>pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>To remember which is which, try this mnemonic which I learned from Evan Misshula<span id="fn15" class="footnote" data-pagedown-footnote-number="15" style="white-space: pre-line;"><a href="https://twitter.com/emisshula/status/323863393167613953" class="uri">https://twitter.com/emisshula/status/323863393167613953</a></span>: if you begin with power (<code>^</code>), you end up with money (<code>$</code>).</p>
<p>To force a regular expression to only match a complete string, anchor it with both <code>^</code> and <code>$</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple pie&quot;</span>, <span class="st">&quot;apple&quot;</span>, <span class="st">&quot;apple cake&quot;</span>)
<span class="kw">str_view</span>(x, <span class="st">&quot;apple&quot;</span>)</code></pre>
<div id="htmlwidget-d34691559831f28a8b47" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-d34691559831f28a8b47">{"x":{"html":"<ul>\n  <li><span class='match'>apple<\/span> pie<\/li>\n  <li><span class='match'>apple<\/span><\/li>\n  <li><span class='match'>apple<\/span> cake<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;^apple$&quot;</span>)</code></pre>
<div id="htmlwidget-725f07776305608fdb62" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-725f07776305608fdb62">{"x":{"html":"<ul>\n  <li>apple pie<\/li>\n  <li><span class='match'>apple<\/span><\/li>\n  <li>apple cake<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>You can also match the boundary between words with <code>\b</code>. I don’t often use this in R, but I will sometimes use it when I’m doing a search in RStudio when I want to find the name of a function that’s a component of other functions. For example, I’ll search for <code>\bsum\b</code> to avoid matching <code>summarise</code>, <code>summary</code>, <code>rowsum</code> and so on.</p>
<div id="exercises-32" class="section level4">
<h4><span class="header-section-number">14.3.2.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>How would you match the literal string <code>&quot;$^$&quot;</code>?</p></li>
<li><p>Given the corpus of common words in <code>stringr::words</code>, create regular
expressions that find all words that:</p>
<ol style="list-style-type: decimal">
<li>Start with “y”.</li>
<li>End with “x”</li>
<li>Are exactly three letters long. (Don’t cheat by using <code>str_length()</code>!)</li>
<li>Have seven letters or more.</li>
</ol>
<p>Since this list is long, you might want to use the <code>match</code> argument to
<code>str_view()</code> to show only the matching or non-matching words.</p></li>
</ol>
</div>
</div>
<div id="character-classes-and-alternatives" class="section level3">
<h3><span class="header-section-number">14.3.3</span> Character classes and alternatives</h3>
<p>There are a number of special patterns that match more than one character. You’ve already seen <code>.</code>, which matches any character apart from a newline. There are four other useful tools:</p>
<ul>
<li><code>\d</code>: matches any digit.</li>
<li><code>\s</code>: matches any whitespace (e.g. space, tab, newline).</li>
<li><code>[abc]</code>: matches a, b, or c.</li>
<li><code>[^abc]</code>: matches anything except a, b, or c.</li>
</ul>
<p>Remember, to create a regular expression containing <code>\d</code> or <code>\s</code>, you’ll need to escape the <code>\</code> for the string, so you’ll type <code>&quot;\\d&quot;</code> or <code>&quot;\\s&quot;</code>.</p>
<p>A character class containing a single character is a nice alternative to backslash escapes when you want to include a single metacharacter in a regex. Many people find this more readable.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Look for a literal character that normally has special meaning in a regex</span>
<span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;a.c&quot;</span>, <span class="st">&quot;a*c&quot;</span>, <span class="st">&quot;a c&quot;</span>), <span class="st">&quot;a[.]c&quot;</span>)</code></pre>
<div id="htmlwidget-8799424a7aeb6636ab0f" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-8799424a7aeb6636ab0f">{"x":{"html":"<ul>\n  <li>abc<\/li>\n  <li><span class='match'>a.c<\/span><\/li>\n  <li>a*c<\/li>\n  <li>a c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;a.c&quot;</span>, <span class="st">&quot;a*c&quot;</span>, <span class="st">&quot;a c&quot;</span>), <span class="st">&quot;.[*]c&quot;</span>)</code></pre>
<div id="htmlwidget-ff2684d8b73d8cd50778" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ff2684d8b73d8cd50778">{"x":{"html":"<ul>\n  <li>abc<\/li>\n  <li>a.c<\/li>\n  <li><span class='match'>a*c<\/span><\/li>\n  <li>a c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;a.c&quot;</span>, <span class="st">&quot;a*c&quot;</span>, <span class="st">&quot;a c&quot;</span>), <span class="st">&quot;a[ ]&quot;</span>)</code></pre>
<div id="htmlwidget-ced067376bab81a983d5" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ced067376bab81a983d5">{"x":{"html":"<ul>\n  <li>abc<\/li>\n  <li>a.c<\/li>\n  <li>a*c<\/li>\n  <li><span class='match'>a <\/span>c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>This works for most (but not all) regex metacharacters: <code>$</code> <code>.</code> <code>|</code> <code>?</code> <code>*</code> <code>+</code> <code>(</code> <code>)</code> <code>[</code> <code>{</code>. Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: <code>]</code> <code>\</code> <code>^</code> and <code>-</code>.</p>
<p>You can use <em>alternation</em> to pick between one or more alternative patterns. For example, <code>abc|d..f</code> will match either ‘“abc”’, or <code>&quot;deaf&quot;</code>. Note that the precedence for <code>|</code> is low, so that <code>abc|xyz</code> matches <code>abc</code> or <code>xyz</code> not <code>abcyz</code> or <code>abxyz</code>. Like with mathematical expressions, if precedence ever gets confusing, use parentheses to make it clear what you want:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;grey&quot;</span>, <span class="st">&quot;gray&quot;</span>), <span class="st">&quot;gr(e|a)y&quot;</span>)</code></pre>
<div id="htmlwidget-b5df02e3ff805bc695a2" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-b5df02e3ff805bc695a2">{"x":{"html":"<ul>\n  <li><span class='match'>grey<\/span><\/li>\n  <li><span class='match'>gray<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div id="exercises-33" class="section level4">
<h4><span class="header-section-number">14.3.3.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Create regular expressions to find all words that:</p>
<ol style="list-style-type: decimal">
<li><p>Start with a vowel.</p></li>
<li><p>That only contain consonants. (Hint: thinking about matching
“not”-vowels.)</p></li>
<li><p>End with <code>ed</code>, but not with <code>eed</code>.</p></li>
<li><p>End with <code>ing</code> or <code>ise</code>.</p></li>
</ol></li>
<li><p>Empirically verify the rule “i before e except after c”.</p></li>
<li><p>Is “q” always followed by a “u”?</p></li>
<li><p>Write a regular expression that matches a word if it’s probably written
in British English, not American English.</p></li>
<li><p>Create a regular expression that will match telephone numbers as commonly
written in your country.</p></li>
</ol>
</div>
</div>
<div id="repetition" class="section level3">
<h3><span class="header-section-number">14.3.4</span> Repetition</h3>
<p>The next step up in power involves controlling how many times a pattern matches:</p>
<ul>
<li><code>?</code>: 0 or 1</li>
<li><code>+</code>: 1 or more</li>
<li><code>*</code>: 0 or more</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;1888 is the longest year in Roman numerals: MDCCCLXXXVIII&quot;</span>
<span class="kw">str_view</span>(x, <span class="st">&quot;CC?&quot;</span>)</code></pre>
<div id="htmlwidget-db9140ebde3f67c51e31" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-db9140ebde3f67c51e31">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;CC+&quot;</span>)</code></pre>
<div id="htmlwidget-2aa9dbed8d93af3e0be8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-2aa9dbed8d93af3e0be8">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&#39;C[LX]+&#39;</span>)</code></pre>
<div id="htmlwidget-12ff9c2ce809973ce8d1" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-12ff9c2ce809973ce8d1">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MDCC<span class='match'>CLXXX<\/span>VIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>Note that the precedence of these operators is high, so you can write: <code>colou?r</code> to match either American or British spellings. That means most uses will need parentheses, like <code>bana(na)+</code>.</p>
<p>You can also specify the number of matches precisely:</p>
<ul>
<li><code>{n}</code>: exactly n</li>
<li><code>{n,}</code>: n or more</li>
<li><code>{,m}</code>: at most m</li>
<li><code>{n,m}</code>: between n and m</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;C{2}&quot;</span>)</code></pre>
<div id="htmlwidget-b338ba377455914076ea" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-b338ba377455914076ea">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;C{2,}&quot;</span>)</code></pre>
<div id="htmlwidget-f9d1e794c5feb6374ab8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f9d1e794c5feb6374ab8">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&quot;C{2,3}&quot;</span>)</code></pre>
<div id="htmlwidget-dd3d01f170c0aa6859bc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-dd3d01f170c0aa6859bc">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>By default these matches are “greedy”: they will match the longest string possible. You can make them “lazy”, matching the shortest string possible by putting a <code>?</code> after them. This is an advanced feature of regular expressions, but it’s useful to know that it exists:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&#39;C{2,3}?&#39;</span>)</code></pre>
<div id="htmlwidget-aa15db13da1b7c3faf29" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-aa15db13da1b7c3faf29">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MD<span class='match'>CC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(x, <span class="st">&#39;C[LX]+?&#39;</span>)</code></pre>
<div id="htmlwidget-f3525ce3d319e7c562ff" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f3525ce3d319e7c562ff">{"x":{"html":"<ul>\n  <li>1888 is the longest year in Roman numerals: MDCC<span class='match'>CL<\/span>XXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div id="exercises-34" class="section level4">
<h4><span class="header-section-number">14.3.4.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Describe the equivalents of <code>?</code>, <code>+</code>, <code>*</code> in <code>{m,n}</code> form.</p></li>
<li><p>Describe in words what these regular expressions match:
(read carefully to see if I’m using a regular expression or a string
that defines a regular expression.)</p>
<ol style="list-style-type: decimal">
<li><code>^.*$</code></li>
<li><code>&quot;\\{.+\\}&quot;</code></li>
<li><code>\d{4}-\d{2}-\d{2}</code></li>
<li><code>&quot;\\\\{4}&quot;</code></li>
</ol></li>
<li><p>Create regular expressions to find all words that:</p>
<ol style="list-style-type: decimal">
<li>Start with three consonants.</li>
<li>Have three or more vowels in a row.</li>
<li>Have two or more vowel-consonant pairs in a row.</li>
</ol></li>
<li><p>Solve the beginner regexp crosswords at
<a href="https://regexcrossword.com/challenges/beginner" class="uri">https://regexcrossword.com/challenges/beginner</a>.</p></li>
</ol>
</div>
</div>
<div id="grouping-and-backreferences" class="section level3">
<h3><span class="header-section-number">14.3.5</span> Grouping and backreferences</h3>
<p>Earlier, you learned about parentheses as a way to disambiguate complex expressions. Parentheses also create a <em>numbered</em> capturing group (number 1, 2 etc.). A capturing group stores <em>the part of the string</em> matched by the part of the regular expression inside the parentheses. You can refer to the same text as previously matched by a capturing group with <em>backreferences</em>, like <code>\1</code>, <code>\2</code> etc. For example, the following regular expression finds all fruits that have a repeated pair of letters.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(fruit, <span class="st">&quot;(..)</span><span class="ch">\\</span><span class="st">1&quot;</span>, <span class="dt">match =</span> <span class="ot">TRUE</span>)</code></pre>
<div id="htmlwidget-59f2370825da36350af1" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-59f2370825da36350af1">{"x":{"html":"<ul>\n  <li>b<span class='match'>anan<\/span>a<\/li>\n  <li><span class='match'>coco<\/span>nut<\/li>\n  <li><span class='match'>cucu<\/span>mber<\/li>\n  <li><span class='match'>juju<\/span>be<\/li>\n  <li><span class='match'>papa<\/span>ya<\/li>\n  <li>s<span class='match'>alal<\/span> berry<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>(Shortly, you’ll also see how they’re useful in conjunction with <code>str_match()</code>.)</p>
<div id="exercises-35" class="section level4">
<h4><span class="header-section-number">14.3.5.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Describe, in words, what these expressions will match:</p>
<ol style="list-style-type: decimal">
<li><code>(.)\1\1</code></li>
<li><code>&quot;(.)(.)\\2\\1&quot;</code></li>
<li><code>(..)\1</code></li>
<li><code>&quot;(.).\\1.\\1&quot;</code></li>
<li><code>&quot;(.)(.)(.).*\\3\\2\\1&quot;</code></li>
</ol></li>
<li><p>Construct regular expressions to match words that:</p>
<ol style="list-style-type: decimal">
<li><p>Start and end with the same character.</p></li>
<li><p>Contain a repeated pair of letters
(e.g. “church” contains “ch” repeated twice.)</p></li>
<li><p>Contain one letter repeated in at least three places
(e.g. “eleven” contains three “e”s.)</p></li>
</ol></li>
</ol>
</div>
</div>
</div>
<div id="tools" class="section level2">
<h2><span class="header-section-number">14.4</span> Tools</h2>
<p>Now that you’ve learned the basics of regular expressions, it’s time to learn how to apply them to real problems. In this section you’ll learn a wide array of stringr functions that let you:</p>
<ul>
<li>Determine which strings match a pattern.</li>
<li>Find the positions of matches.</li>
<li>Extract the content of matches.</li>
<li>Replace matches with new values.</li>
<li>Split a string based on a match.</li>
</ul>
<p>A word of caution before we continue: because regular expressions are so powerful, it’s easy to try and solve every problem with a single regular expression. In the words of Jamie Zawinski:</p>
<blockquote>
<p>Some people, when confronted with a problem, think “I know, I’ll use regular
expressions.” Now they have two problems.</p>
</blockquote>
<p>As a cautionary tale, check out this regular expression that checks if a email address is valid:</p>
<pre><code>(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)
?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;
@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;
(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\
&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;
:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,
;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?
:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\
&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\
]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)
?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;
()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;
@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,
;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\
&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.
\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(
?:\r\n)?[ \t])*))*)?;\s*)</code></pre>
<p>This is a somewhat pathological example (because email addresses are actually surprisingly complex), but is used in real code. See the stackoverflow discussion at <a href="http://stackoverflow.com/a/201378" class="uri">http://stackoverflow.com/a/201378</a> for more details.</p>
<p>Don’t forget that you’re in a programming language and you have other tools at your disposal. Instead of creating one complex regular expression, it’s often easier to write a series of simpler regexps. If you get stuck trying to create a single regexp that solves your problem, take a step back and think if you could break the problem down into smaller pieces, solving each challenge before moving onto the next one.</p>
<div id="detect-matches" class="section level3">
<h3><span class="header-section-number">14.4.1</span> Detect matches</h3>
<p>To determine if a character vector matches a pattern, use <code>str_detect()</code>. It returns a logical vector the same length as the input:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;pear&quot;</span>)
<span class="kw">str_detect</span>(x, <span class="st">&quot;e&quot;</span>)
<span class="co">#&gt; [1]  TRUE FALSE  TRUE</span></code></pre>
<p>Remember that when you use a logical vector in a numeric context, <code>FALSE</code> becomes 0 and <code>TRUE</code> becomes 1. That makes <code>sum()</code> and <code>mean()</code> useful if you want to answer questions about matches across a larger vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># How many common words start with t?</span>
<span class="kw">sum</span>(<span class="kw">str_detect</span>(words, <span class="st">&quot;^t&quot;</span>))
<span class="co">#&gt; [1] 65</span>
<span class="co"># What proportion of common words end with a vowel?</span>
<span class="kw">mean</span>(<span class="kw">str_detect</span>(words, <span class="st">&quot;[aeiou]$&quot;</span>))
<span class="co">#&gt; [1] 0.277</span></code></pre>
<p>When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple <code>str_detect()</code> calls with logical operators, rather than trying to create a single regular expression. For example, here are two ways to find all words that don’t contain any vowels:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Find all words containing at least one vowel, and negate</span>
no_vowels_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="op">!</span><span class="kw">str_detect</span>(words, <span class="st">&quot;[aeiou]&quot;</span>)
<span class="co"># Find all words consisting only of consonants (non-vowels)</span>
no_vowels_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">str_detect</span>(words, <span class="st">&quot;^[^aeiou]+$&quot;</span>)
<span class="kw">identical</span>(no_vowels_<span class="dv">1</span>, no_vowels_<span class="dv">2</span>)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p>The results are identical, but I think the first approach is significantly easier to understand. If your regular expression gets overly complicated, try breaking it up into smaller pieces, giving each piece a name, and then combining the pieces with logical operations.</p>
<p>A common use of <code>str_detect()</code> is to select the elements that match a pattern. You can do this with logical subsetting, or the convenient <code>str_subset()</code> wrapper:</p>
<pre class="sourceCode r"><code class="sourceCode r">words[<span class="kw">str_detect</span>(words, <span class="st">&quot;x$&quot;</span>)]
<span class="co">#&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot;</span>
<span class="kw">str_subset</span>(words, <span class="st">&quot;x$&quot;</span>)
<span class="co">#&gt; [1] &quot;box&quot; &quot;sex&quot; &quot;six&quot; &quot;tax&quot;</span></code></pre>
<p>Typically, however, your strings will be one column of a data frame, and you’ll want to use filter instead:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">word =</span> words, 
  <span class="dt">i =</span> <span class="kw">seq_along</span>(word)
)
df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">str_detect</span>(word, <span class="st">&quot;x$&quot;</span>))
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;   word      i</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 box     108</span>
<span class="co">#&gt; 2 sex     747</span>
<span class="co">#&gt; 3 six     772</span>
<span class="co">#&gt; 4 tax     841</span></code></pre>
<p>A variation on <code>str_detect()</code> is <code>str_count()</code>: rather than a simple yes or no, it tells you how many matches there are in a string:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;banana&quot;</span>, <span class="st">&quot;pear&quot;</span>)
<span class="kw">str_count</span>(x, <span class="st">&quot;a&quot;</span>)
<span class="co">#&gt; [1] 1 3 1</span>

<span class="co"># On average, how many vowels per word?</span>
<span class="kw">mean</span>(<span class="kw">str_count</span>(words, <span class="st">&quot;[aeiou]&quot;</span>))
<span class="co">#&gt; [1] 1.99</span></code></pre>
<p>It’s natural to use <code>str_count()</code> with <code>mutate()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">vowels =</span> <span class="kw">str_count</span>(word, <span class="st">&quot;[aeiou]&quot;</span>),
    <span class="dt">consonants =</span> <span class="kw">str_count</span>(word, <span class="st">&quot;[^aeiou]&quot;</span>)
  )
<span class="co">#&gt; # A tibble: 980 x 4</span>
<span class="co">#&gt;   word         i vowels consonants</span>
<span class="co">#&gt;   &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 a            1      1          0</span>
<span class="co">#&gt; 2 able         2      2          2</span>
<span class="co">#&gt; 3 about        3      3          2</span>
<span class="co">#&gt; 4 absolute     4      4          4</span>
<span class="co">#&gt; 5 accept       5      2          4</span>
<span class="co">#&gt; 6 account      6      3          4</span>
<span class="co">#&gt; # … with 974 more rows</span></code></pre>
<p>Note that matches never overlap. For example, in <code>&quot;abababa&quot;</code>, how many times will the pattern <code>&quot;aba&quot;</code> match? Regular expressions say two, not three:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_count</span>(<span class="st">&quot;abababa&quot;</span>, <span class="st">&quot;aba&quot;</span>)
<span class="co">#&gt; [1] 2</span>
<span class="kw">str_view_all</span>(<span class="st">&quot;abababa&quot;</span>, <span class="st">&quot;aba&quot;</span>)</code></pre>
<div id="htmlwidget-3ec749e04bfb96c2d6c3" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-3ec749e04bfb96c2d6c3">{"x":{"html":"<ul>\n  <li><span class='match'>aba<\/span>b<span class='match'>aba<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>Note the use of <code>str_view_all()</code>. As you’ll shortly learn, many stringr functions come in pairs: one function works with a single match, and the other works with all matches. The second function will have the suffix <code>_all</code>.</p>
<div id="exercises-36" class="section level4">
<h4><span class="header-section-number">14.4.1.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>For each of the following challenges, try solving it by using both a single
regular expression, and a combination of multiple <code>str_detect()</code> calls.</p>
<ol style="list-style-type: decimal">
<li><p>Find all words that start or end with <code>x</code>.</p></li>
<li><p>Find all words that start with a vowel and end with a consonant.</p></li>
<li><p>Are there any words that contain at least one of each different
vowel?</p></li>
</ol></li>
<li><p>What word has the highest number of vowels? What word has the highest
proportion of vowels? (Hint: what is the denominator?)</p></li>
</ol>
</div>
</div>
<div id="extract-matches" class="section level3">
<h3><span class="header-section-number">14.4.2</span> Extract matches</h3>
<p>To extract the actual text of a match, use <code>str_extract()</code>. To show that off, we’re going to need a more complicated example. I’m going to use the Harvard sentences<span id="fn16" class="footnote" data-pagedown-footnote-number="16" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/Harvard_sentences" class="uri">https://en.wikipedia.org/wiki/Harvard_sentences</a></span>, which were designed to test VOIP systems, but are also useful for practicing regexps. These are provided in <code>stringr::sentences</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(sentences)
<span class="co">#&gt; [1] 720</span>
<span class="kw">head</span>(sentences)
<span class="co">#&gt; [1] &quot;The birch canoe slid on the smooth planks.&quot; </span>
<span class="co">#&gt; [2] &quot;Glue the sheet to the dark blue background.&quot;</span>
<span class="co">#&gt; [3] &quot;It&#39;s easy to tell the depth of a well.&quot;     </span>
<span class="co">#&gt; [4] &quot;These days a chicken leg is a rare dish.&quot;   </span>
<span class="co">#&gt; [5] &quot;Rice is often served in round bowls.&quot;       </span>
<span class="co">#&gt; [6] &quot;The juice of lemons makes fine punch.&quot;</span></code></pre>
<p>Imagine we want to find all sentences that contain a colour. We first create a vector of colour names, and then turn it into a single regular expression:</p>
<pre class="sourceCode r"><code class="sourceCode r">colours &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;yellow&quot;</span>, <span class="st">&quot;green&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;purple&quot;</span>)
colour_match &lt;-<span class="st"> </span><span class="kw">str_c</span>(colours, <span class="dt">collapse =</span> <span class="st">&quot;|&quot;</span>)
colour_match
<span class="co">#&gt; [1] &quot;red|orange|yellow|green|blue|purple&quot;</span></code></pre>
<p>Now we can select the sentences that contain a colour, and then extract the colour to figure out which one it is:</p>
<pre class="sourceCode r"><code class="sourceCode r">has_colour &lt;-<span class="st"> </span><span class="kw">str_subset</span>(sentences, colour_match)
matches &lt;-<span class="st"> </span><span class="kw">str_extract</span>(has_colour, colour_match)
<span class="kw">head</span>(matches)
<span class="co">#&gt; [1] &quot;blue&quot; &quot;blue&quot; &quot;red&quot;  &quot;red&quot;  &quot;red&quot;  &quot;blue&quot;</span></code></pre>
<p>Note that <code>str_extract()</code> only extracts the first match. We can see that most easily by first selecting all the sentences that have more than 1 match:</p>
<pre class="sourceCode r"><code class="sourceCode r">more &lt;-<span class="st"> </span>sentences[<span class="kw">str_count</span>(sentences, colour_match) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>]
<span class="kw">str_view_all</span>(more, colour_match)</code></pre>
<div id="htmlwidget-6a2314a79aa854fab7df" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6a2314a79aa854fab7df">{"x":{"html":"<ul>\n  <li>It is hard to erase <span class='match'>blue<\/span> or <span class='match'>red<\/span> ink.<\/li>\n  <li>The <span class='match'>green<\/span> light in the brown box flicke<span class='match'>red<\/span>.<\/li>\n  <li>The sky in the west is tinged with <span class='match'>orange<\/span> <span class='match'>red<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">str_extract</span>(more, colour_match)
<span class="co">#&gt; [1] &quot;blue&quot;   &quot;green&quot;  &quot;orange&quot;</span></code></pre>
<p>This is a common pattern for stringr functions, because working with a single match allows you to use much simpler data structures. To get all matches, use <code>str_extract_all()</code>. It returns a list:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_extract_all</span>(more, colour_match)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;blue&quot; &quot;red&quot; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] &quot;green&quot; &quot;red&quot;  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] &quot;orange&quot; &quot;red&quot;</span></code></pre>
<p>You’ll learn more about lists in <a href="#lists">lists</a> and <a href="#iteration">iteration</a>.</p>
<p>If you use <code>simplify = TRUE</code>, <code>str_extract_all()</code> will return a matrix with short matches expanded to the same length as the longest:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_extract_all</span>(more, colour_match, <span class="dt">simplify =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt;      [,1]     [,2] </span>
<span class="co">#&gt; [1,] &quot;blue&quot;   &quot;red&quot;</span>
<span class="co">#&gt; [2,] &quot;green&quot;  &quot;red&quot;</span>
<span class="co">#&gt; [3,] &quot;orange&quot; &quot;red&quot;</span>

x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;a b&quot;</span>, <span class="st">&quot;a b c&quot;</span>)
<span class="kw">str_extract_all</span>(x, <span class="st">&quot;[a-z]&quot;</span>, <span class="dt">simplify =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt;      [,1] [,2] [,3]</span>
<span class="co">#&gt; [1,] &quot;a&quot;  &quot;&quot;   &quot;&quot;  </span>
<span class="co">#&gt; [2,] &quot;a&quot;  &quot;b&quot;  &quot;&quot;  </span>
<span class="co">#&gt; [3,] &quot;a&quot;  &quot;b&quot;  &quot;c&quot;</span></code></pre>
<div id="exercises-37" class="section level4">
<h4><span class="header-section-number">14.4.2.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>In the previous example, you might have noticed that the regular
expression matched “flickered”, which is not a colour. Modify the
regex to fix the problem.</p></li>
<li><p>From the Harvard sentences data, extract:</p>
<ol style="list-style-type: decimal">
<li>The first word from each sentence.</li>
<li>All words ending in <code>ing</code>.</li>
<li>All plurals.</li>
</ol></li>
</ol>
</div>
</div>
<div id="grouped-matches" class="section level3">
<h3><span class="header-section-number">14.4.3</span> Grouped matches</h3>
<p>Earlier in this chapter we talked about the use of parentheses for clarifying precedence and for backreferences when matching. You can also use parentheses to extract parts of a complex match. For example, imagine we want to extract nouns from the sentences. As a heuristic, we’ll look for any word that comes after “a” or “the”. Defining a “word” in a regular expression is a little tricky, so here I use a simple approximation: a sequence of at least one character that isn’t a space.</p>
<pre class="sourceCode r"><code class="sourceCode r">noun &lt;-<span class="st"> &quot;(a|the) ([^ ]+)&quot;</span>

has_noun &lt;-<span class="st"> </span>sentences <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">str_subset</span>(noun) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">10</span>)
has_noun <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_extract</span>(noun)
<span class="co">#&gt;  [1] &quot;the smooth&quot; &quot;the sheet&quot;  &quot;the depth&quot;  &quot;a chicken&quot;  &quot;the parked&quot;</span>
<span class="co">#&gt;  [6] &quot;the sun&quot;    &quot;the huge&quot;   &quot;the ball&quot;   &quot;the woman&quot;  &quot;a helps&quot;</span></code></pre>
<p><code>str_extract()</code> gives us the complete match; <code>str_match()</code> gives each individual component. Instead of a character vector, it returns a matrix, with one column for the complete match followed by one column for each group:</p>
<pre class="sourceCode r"><code class="sourceCode r">has_noun <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_match</span>(noun)
<span class="co">#&gt;       [,1]         [,2]  [,3]     </span>
<span class="co">#&gt;  [1,] &quot;the smooth&quot; &quot;the&quot; &quot;smooth&quot; </span>
<span class="co">#&gt;  [2,] &quot;the sheet&quot;  &quot;the&quot; &quot;sheet&quot;  </span>
<span class="co">#&gt;  [3,] &quot;the depth&quot;  &quot;the&quot; &quot;depth&quot;  </span>
<span class="co">#&gt;  [4,] &quot;a chicken&quot;  &quot;a&quot;   &quot;chicken&quot;</span>
<span class="co">#&gt;  [5,] &quot;the parked&quot; &quot;the&quot; &quot;parked&quot; </span>
<span class="co">#&gt;  [6,] &quot;the sun&quot;    &quot;the&quot; &quot;sun&quot;    </span>
<span class="co">#&gt;  [7,] &quot;the huge&quot;   &quot;the&quot; &quot;huge&quot;   </span>
<span class="co">#&gt;  [8,] &quot;the ball&quot;   &quot;the&quot; &quot;ball&quot;   </span>
<span class="co">#&gt;  [9,] &quot;the woman&quot;  &quot;the&quot; &quot;woman&quot;  </span>
<span class="co">#&gt; [10,] &quot;a helps&quot;    &quot;a&quot;   &quot;helps&quot;</span></code></pre>
<p>(Unsurprisingly, our heuristic for detecting nouns is poor, and also picks up adjectives like smooth and parked.)</p>
<p>If your data is in a tibble, it’s often easier to use <code>tidyr::extract()</code>. It works like <code>str_match()</code> but requires you to name the matches, which are then placed in new columns:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">sentence =</span> sentences) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>tidyr<span class="op">::</span><span class="kw">extract</span>(
    sentence, <span class="kw">c</span>(<span class="st">&quot;article&quot;</span>, <span class="st">&quot;noun&quot;</span>), <span class="st">&quot;(a|the) ([^ ]+)&quot;</span>, 
    <span class="dt">remove =</span> <span class="ot">FALSE</span>
  )
<span class="co">#&gt; # A tibble: 720 x 3</span>
<span class="co">#&gt;   sentence                                    article noun   </span>
<span class="co">#&gt;   &lt;chr&gt;                                       &lt;chr&gt;   &lt;chr&gt;  </span>
<span class="co">#&gt; 1 The birch canoe slid on the smooth planks.  the     smooth </span>
<span class="co">#&gt; 2 Glue the sheet to the dark blue background. the     sheet  </span>
<span class="co">#&gt; 3 It&#39;s easy to tell the depth of a well.      the     depth  </span>
<span class="co">#&gt; 4 These days a chicken leg is a rare dish.    a       chicken</span>
<span class="co">#&gt; 5 Rice is often served in round bowls.        &lt;NA&gt;    &lt;NA&gt;   </span>
<span class="co">#&gt; 6 The juice of lemons makes fine punch.       &lt;NA&gt;    &lt;NA&gt;   </span>
<span class="co">#&gt; # … with 714 more rows</span></code></pre>
<p>Like <code>str_extract()</code>, if you want all matches for each string, you’ll need <code>str_match_all()</code>.</p>
<div id="exercises-38" class="section level4">
<h4><span class="header-section-number">14.4.3.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Find all words that come after a “number” like “one”, “two”, “three” etc.
Pull out both the number and the word.</p></li>
<li><p>Find all contractions. Separate out the pieces before and after the
apostrophe.</p></li>
</ol>
</div>
</div>
<div id="replacing-matches" class="section level3">
<h3><span class="header-section-number">14.4.4</span> Replacing matches</h3>
<p><code>str_replace()</code> and <code>str_replace_all()</code> allow you to replace matches with new strings. The simplest use is to replace a pattern with a fixed string:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;pear&quot;</span>, <span class="st">&quot;banana&quot;</span>)
<span class="kw">str_replace</span>(x, <span class="st">&quot;[aeiou]&quot;</span>, <span class="st">&quot;-&quot;</span>)
<span class="co">#&gt; [1] &quot;-pple&quot;  &quot;p-ar&quot;   &quot;b-nana&quot;</span>
<span class="kw">str_replace_all</span>(x, <span class="st">&quot;[aeiou]&quot;</span>, <span class="st">&quot;-&quot;</span>)
<span class="co">#&gt; [1] &quot;-ppl-&quot;  &quot;p--r&quot;   &quot;b-n-n-&quot;</span></code></pre>
<p>With <code>str_replace_all()</code> you can perform multiple replacements by supplying a named vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1 house&quot;</span>, <span class="st">&quot;2 cars&quot;</span>, <span class="st">&quot;3 people&quot;</span>)
<span class="kw">str_replace_all</span>(x, <span class="kw">c</span>(<span class="st">&quot;1&quot;</span> =<span class="st"> &quot;one&quot;</span>, <span class="st">&quot;2&quot;</span> =<span class="st"> &quot;two&quot;</span>, <span class="st">&quot;3&quot;</span> =<span class="st"> &quot;three&quot;</span>))
<span class="co">#&gt; [1] &quot;one house&quot;    &quot;two cars&quot;     &quot;three people&quot;</span></code></pre>
<p>Instead of replacing with a fixed string you can use backreferences to insert components of the match. In the following code, I flip the order of the second and third words.</p>
<pre class="sourceCode r"><code class="sourceCode r">sentences <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_replace</span>(<span class="st">&quot;([^ ]+) ([^ ]+) ([^ ]+)&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1 </span><span class="ch">\\</span><span class="st">3 </span><span class="ch">\\</span><span class="st">2&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">5</span>)
<span class="co">#&gt; [1] &quot;The canoe birch slid on the smooth planks.&quot; </span>
<span class="co">#&gt; [2] &quot;Glue sheet the to the dark blue background.&quot;</span>
<span class="co">#&gt; [3] &quot;It&#39;s to easy tell the depth of a well.&quot;     </span>
<span class="co">#&gt; [4] &quot;These a days chicken leg is a rare dish.&quot;   </span>
<span class="co">#&gt; [5] &quot;Rice often is served in round bowls.&quot;</span></code></pre>
<div id="exercises-39" class="section level4">
<h4><span class="header-section-number">14.4.4.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Replace all forward slashes in a string with backslashes.</p></li>
<li><p>Implement a simple version of <code>str_to_lower()</code> using <code>replace_all()</code>.</p></li>
<li><p>Switch the first and last letters in <code>words</code>. Which of those strings
are still words?</p></li>
</ol>
</div>
</div>
<div id="splitting" class="section level3">
<h3><span class="header-section-number">14.4.5</span> Splitting</h3>
<p>Use <code>str_split()</code> to split a string up into pieces. For example, we could split sentences into words:</p>
<pre class="sourceCode r"><code class="sourceCode r">sentences <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_split</span>(<span class="st">&quot; &quot;</span>)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;The&quot;     &quot;birch&quot;   &quot;canoe&quot;   &quot;slid&quot;    &quot;on&quot;      &quot;the&quot;     &quot;smooth&quot; </span>
<span class="co">#&gt; [8] &quot;planks.&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] &quot;Glue&quot;        &quot;the&quot;         &quot;sheet&quot;       &quot;to&quot;          &quot;the&quot;        </span>
<span class="co">#&gt; [6] &quot;dark&quot;        &quot;blue&quot;        &quot;background.&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] &quot;It&#39;s&quot;  &quot;easy&quot;  &quot;to&quot;    &quot;tell&quot;  &quot;the&quot;   &quot;depth&quot; &quot;of&quot;    &quot;a&quot;     &quot;well.&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[4]]</span>
<span class="co">#&gt; [1] &quot;These&quot;   &quot;days&quot;    &quot;a&quot;       &quot;chicken&quot; &quot;leg&quot;     &quot;is&quot;      &quot;a&quot;      </span>
<span class="co">#&gt; [8] &quot;rare&quot;    &quot;dish.&quot;  </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[5]]</span>
<span class="co">#&gt; [1] &quot;Rice&quot;   &quot;is&quot;     &quot;often&quot;  &quot;served&quot; &quot;in&quot;     &quot;round&quot;  &quot;bowls.&quot;</span></code></pre>
<p>Because each component might contain a different number of pieces, this returns a list. If you’re working with a length-1 vector, the easiest thing is to just extract the first element of the list:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;a|b|c|d&quot;</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_split</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">|&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>.[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</span></code></pre>
<p>Otherwise, like the other stringr functions that return a list, you can use <code>simplify = TRUE</code> to return a matrix:</p>
<pre class="sourceCode r"><code class="sourceCode r">sentences <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">head</span>(<span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str_split</span>(<span class="st">&quot; &quot;</span>, <span class="dt">simplify =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt;      [,1]    [,2]    [,3]    [,4]      [,5]  [,6]    [,7]    </span>
<span class="co">#&gt; [1,] &quot;The&quot;   &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot;    &quot;on&quot;  &quot;the&quot;   &quot;smooth&quot;</span>
<span class="co">#&gt; [2,] &quot;Glue&quot;  &quot;the&quot;   &quot;sheet&quot; &quot;to&quot;      &quot;the&quot; &quot;dark&quot;  &quot;blue&quot;  </span>
<span class="co">#&gt; [3,] &quot;It&#39;s&quot;  &quot;easy&quot;  &quot;to&quot;    &quot;tell&quot;    &quot;the&quot; &quot;depth&quot; &quot;of&quot;    </span>
<span class="co">#&gt; [4,] &quot;These&quot; &quot;days&quot;  &quot;a&quot;     &quot;chicken&quot; &quot;leg&quot; &quot;is&quot;    &quot;a&quot;     </span>
<span class="co">#&gt; [5,] &quot;Rice&quot;  &quot;is&quot;    &quot;often&quot; &quot;served&quot;  &quot;in&quot;  &quot;round&quot; &quot;bowls.&quot;</span>
<span class="co">#&gt;      [,8]          [,9]   </span>
<span class="co">#&gt; [1,] &quot;planks.&quot;     &quot;&quot;     </span>
<span class="co">#&gt; [2,] &quot;background.&quot; &quot;&quot;     </span>
<span class="co">#&gt; [3,] &quot;a&quot;           &quot;well.&quot;</span>
<span class="co">#&gt; [4,] &quot;rare&quot;        &quot;dish.&quot;</span>
<span class="co">#&gt; [5,] &quot;&quot;            &quot;&quot;</span></code></pre>
<p>You can also request a maximum number of pieces:</p>
<pre class="sourceCode r"><code class="sourceCode r">fields &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Name: Hadley&quot;</span>, <span class="st">&quot;Country: NZ&quot;</span>, <span class="st">&quot;Age: 35&quot;</span>)
fields <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str_split</span>(<span class="st">&quot;: &quot;</span>, <span class="dt">n =</span> <span class="dv">2</span>, <span class="dt">simplify =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt;      [,1]      [,2]    </span>
<span class="co">#&gt; [1,] &quot;Name&quot;    &quot;Hadley&quot;</span>
<span class="co">#&gt; [2,] &quot;Country&quot; &quot;NZ&quot;    </span>
<span class="co">#&gt; [3,] &quot;Age&quot;     &quot;35&quot;</span></code></pre>
<p>Instead of splitting up strings by patterns, you can also split up by character, line, sentence and word <code>boundary()</code>s:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;This is a sentence.  This is another sentence.&quot;</span>
<span class="kw">str_view_all</span>(x, <span class="kw">boundary</span>(<span class="st">&quot;word&quot;</span>))</code></pre>
<div id="htmlwidget-fb37aa630b9d9968db84" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-fb37aa630b9d9968db84">{"x":{"html":"<ul>\n  <li><span class='match'>This<\/span> <span class='match'>is<\/span> <span class='match'>a<\/span> <span class='match'>sentence<\/span>.  <span class='match'>This<\/span> <span class='match'>is<\/span> <span class='match'>another<\/span> <span class='match'>sentence<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r">
<span class="kw">str_split</span>(x, <span class="st">&quot; &quot;</span>)[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] &quot;This&quot;      &quot;is&quot;        &quot;a&quot;         &quot;sentence.&quot; &quot;&quot;          &quot;This&quot;     </span>
<span class="co">#&gt; [7] &quot;is&quot;        &quot;another&quot;   &quot;sentence.&quot;</span>
<span class="kw">str_split</span>(x, <span class="kw">boundary</span>(<span class="st">&quot;word&quot;</span>))[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] &quot;This&quot;     &quot;is&quot;       &quot;a&quot;        &quot;sentence&quot; &quot;This&quot;     &quot;is&quot;      </span>
<span class="co">#&gt; [7] &quot;another&quot;  &quot;sentence&quot;</span></code></pre>
<div id="exercises-40" class="section level4">
<h4><span class="header-section-number">14.4.5.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li><p>Split up a string like <code>&quot;apples, pears, and bananas&quot;</code> into individual
components.</p></li>
<li><p>Why is it better to split up by <code>boundary(&quot;word&quot;)</code> than <code>&quot; &quot;</code>?</p></li>
<li><p>What does splitting with an empty string (<code>&quot;&quot;</code>) do? Experiment, and
then read the documentation.</p></li>
</ol>
</div>
</div>
<div id="find-matches" class="section level3">
<h3><span class="header-section-number">14.4.6</span> Find matches</h3>
<p><code>str_locate()</code> and <code>str_locate_all()</code> give you the starting and ending positions of each match. These are particularly useful when none of the other functions does exactly what you want. You can use <code>str_locate()</code> to find the matching pattern, <code>str_sub()</code> to extract and/or modify them.</p>
</div>
</div>
<div id="other-types-of-pattern" class="section level2">
<h2><span class="header-section-number">14.5</span> Other types of pattern</h2>
<p>When you use a pattern that’s a string, it’s automatically wrapped into a call to <code>regex()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># The regular call:</span>
<span class="kw">str_view</span>(fruit, <span class="st">&quot;nana&quot;</span>)
<span class="co"># Is shorthand for</span>
<span class="kw">str_view</span>(fruit, <span class="kw">regex</span>(<span class="st">&quot;nana&quot;</span>))</code></pre>
<p>You can use the other arguments of <code>regex()</code> to control details of the match:</p>
<ul>
<li><p><code>ignore_case = TRUE</code> allows characters to match either their uppercase or
lowercase forms. This always uses the current locale.</p>
<pre class="sourceCode r"><code class="sourceCode r">bananas &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;banana&quot;</span>, <span class="st">&quot;Banana&quot;</span>, <span class="st">&quot;BANANA&quot;</span>)
<span class="kw">str_view</span>(bananas, <span class="st">&quot;banana&quot;</span>)</code></pre>
<div id="htmlwidget-fa04ac5febadaac18a3d" style="width:960px;height:100%;" class="str_view html-widget"></div>
    <script type="application/json" data-for="htmlwidget-fa04ac5febadaac18a3d">{"x":{"html":"<ul>\n  <li><span class='match'>banana<\/span><\/li>\n  <li>Banana<\/li>\n  <li>BANANA<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_view</span>(bananas, <span class="kw">regex</span>(<span class="st">&quot;banana&quot;</span>, <span class="dt">ignore_case =</span> <span class="ot">TRUE</span>))</code></pre>
<div id="htmlwidget-826abaa365f54c0c9337" style="width:960px;height:100%;" class="str_view html-widget"></div>
    <script type="application/json" data-for="htmlwidget-826abaa365f54c0c9337">{"x":{"html":"<ul>\n  <li><span class='match'>banana<\/span><\/li>\n  <li><span class='match'>Banana<\/span><\/li>\n  <li><span class='match'>BANANA<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script></li>
<li><p><code>multiline = TRUE</code> allows <code>^</code> and <code>$</code> to match the start and end of each
line rather than the start and end of the complete string.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;Line 1</span><span class="ch">\n</span><span class="st">Line 2</span><span class="ch">\n</span><span class="st">Line 3&quot;</span>
<span class="kw">str_extract_all</span>(x, <span class="st">&quot;^Line&quot;</span>)[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] &quot;Line&quot;</span>
<span class="kw">str_extract_all</span>(x, <span class="kw">regex</span>(<span class="st">&quot;^Line&quot;</span>, <span class="dt">multiline =</span> <span class="ot">TRUE</span>))[[<span class="dv">1</span>]]
<span class="co">#&gt; [1] &quot;Line&quot; &quot;Line&quot; &quot;Line&quot;</span></code></pre></li>
<li><p><code>comments = TRUE</code> allows you to use comments and white space to make
complex regular expressions more understandable. Spaces are ignored, as is
everything after <code>#</code>. To match a literal space, you’ll need to escape it:
<code>&quot;\\ &quot;</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">phone &lt;-<span class="st"> </span><span class="kw">regex</span>(<span class="st">&quot;</span>
<span class="st">  </span><span class="ch">\\</span><span class="st">(?     # optional opening parens</span>
<span class="st">  (</span><span class="ch">\\</span><span class="st">d{3}) # area code</span>
<span class="st">  [) -]?   # optional closing parens, space, or dash</span>
<span class="st">  (</span><span class="ch">\\</span><span class="st">d{3}) # another three numbers</span>
<span class="st">  [ -]?    # optional space or dash</span>
<span class="st">  (</span><span class="ch">\\</span><span class="st">d{3}) # three more numbers</span>
<span class="st">  &quot;</span>, <span class="dt">comments =</span> <span class="ot">TRUE</span>)

<span class="kw">str_match</span>(<span class="st">&quot;514-791-8141&quot;</span>, phone)
<span class="co">#&gt;      [,1]          [,2]  [,3]  [,4] </span>
<span class="co">#&gt; [1,] &quot;514-791-814&quot; &quot;514&quot; &quot;791&quot; &quot;814&quot;</span></code></pre></li>
<li><p><code>dotall = TRUE</code> allows <code>.</code> to match everything, including <code>\n</code>.</p></li>
</ul>
<p>There are three other functions you can use instead of <code>regex()</code>:</p>
<ul>
<li><p><code>fixed()</code>: matches exactly the specified sequence of bytes. It ignores
all special regular expressions and operates at a very low level.
This allows you to avoid complex escaping and can be much faster than
regular expressions. The following microbenchmark shows that it’s about
3x faster for a simple example.</p>
<pre class="sourceCode r"><code class="sourceCode r">microbenchmark<span class="op">::</span><span class="kw">microbenchmark</span>(
  <span class="dt">fixed =</span> <span class="kw">str_detect</span>(sentences, <span class="kw">fixed</span>(<span class="st">&quot;the&quot;</span>)),
  <span class="dt">regex =</span> <span class="kw">str_detect</span>(sentences, <span class="st">&quot;the&quot;</span>),
  <span class="dt">times =</span> <span class="dv">20</span>
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;   expr   min    lq mean median  uq max neval</span>
<span class="co">#&gt;  fixed  84.7  87.5  113    101 116 330    20</span>
<span class="co">#&gt;  regex 349.5 359.8  386    365 380 690    20</span></code></pre>
<p>Beware using <code>fixed()</code> with non-English data. It is problematic because
there are often multiple ways of representing the same character. For
example, there are two ways to define “á”: either as a single character or
as an “a” plus an accent:</p>
<pre class="sourceCode r"><code class="sourceCode r">a1 &lt;-<span class="st"> &quot;\u00e1&quot;</span>
a2 &lt;-<span class="st"> &quot;a\u0301&quot;</span>
<span class="kw">c</span>(a1, a2)
<span class="co">#&gt; [1] &quot;á&quot; &quot;á&quot;</span>
a1 <span class="op">==</span><span class="st"> </span>a2
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>They render identically, but because they’re defined differently,
<code>fixed()</code> doesn’t find a match. Instead, you can use <code>coll()</code>, defined
next, to respect human character comparison rules:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_detect</span>(a1, <span class="kw">fixed</span>(a2))
<span class="co">#&gt; [1] FALSE</span>
<span class="kw">str_detect</span>(a1, <span class="kw">coll</span>(a2))
<span class="co">#&gt; [1] TRUE</span></code></pre></li>
<li><p><code>coll()</code>: compare strings using standard <strong>coll</strong>ation rules. This is
useful for doing case insensitive matching. Note that <code>coll()</code> takes a
<code>locale</code> parameter that controls which rules are used for comparing
characters. Unfortunately different parts of the world use different rules!</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># That means you also need to be aware of the difference</span>
<span class="co"># when doing case insensitive matches:</span>
i &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;I&quot;</span>, <span class="st">&quot;İ&quot;</span>, <span class="st">&quot;i&quot;</span>, <span class="st">&quot;ı&quot;</span>)
i
<span class="co">#&gt; [1] &quot;I&quot; &quot;İ&quot; &quot;i&quot; &quot;ı&quot;</span>

<span class="kw">str_subset</span>(i, <span class="kw">coll</span>(<span class="st">&quot;i&quot;</span>, <span class="dt">ignore_case =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; [1] &quot;I&quot; &quot;i&quot;</span>
<span class="kw">str_subset</span>(i, <span class="kw">coll</span>(<span class="st">&quot;i&quot;</span>, <span class="dt">ignore_case =</span> <span class="ot">TRUE</span>, <span class="dt">locale =</span> <span class="st">&quot;tr&quot;</span>))
<span class="co">#&gt; [1] &quot;İ&quot; &quot;i&quot;</span></code></pre>
<p>Both <code>fixed()</code> and <code>regex()</code> have <code>ignore_case</code> arguments, but they
do not allow you to pick the locale: they always use the default locale.
You can see what that is with the following code; more on stringi
later.</p>
<pre class="sourceCode r"><code class="sourceCode r">stringi<span class="op">::</span><span class="kw">stri_locale_info</span>()
<span class="co">#&gt; $Language</span>
<span class="co">#&gt; [1] &quot;en&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $Country</span>
<span class="co">#&gt; [1] &quot;US&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $Variant</span>
<span class="co">#&gt; [1] &quot;&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $Name</span>
<span class="co">#&gt; [1] &quot;en_US&quot;</span></code></pre>
<p>The downside of <code>coll()</code> is speed; because the rules for recognising which
characters are the same are complicated, <code>coll()</code> is relatively slow
compared to <code>regex()</code> and <code>fixed()</code>.</p></li>
<li><p>As you saw with <code>str_split()</code> you can use <code>boundary()</code> to match boundaries.
You can also use it with the other functions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;This is a sentence.&quot;</span>
<span class="kw">str_view_all</span>(x, <span class="kw">boundary</span>(<span class="st">&quot;word&quot;</span>))</code></pre>
<div id="htmlwidget-20f0cdc2888b18632cb0" style="width:960px;height:100%;" class="str_view html-widget"></div>
    <script type="application/json" data-for="htmlwidget-20f0cdc2888b18632cb0">{"x":{"html":"<ul>\n  <li><span class='match'>This<\/span> <span class='match'>is<\/span> <span class='match'>a<\/span> <span class='match'>sentence<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_extract_all</span>(x, <span class="kw">boundary</span>(<span class="st">&quot;word&quot;</span>))
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;This&quot;     &quot;is&quot;       &quot;a&quot;        &quot;sentence&quot;</span></code></pre></li>
</ul>
<div id="exercises-41" class="section level3">
<h3><span class="header-section-number">14.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How would you find all strings containing <code>\</code> with <code>regex()</code>
vs. with <code>fixed()</code>?</p></li>
<li><p>What are the five most common words in <code>sentences</code>?</p></li>
</ol>
</div>
</div>
<div id="other-uses-of-regular-expressions" class="section level2">
<h2><span class="header-section-number">14.6</span> Other uses of regular expressions</h2>
<p>There are two useful function in base R that also use regular expressions:</p>
<ul>
<li><p><code>apropos()</code> searches all objects available from the global environment. This
is useful if you can’t quite remember the name of the function.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">apropos</span>(<span class="st">&quot;replace&quot;</span>)
<span class="co">#&gt; [1] &quot;%+replace%&quot;       &quot;replace&quot;          &quot;replace_na&quot;      </span>
<span class="co">#&gt; [4] &quot;setReplaceMethod&quot; &quot;str_replace&quot;      &quot;str_replace_all&quot; </span>
<span class="co">#&gt; [7] &quot;str_replace_na&quot;   &quot;theme_replace&quot;</span></code></pre></li>
<li><p><code>dir()</code> lists all the files in a directory. The <code>pattern</code> argument takes
a regular expression and only returns file names that match the pattern.
For example, you can find all the R Markdown files in the current
directory with:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">dir</span>(<span class="dt">pattern =</span> <span class="st">&quot;</span><span class="ch">\\</span><span class="st">.Rmd$&quot;</span>))
<span class="co">#&gt; [1] &quot;communicate-plots.Rmd&quot; &quot;communicate.Rmd&quot;       &quot;datetimes.Rmd&quot;        </span>
<span class="co">#&gt; [4] &quot;EDA.Rmd&quot;               &quot;explore.Rmd&quot;           &quot;factors.Rmd&quot;</span></code></pre>
<p>(If you’re more comfortable with “globs” like <code>*.Rmd</code>, you can convert
them to regular expressions with <code>glob2rx()</code>):</p></li>
</ul>
</div>
<div id="stringi" class="section level2">
<h2><span class="header-section-number">14.7</span> stringi</h2>
<p>stringr is built on top of the <strong>stringi</strong> package. stringr is useful when you’re learning because it exposes a minimal set of functions, which have been carefully picked to handle the most common string manipulation functions. stringi, on the other hand, is designed to be comprehensive. It contains almost every function you might ever need: stringi has 234 functions to stringr’s 46.</p>
<p>If you find yourself struggling to do something in stringr, it’s worth taking a look at stringi. The packages work very similarly, so you should be able to translate your stringr knowledge in a natural way. The main difference is the prefix: <code>str_</code> vs. <code>stri_</code>.</p>
<div id="exercises-42" class="section level3">
<h3><span class="header-section-number">14.7.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Find the stringi functions that:</p>
<ol style="list-style-type: decimal">
<li>Count the number of words.</li>
<li>Find duplicated strings.</li>
<li>Generate random text.</li>
</ol></li>
<li><p>How do you control the language that <code>stri_sort()</code> uses for
sorting?</p></li>
</ol>
<!--chapter:end:strings.Rmd-->
</div>
</div>
</div>
<div id="factors" class="section level1">
<h1><span class="header-section-number">15</span> Factors</h1>
<div id="introduction-9" class="section level2">
<h2><span class="header-section-number">15.1</span> Introduction</h2>
<p>In R, factors are used to work with categorical variables, variables that have a fixed and known set of possible values. They are also useful when you want to display character vectors in a non-alphabetical order.</p>
<p>Historically, factors were much easier to work with than characters. As a result, many of the functions in base R automatically convert characters to factors. This means that factors often crop up in places where they’re not actually helpful. Fortunately, you don’t need to worry about that in the tidyverse, and can focus on situations where factors are genuinely useful.</p>
<div id="prerequisites-9" class="section level3">
<h3><span class="header-section-number">15.1.1</span> Prerequisites</h3>
<p>To work with factors, we’ll use the <strong>forcats</strong> package, which provides tools for dealing with <strong>cat</strong>egorical variables (and it’s an anagram of factors!). It provides a wide range of helpers for working with factors. forcats is not part of the core tidyverse, so we need to load it explicitly.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(forcats)</code></pre>
</div>
<div id="learning-more-1" class="section level3">
<h3><span class="header-section-number">15.1.2</span> Learning more</h3>
<p>If you want to learn more about factors, I recommend reading Amelia McNamara and Nicholas Horton’s paper, <em>Wrangling categorical data in R</em><span id="fn17" class="footnote" data-pagedown-footnote-number="17" style="white-space: pre-line;"><a href="https://peerj.com/preprints/3163/" class="uri">https://peerj.com/preprints/3163/</a></span>. This paper lays out some of the history discussed in <em>stringsAsFactors: An unauthorized biography</em><span id="fn18" class="footnote" data-pagedown-footnote-number="18" style="white-space: pre-line;"><a href="http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/" class="uri">http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/</a></span> and <em>stringsAsFactors = &lt;sigh&gt;</em><span id="fn19" class="footnote" data-pagedown-footnote-number="19" style="white-space: pre-line;"><a href="http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh" class="uri">http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh</a></span>, and compares the tidy approaches to categorical data outlined in this book with base R methods. A early version of the paper help motivate and scope the forcats package; thanks Amelia &amp; Nick!</p>
</div>
</div>
<div id="creating-factors" class="section level2">
<h2><span class="header-section-number">15.2</span> Creating factors</h2>
<p>Imagine that you have a variable that records month:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Dec&quot;</span>, <span class="st">&quot;Apr&quot;</span>, <span class="st">&quot;Jan&quot;</span>, <span class="st">&quot;Mar&quot;</span>)</code></pre>
<p>Using a string to record this variable has two problems:</p>
<ol style="list-style-type: decimal">
<li><p>There are only twelve possible months, and there’s nothing saving you
from typos:</p>
<pre class="sourceCode r"><code class="sourceCode r">x2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Dec&quot;</span>, <span class="st">&quot;Apr&quot;</span>, <span class="st">&quot;Jam&quot;</span>, <span class="st">&quot;Mar&quot;</span>)</code></pre></li>
<li><p>It doesn’t sort in a useful way:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sort</span>(x1)
<span class="co">#&gt; [1] &quot;Apr&quot; &quot;Dec&quot; &quot;Jan&quot; &quot;Mar&quot;</span></code></pre></li>
</ol>
<p>You can fix both of these problems with a factor. To create a factor you must start by creating a list of the valid <strong>levels</strong>:</p>
<pre class="sourceCode r"><code class="sourceCode r">month_levels &lt;-<span class="st"> </span><span class="kw">c</span>(
  <span class="st">&quot;Jan&quot;</span>, <span class="st">&quot;Feb&quot;</span>, <span class="st">&quot;Mar&quot;</span>, <span class="st">&quot;Apr&quot;</span>, <span class="st">&quot;May&quot;</span>, <span class="st">&quot;Jun&quot;</span>, 
  <span class="st">&quot;Jul&quot;</span>, <span class="st">&quot;Aug&quot;</span>, <span class="st">&quot;Sep&quot;</span>, <span class="st">&quot;Oct&quot;</span>, <span class="st">&quot;Nov&quot;</span>, <span class="st">&quot;Dec&quot;</span>
)</code></pre>
<p>Now you can create a factor:</p>
<pre class="sourceCode r"><code class="sourceCode r">y1 &lt;-<span class="st"> </span><span class="kw">factor</span>(x1, <span class="dt">levels =</span> month_levels)
y1
<span class="co">#&gt; [1] Dec Apr Jan Mar</span>
<span class="co">#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</span>
<span class="kw">sort</span>(y1)
<span class="co">#&gt; [1] Jan Mar Apr Dec</span>
<span class="co">#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</span></code></pre>
<p>And any values not in the set will be silently converted to NA:</p>
<pre class="sourceCode r"><code class="sourceCode r">y2 &lt;-<span class="st"> </span><span class="kw">factor</span>(x2, <span class="dt">levels =</span> month_levels)
y2
<span class="co">#&gt; [1] Dec  Apr  &lt;NA&gt; Mar </span>
<span class="co">#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</span></code></pre>
<p>If you want a warning, you can use <code>readr::parse_factor()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">y2 &lt;-<span class="st"> </span><span class="kw">parse_factor</span>(x2, <span class="dt">levels =</span> month_levels)
<span class="co">#&gt; Warning: 1 parsing failure.</span>
<span class="co">#&gt; row col           expected actual</span>
<span class="co">#&gt;   3  -- value in level set    Jam</span></code></pre>
<p>If you omit the levels, they’ll be taken from the data in alphabetical order:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">factor</span>(x1)
<span class="co">#&gt; [1] Dec Apr Jan Mar</span>
<span class="co">#&gt; Levels: Apr Dec Jan Mar</span></code></pre>
<p>Sometimes you’d prefer that the order of the levels match the order of the first appearance in the data. You can do that when creating the factor by setting levels to <code>unique(x)</code>, or after the fact, with <code>fct_inorder()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="kw">factor</span>(x1, <span class="dt">levels =</span> <span class="kw">unique</span>(x1))
f1
<span class="co">#&gt; [1] Dec Apr Jan Mar</span>
<span class="co">#&gt; Levels: Dec Apr Jan Mar</span>

f2 &lt;-<span class="st"> </span>x1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">factor</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">fct_inorder</span>()
f2
<span class="co">#&gt; [1] Dec Apr Jan Mar</span>
<span class="co">#&gt; Levels: Dec Apr Jan Mar</span></code></pre>
<p>If you ever need to access the set of valid levels directly, you can do so with <code>levels()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(f2)
<span class="co">#&gt; [1] &quot;Dec&quot; &quot;Apr&quot; &quot;Jan&quot; &quot;Mar&quot;</span></code></pre>
</div>
<div id="general-social-survey" class="section level2">
<h2><span class="header-section-number">15.3</span> General Social Survey</h2>
<p>For the rest of this chapter, we’re going to focus on <code>forcats::gss_cat</code>. It’s a sample of data from the General Social Survey<span id="fn20" class="footnote" data-pagedown-footnote-number="20" style="white-space: pre-line;"><a href="http://gss.norc.org" class="uri">http://gss.norc.org</a></span>, which is a long-running US survey conducted by the independent research organization NORC at the University of Chicago. The survey has thousands of questions, so in <code>gss_cat</code> I’ve selected a handful that will illustrate some common challenges you’ll encounter when working with factors.</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat
<span class="co">#&gt; # A tibble: 21,483 x 9</span>
<span class="co">#&gt;    year marital     age race  rincome   partyid    relig    denom   tvhours</span>
<span class="co">#&gt;   &lt;int&gt; &lt;fct&gt;     &lt;int&gt; &lt;fct&gt; &lt;fct&gt;     &lt;fct&gt;      &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1  2000 Never ma…    26 White $8000 to… Ind,near … Protest… Southe…      12</span>
<span class="co">#&gt; 2  2000 Divorced     48 White $8000 to… Not str r… Protest… Baptis…      NA</span>
<span class="co">#&gt; 3  2000 Widowed      67 White Not appl… Independe… Protest… No den…       2</span>
<span class="co">#&gt; 4  2000 Never ma…    39 White Not appl… Ind,near … Orthodo… Not ap…       4</span>
<span class="co">#&gt; 5  2000 Divorced     25 White Not appl… Not str d… None     Not ap…       1</span>
<span class="co">#&gt; 6  2000 Married      25 White $20000 -… Strong de… Protest… Southe…      NA</span>
<span class="co">#&gt; # … with 2.148e+04 more rows</span></code></pre>
<p>(Remember, since this dataset is provided by a package, you can get more information about the variables with <code>?gss_cat</code>.)</p>
<p>When factors are stored in a tibble, you can’t see their levels so easily. One way to see them is with <code>count()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(race)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   race      n</span>
<span class="co">#&gt;   &lt;fct&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 Other  1959</span>
<span class="co">#&gt; 2 Black  3129</span>
<span class="co">#&gt; 3 White 16395</span></code></pre>
<p>Or with a bar chart:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(gss_cat, <span class="kw">aes</span>(race)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>By default, ggplot2 will drop levels that don’t have any values. You can force them to display with:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(gss_cat, <span class="kw">aes</span>(race)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_discrete</span>(<span class="dt">drop =</span> <span class="ot">FALSE</span>)</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>These levels represent valid values that simply did not occur in this dataset. Unfortunately, dplyr doesn’t yet have a <code>drop</code> option, but it will in the future.</p>
<p>When working with factors, the two most common operations are changing the order of the levels, and changing the values of the levels. Those operations are described in the sections below.</p>
<div id="exercise" class="section level3">
<h3><span class="header-section-number">15.3.1</span> Exercise</h3>
<ol style="list-style-type: decimal">
<li><p>Explore the distribution of <code>rincome</code> (reported income). What makes the
default bar chart hard to understand? How could you improve the plot?</p></li>
<li><p>What is the most common <code>relig</code> in this survey? What’s the most
common <code>partyid</code>?</p></li>
<li><p>Which <code>relig</code> does <code>denom</code> (denomination) apply to? How can you find
out with a table? How can you find out with a visualisation?</p></li>
</ol>
</div>
</div>
<div id="modifying-factor-order" class="section level2">
<h2><span class="header-section-number">15.4</span> Modifying factor order</h2>
<p>It’s often useful to change the order of the factor levels in a visualisation. For example, imagine you want to explore the average number of hours spent watching TV per day across religions:</p>
<pre class="sourceCode r"><code class="sourceCode r">relig_summary &lt;-<span class="st"> </span>gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(relig) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">age =</span> <span class="kw">mean</span>(age, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">tvhours =</span> <span class="kw">mean</span>(tvhours, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">n =</span> <span class="kw">n</span>()
  )

<span class="kw">ggplot</span>(relig_summary, <span class="kw">aes</span>(tvhours, relig)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It is difficult to interpret this plot because there’s no overall pattern. We can improve it by reordering the levels of <code>relig</code> using <code>fct_reorder()</code>. <code>fct_reorder()</code> takes three arguments:</p>
<ul>
<li><code>f</code>, the factor whose levels you want to modify.</li>
<li><code>x</code>, a numeric vector that you want to use to reorder the levels.</li>
<li>Optionally, <code>fun</code>, a function that’s used if there are multiple values of
<code>x</code> for each value of <code>f</code>. The default value is <code>median</code>.</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(relig_summary, <span class="kw">aes</span>(tvhours, <span class="kw">fct_reorder</span>(relig, tvhours))) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Reordering religion makes it much easier to see that people in the “Don’t know” category watch much more TV, and Hinduism &amp; Other Eastern religions watch much less.</p>
<p>As you start making more complicated transformations, I’d recommend moving them out of <code>aes()</code> and into a separate <code>mutate()</code> step. For example, you could rewrite the plot above as:</p>
<pre class="sourceCode r"><code class="sourceCode r">relig_summary <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">relig =</span> <span class="kw">fct_reorder</span>(relig, tvhours)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(tvhours, relig)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>()</code></pre>
<p>What if we create a similar plot looking at how average age varies across reported income level?</p>
<pre class="sourceCode r"><code class="sourceCode r">rincome_summary &lt;-<span class="st"> </span>gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(rincome) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">age =</span> <span class="kw">mean</span>(age, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">tvhours =</span> <span class="kw">mean</span>(tvhours, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">n =</span> <span class="kw">n</span>()
  )

<span class="kw">ggplot</span>(rincome_summary, <span class="kw">aes</span>(age, <span class="kw">fct_reorder</span>(rincome, age))) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Here, arbitrarily reordering the levels isn’t a good idea! That’s because <code>rincome</code> already has a principled order that we shouldn’t mess with. Reserve <code>fct_reorder()</code> for factors whose levels are arbitrarily ordered.</p>
<p>However, it does make sense to pull “Not applicable” to the front with the other special levels. You can use <code>fct_relevel()</code>. It takes a factor, <code>f</code>, and then any number of levels that you want to move to the front of the line.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(rincome_summary, <span class="kw">aes</span>(age, <span class="kw">fct_relevel</span>(rincome, <span class="st">&quot;Not applicable&quot;</span>))) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Why do you think the average age for “Not applicable” is so high?</p>
<p>Another type of reordering is useful when you are colouring the lines on a plot. <code>fct_reorder2()</code> reorders the factor by the <code>y</code> values associated with the largest <code>x</code> values. This makes the plot easier to read because the line colours line up with the legend.</p>
<pre class="sourceCode r"><code class="sourceCode r">by_age &lt;-<span class="st"> </span>gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(age)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(age, marital) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(age) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">prop =</span> n <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(n))

<span class="kw">ggplot</span>(by_age, <span class="kw">aes</span>(age, prop, <span class="dt">colour =</span> marital)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

<span class="kw">ggplot</span>(by_age, <span class="kw">aes</span>(age, prop, <span class="dt">colour =</span> <span class="kw">fct_reorder2</span>(marital, age, prop))) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">colour =</span> <span class="st">&quot;marital&quot;</span>)</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-21-1.png" width="50%" /><img src="factors_files/figure-html/unnamed-chunk-21-2.png" width="50%" /></p>
<p>Finally, for bar plots, you can use <code>fct_infreq()</code> to order levels in increasing frequency: this is the simplest type of reordering because it doesn’t need any extra variables. You may want to combine with <code>fct_rev()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">marital =</span> marital <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">fct_infreq</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">fct_rev</span>()) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(marital)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_bar</span>()</code></pre>
<p><img src="factors_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="exercises-43" class="section level3">
<h3><span class="header-section-number">15.4.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>There are some suspiciously high numbers in <code>tvhours</code>. Is the mean a good
summary?</p></li>
<li><p>For each factor in <code>gss_cat</code> identify whether the order of the levels is
arbitrary or principled.</p></li>
<li><p>Why did moving “Not applicable” to the front of the levels move it to the
bottom of the plot?</p></li>
</ol>
</div>
</div>
<div id="modifying-factor-levels" class="section level2">
<h2><span class="header-section-number">15.5</span> Modifying factor levels</h2>
<p>More powerful than changing the orders of the levels is changing their values. This allows you to clarify labels for publication, and collapse levels for high-level displays. The most general and powerful tool is <code>fct_recode()</code>. It allows you to recode, or change, the value of each level. For example, take the <code>gss_cat$partyid</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">count</span>(partyid)
<span class="co">#&gt; # A tibble: 10 x 2</span>
<span class="co">#&gt;   partyid                n</span>
<span class="co">#&gt;   &lt;fct&gt;              &lt;int&gt;</span>
<span class="co">#&gt; 1 No answer            154</span>
<span class="co">#&gt; 2 Don&#39;t know             1</span>
<span class="co">#&gt; 3 Other party          393</span>
<span class="co">#&gt; 4 Strong republican   2314</span>
<span class="co">#&gt; 5 Not str republican  3032</span>
<span class="co">#&gt; 6 Ind,near rep        1791</span>
<span class="co">#&gt; # … with 4 more rows</span></code></pre>
<p>The levels are terse and inconsistent. Let’s tweak them to be longer and use a parallel construction.</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">partyid =</span> <span class="kw">fct_recode</span>(partyid,
    <span class="st">&quot;Republican, strong&quot;</span>    =<span class="st"> &quot;Strong republican&quot;</span>,
    <span class="st">&quot;Republican, weak&quot;</span>      =<span class="st"> &quot;Not str republican&quot;</span>,
    <span class="st">&quot;Independent, near rep&quot;</span> =<span class="st"> &quot;Ind,near rep&quot;</span>,
    <span class="st">&quot;Independent, near dem&quot;</span> =<span class="st"> &quot;Ind,near dem&quot;</span>,
    <span class="st">&quot;Democrat, weak&quot;</span>        =<span class="st"> &quot;Not str democrat&quot;</span>,
    <span class="st">&quot;Democrat, strong&quot;</span>      =<span class="st"> &quot;Strong democrat&quot;</span>
  )) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(partyid)
<span class="co">#&gt; # A tibble: 10 x 2</span>
<span class="co">#&gt;   partyid                   n</span>
<span class="co">#&gt;   &lt;fct&gt;                 &lt;int&gt;</span>
<span class="co">#&gt; 1 No answer               154</span>
<span class="co">#&gt; 2 Don&#39;t know                1</span>
<span class="co">#&gt; 3 Other party             393</span>
<span class="co">#&gt; 4 Republican, strong     2314</span>
<span class="co">#&gt; 5 Republican, weak       3032</span>
<span class="co">#&gt; 6 Independent, near rep  1791</span>
<span class="co">#&gt; # … with 4 more rows</span></code></pre>
<p><code>fct_recode()</code> will leave levels that aren’t explicitly mentioned as is, and will warn you if you accidentally refer to a level that doesn’t exist.</p>
<p>To combine groups, you can assign multiple old levels to the same new level:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">partyid =</span> <span class="kw">fct_recode</span>(partyid,
    <span class="st">&quot;Republican, strong&quot;</span>    =<span class="st"> &quot;Strong republican&quot;</span>,
    <span class="st">&quot;Republican, weak&quot;</span>      =<span class="st"> &quot;Not str republican&quot;</span>,
    <span class="st">&quot;Independent, near rep&quot;</span> =<span class="st"> &quot;Ind,near rep&quot;</span>,
    <span class="st">&quot;Independent, near dem&quot;</span> =<span class="st"> &quot;Ind,near dem&quot;</span>,
    <span class="st">&quot;Democrat, weak&quot;</span>        =<span class="st"> &quot;Not str democrat&quot;</span>,
    <span class="st">&quot;Democrat, strong&quot;</span>      =<span class="st"> &quot;Strong democrat&quot;</span>,
    <span class="st">&quot;Other&quot;</span>                 =<span class="st"> &quot;No answer&quot;</span>,
    <span class="st">&quot;Other&quot;</span>                 =<span class="st"> &quot;Don&#39;t know&quot;</span>,
    <span class="st">&quot;Other&quot;</span>                 =<span class="st"> &quot;Other party&quot;</span>
  )) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(partyid)
<span class="co">#&gt; # A tibble: 8 x 2</span>
<span class="co">#&gt;   partyid                   n</span>
<span class="co">#&gt;   &lt;fct&gt;                 &lt;int&gt;</span>
<span class="co">#&gt; 1 Other                   548</span>
<span class="co">#&gt; 2 Republican, strong     2314</span>
<span class="co">#&gt; 3 Republican, weak       3032</span>
<span class="co">#&gt; 4 Independent, near rep  1791</span>
<span class="co">#&gt; 5 Independent            4119</span>
<span class="co">#&gt; 6 Independent, near dem  2499</span>
<span class="co">#&gt; # … with 2 more rows</span></code></pre>
<p>You must use this technique with care: if you group together categories that are truly different you will end up with misleading results.</p>
<p>If you want to collapse a lot of levels, <code>fct_collapse()</code> is a useful variant of <code>fct_recode()</code>. For each new variable, you can provide a vector of old levels:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">partyid =</span> <span class="kw">fct_collapse</span>(partyid,
    <span class="dt">other =</span> <span class="kw">c</span>(<span class="st">&quot;No answer&quot;</span>, <span class="st">&quot;Don&#39;t know&quot;</span>, <span class="st">&quot;Other party&quot;</span>),
    <span class="dt">rep =</span> <span class="kw">c</span>(<span class="st">&quot;Strong republican&quot;</span>, <span class="st">&quot;Not str republican&quot;</span>),
    <span class="dt">ind =</span> <span class="kw">c</span>(<span class="st">&quot;Ind,near rep&quot;</span>, <span class="st">&quot;Independent&quot;</span>, <span class="st">&quot;Ind,near dem&quot;</span>),
    <span class="dt">dem =</span> <span class="kw">c</span>(<span class="st">&quot;Not str democrat&quot;</span>, <span class="st">&quot;Strong democrat&quot;</span>)
  )) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(partyid)
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;   partyid     n</span>
<span class="co">#&gt;   &lt;fct&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1 other     548</span>
<span class="co">#&gt; 2 rep      5346</span>
<span class="co">#&gt; 3 ind      8409</span>
<span class="co">#&gt; 4 dem      7180</span></code></pre>
<p>Sometimes you just want to lump together all the small groups to make a plot or table simpler. That’s the job of <code>fct_lump()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">relig =</span> <span class="kw">fct_lump</span>(relig)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(relig)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   relig          n</span>
<span class="co">#&gt;   &lt;fct&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 Protestant 10846</span>
<span class="co">#&gt; 2 Other      10637</span></code></pre>
<p>The default behaviour is to progressively lump together the smallest groups, ensuring that the aggregate is still the smallest group. In this case it’s not very helpful: it is true that the majority of Americans in this survey are Protestant, but we’ve probably over collapsed.</p>
<p>Instead, we can use the <code>n</code> parameter to specify how many groups (excluding other) we want to keep:</p>
<pre class="sourceCode r"><code class="sourceCode r">gss_cat <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">relig =</span> <span class="kw">fct_lump</span>(relig, <span class="dt">n =</span> <span class="dv">10</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">count</span>(relig, <span class="dt">sort =</span> <span class="ot">TRUE</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">print</span>(<span class="dt">n =</span> <span class="ot">Inf</span>)
<span class="co">#&gt; # A tibble: 10 x 2</span>
<span class="co">#&gt;    relig                       n</span>
<span class="co">#&gt;    &lt;fct&gt;                   &lt;int&gt;</span>
<span class="co">#&gt;  1 Protestant              10846</span>
<span class="co">#&gt;  2 Catholic                 5124</span>
<span class="co">#&gt;  3 None                     3523</span>
<span class="co">#&gt;  4 Christian                 689</span>
<span class="co">#&gt;  5 Other                     458</span>
<span class="co">#&gt;  6 Jewish                    388</span>
<span class="co">#&gt;  7 Buddhism                  147</span>
<span class="co">#&gt;  8 Inter-nondenominational   109</span>
<span class="co">#&gt;  9 Moslem/islam              104</span>
<span class="co">#&gt; 10 Orthodox-christian         95</span></code></pre>
<div id="exercises-44" class="section level3">
<h3><span class="header-section-number">15.5.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How have the proportions of people identifying as Democrat, Republican, and
Independent changed over time?</p></li>
<li><p>How could you collapse <code>rincome</code> into a small set of categories?</p></li>
</ol>
<!--chapter:end:factors.Rmd-->
</div>
</div>
</div>
<div id="dates-and-times" class="section level1">
<h1><span class="header-section-number">16</span> Dates and times</h1>
<div id="introduction-10" class="section level2">
<h2><span class="header-section-number">16.1</span> Introduction</h2>
<p>This chapter will show you how to work with dates and times in R. At first glance, dates and times seem simple. You use them all the time in your regular life, and they don’t seem to cause much confusion. However, the more you learn about dates and times, the more complicated they seem to get. To warm up, try these three seemingly simple questions:</p>
<ul>
<li>Does every year have 365 days?</li>
<li>Does every day have 24 hours?</li>
<li>Does every minute have 60 seconds?</li>
</ul>
<p>I’m sure you know that not every year has 365 days, but do you know the full rule for determining if a year is a leap year? (It has three parts.) You might have remembered that many parts of the world use daylight savings time (DST), so that some days have 23 hours, and others have 25. You might not have known that some minutes have 61 seconds because every now and then leap seconds are added because the Earth’s rotation is gradually slowing down.</p>
<p>Dates and times are hard because they have to reconcile two physical phenomena (the rotation of the Earth and its orbit around the sun) with a whole raft of geopolitical phenomena including months, time zones, and DST. This chapter won’t teach you every last detail about dates and times, but it will give you a solid grounding of practical skills that will help you with common data analysis challenges.</p>
<div id="prerequisites-10" class="section level3">
<h3><span class="header-section-number">16.1.1</span> Prerequisites</h3>
<p>This chapter will focus on the <strong>lubridate</strong> package, which makes it easier to work with dates and times in R. lubridate is not part of core tidyverse because you only need it when you’re working with dates/times. We will also need nycflights13 for practice data.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)

<span class="kw">library</span>(lubridate)
<span class="kw">library</span>(nycflights13)</code></pre>
</div>
</div>
<div id="creating-datetimes" class="section level2">
<h2><span class="header-section-number">16.2</span> Creating date/times</h2>
<p>There are three types of date/time data that refer to an instant in time:</p>
<ul>
<li><p>A <strong>date</strong>. Tibbles print this as <code>&lt;date&gt;</code>.</p></li>
<li><p>A <strong>time</strong> within a day. Tibbles print this as <code>&lt;time&gt;</code>.</p></li>
<li><p>A <strong>date-time</strong> is a date plus a time: it uniquely identifies an
instant in time (typically to the nearest second). Tibbles print this
as <code>&lt;dttm&gt;</code>. Elsewhere in R these are called POSIXct, but I don’t think
that’s a very useful name.</p></li>
</ul>
<p>In this chapter we are only going to focus on dates and date-times as R doesn’t have a native class for storing times. If you need one, you can use the <strong>hms</strong> package.</p>
<p>You should always use the simplest possible data type that works for your needs. That means if you can use a date instead of a date-time, you should. Date-times are substantially more complicated because of the need to handle time zones, which we’ll come back to at the end of the chapter.</p>
<p>To get the current date or date-time you can use <code>today()</code> or <code>now()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">today</span>()
<span class="co">#&gt; [1] &quot;2019-01-24&quot;</span>
<span class="kw">now</span>()
<span class="co">#&gt; [1] &quot;2019-01-24 15:19:02 CST&quot;</span></code></pre>
<p>Otherwise, there are three ways you’re likely to create a date/time:</p>
<ul>
<li>From a string.</li>
<li>From individual date-time components.</li>
<li>From an existing date/time object.</li>
</ul>
<p>They work as follows.</p>
<div id="from-strings" class="section level3">
<h3><span class="header-section-number">16.2.1</span> From strings</h3>
<p>Date/time data often comes as strings. You’ve seen one approach to parsing strings into date-times in <a href="#readr-datetimes">date-times</a>. Another approach is to use the helpers provided by lubridate. They automatically work out the format once you specify the order of the component. To use them, identify the order in which year, month, and day appear in your dates, then arrange “y”, “m”, and “d” in the same order. That gives you the name of the lubridate function that will parse your date. For example:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd</span>(<span class="st">&quot;2017-01-31&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31&quot;</span>
<span class="kw">mdy</span>(<span class="st">&quot;January 31st, 2017&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31&quot;</span>
<span class="kw">dmy</span>(<span class="st">&quot;31-Jan-2017&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31&quot;</span></code></pre>
<p>These functions also take unquoted numbers. This is the most concise way to create a single date/time object, as you might need when filtering date/time data. <code>ymd()</code> is short and unambiguous:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd</span>(<span class="dv">20170131</span>)
<span class="co">#&gt; [1] &quot;2017-01-31&quot;</span></code></pre>
<p><code>ymd()</code> and friends create dates. To create a date-time, add an underscore and one or more of “h”, “m”, and “s” to the name of the parsing function:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd_hms</span>(<span class="st">&quot;2017-01-31 20:11:59&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31 20:11:59 UTC&quot;</span>
<span class="kw">mdy_hm</span>(<span class="st">&quot;01/31/2017 08:01&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31 08:01:00 UTC&quot;</span></code></pre>
<p>You can also force the creation of a date-time from a date by supplying a timezone:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd</span>(<span class="dv">20170131</span>, <span class="dt">tz =</span> <span class="st">&quot;UTC&quot;</span>)
<span class="co">#&gt; [1] &quot;2017-01-31 UTC&quot;</span></code></pre>
</div>
<div id="from-individual-components" class="section level3">
<h3><span class="header-section-number">16.2.2</span> From individual components</h3>
<p>Instead of a single string, sometimes you’ll have the individual components of the date-time spread across multiple columns. This is what we have in the flights data:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(year, month, day, hour, minute)
<span class="co">#&gt; # A tibble: 336,776 x 5</span>
<span class="co">#&gt;    year month   day  hour minute</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1  2013     1     1     5     15</span>
<span class="co">#&gt; 2  2013     1     1     5     29</span>
<span class="co">#&gt; 3  2013     1     1     5     40</span>
<span class="co">#&gt; 4  2013     1     1     5     45</span>
<span class="co">#&gt; 5  2013     1     1     6      0</span>
<span class="co">#&gt; 6  2013     1     1     5     58</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>To create a date/time from this sort of input, use <code>make_date()</code> for dates, or <code>make_datetime()</code> for date-times:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(year, month, day, hour, minute) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">departure =</span> <span class="kw">make_datetime</span>(year, month, day, hour, minute))
<span class="co">#&gt; # A tibble: 336,776 x 6</span>
<span class="co">#&gt;    year month   day  hour minute departure          </span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             </span>
<span class="co">#&gt; 1  2013     1     1     5     15 2013-01-01 05:15:00</span>
<span class="co">#&gt; 2  2013     1     1     5     29 2013-01-01 05:29:00</span>
<span class="co">#&gt; 3  2013     1     1     5     40 2013-01-01 05:40:00</span>
<span class="co">#&gt; 4  2013     1     1     5     45 2013-01-01 05:45:00</span>
<span class="co">#&gt; 5  2013     1     1     6      0 2013-01-01 06:00:00</span>
<span class="co">#&gt; 6  2013     1     1     5     58 2013-01-01 05:58:00</span>
<span class="co">#&gt; # … with 3.368e+05 more rows</span></code></pre>
<p>Let’s do the same thing for each of the four time columns in <code>flights</code>. The times are represented in a slightly odd format, so we use modulus arithmetic to pull out the hour and minute components. Once I’ve created the date-time variables, I focus in on the variables we’ll explore in the rest of the chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r">make_datetime_<span class="dv">100</span> &lt;-<span class="st"> </span><span class="cf">function</span>(year, month, day, time) {
  <span class="kw">make_datetime</span>(year, month, day, time <span class="op">%/%</span><span class="st"> </span><span class="dv">100</span>, time <span class="op">%%</span><span class="st"> </span><span class="dv">100</span>)
}

flights_dt &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="op">!</span><span class="kw">is.na</span>(dep_time), <span class="op">!</span><span class="kw">is.na</span>(arr_time)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">dep_time =</span> <span class="kw">make_datetime_100</span>(year, month, day, dep_time),
    <span class="dt">arr_time =</span> <span class="kw">make_datetime_100</span>(year, month, day, arr_time),
    <span class="dt">sched_dep_time =</span> <span class="kw">make_datetime_100</span>(year, month, day, sched_dep_time),
    <span class="dt">sched_arr_time =</span> <span class="kw">make_datetime_100</span>(year, month, day, sched_arr_time)
  ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(origin, dest, <span class="kw">ends_with</span>(<span class="st">&quot;delay&quot;</span>), <span class="kw">ends_with</span>(<span class="st">&quot;time&quot;</span>))

flights_dt
<span class="co">#&gt; # A tibble: 328,063 x 9</span>
<span class="co">#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     </span>
<span class="co">#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             </span>
<span class="co">#&gt; 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00</span>
<span class="co">#&gt; 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00</span>
<span class="co">#&gt; 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00</span>
<span class="co">#&gt; 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00</span>
<span class="co">#&gt; 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00</span>
<span class="co">#&gt; 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00</span>
<span class="co">#&gt; # … with 3.281e+05 more rows, and 3 more variables: arr_time &lt;dttm&gt;,</span>
<span class="co">#&gt; #   sched_arr_time &lt;dttm&gt;, air_time &lt;dbl&gt;</span></code></pre>
<p>With this data, I can visualise the distribution of departure times across the year:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(dep_time)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="dv">86400</span>) <span class="co"># 86400 seconds = 1 day</span></code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Or within a single day:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(dep_time <span class="op">&lt;</span><span class="st"> </span><span class="kw">ymd</span>(<span class="dv">20130102</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(dep_time)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="dv">600</span>) <span class="co"># 600 s = 10 minutes</span></code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note that when you use date-times in a numeric context (like in a histogram), 1 means 1 second, so a binwidth of 86400 means one day. For dates, 1 means 1 day.</p>
</div>
<div id="from-other-types" class="section level3">
<h3><span class="header-section-number">16.2.3</span> From other types</h3>
<p>You may want to switch between a date-time and a date. That’s the job of <code>as_datetime()</code> and <code>as_date()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_datetime</span>(<span class="kw">today</span>())
<span class="co">#&gt; [1] &quot;2019-01-24 UTC&quot;</span>
<span class="kw">as_date</span>(<span class="kw">now</span>())
<span class="co">#&gt; [1] &quot;2019-01-24&quot;</span></code></pre>
<p>Sometimes you’ll get date/times as numeric offsets from the “Unix Epoch”, 1970-01-01. If the offset is in seconds, use <code>as_datetime()</code>; if it’s in days, use <code>as_date()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as_datetime</span>(<span class="dv">60</span> <span class="op">*</span><span class="st"> </span><span class="dv">60</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;1970-01-01 10:00:00 UTC&quot;</span>
<span class="kw">as_date</span>(<span class="dv">365</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>)
<span class="co">#&gt; [1] &quot;1980-01-01&quot;</span></code></pre>
</div>
<div id="exercises-45" class="section level3">
<h3><span class="header-section-number">16.2.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What happens if you parse a string that contains invalid dates?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd</span>(<span class="kw">c</span>(<span class="st">&quot;2010-10-10&quot;</span>, <span class="st">&quot;bananas&quot;</span>))</code></pre></li>
<li><p>What does the <code>tzone</code> argument to <code>today()</code> do? Why is it important?</p></li>
<li><p>Use the appropriate lubridate function to parse each of the following dates:</p>
<pre class="sourceCode r"><code class="sourceCode r">d1 &lt;-<span class="st"> &quot;January 1, 2010&quot;</span>
d2 &lt;-<span class="st"> &quot;2015-Mar-07&quot;</span>
d3 &lt;-<span class="st"> &quot;06-Jun-2017&quot;</span>
d4 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;August 19 (2015)&quot;</span>, <span class="st">&quot;July 1 (2015)&quot;</span>)
d5 &lt;-<span class="st"> &quot;12/30/14&quot;</span> <span class="co"># Dec 30, 2014</span></code></pre></li>
</ol>
</div>
</div>
<div id="date-time-components" class="section level2">
<h2><span class="header-section-number">16.3</span> Date-time components</h2>
<p>Now that you know how to get date-time data into R’s date-time data structures, let’s explore what you can do with them. This section will focus on the accessor functions that let you get and set individual components. The next section will look at how arithmetic works with date-times.</p>
<div id="getting-components" class="section level3">
<h3><span class="header-section-number">16.3.1</span> Getting components</h3>
<p>You can pull out individual parts of the date with the accessor functions <code>year()</code>, <code>month()</code>, <code>mday()</code> (day of the month), <code>yday()</code> (day of the year), <code>wday()</code> (day of the week), <code>hour()</code>, <code>minute()</code>, and <code>second()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">datetime &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2016-07-08 12:34:56&quot;</span>)

<span class="kw">year</span>(datetime)
<span class="co">#&gt; [1] 2016</span>
<span class="kw">month</span>(datetime)
<span class="co">#&gt; [1] 7</span>
<span class="kw">mday</span>(datetime)
<span class="co">#&gt; [1] 8</span>

<span class="kw">yday</span>(datetime)
<span class="co">#&gt; [1] 190</span>
<span class="kw">wday</span>(datetime)
<span class="co">#&gt; [1] 6</span></code></pre>
<p>For <code>month()</code> and <code>wday()</code> you can set <code>label = TRUE</code> to return the abbreviated name of the month or day of the week. Set <code>abbr = FALSE</code> to return the full name.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">month</span>(datetime, <span class="dt">label =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] Jul</span>
<span class="co">#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec</span>
<span class="kw">wday</span>(datetime, <span class="dt">label =</span> <span class="ot">TRUE</span>, <span class="dt">abbr =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; [1] Friday</span>
<span class="co">#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday</span></code></pre>
<p>We can use <code>wday()</code> to see that more flights depart during the week than on the weekend:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wday =</span> <span class="kw">wday</span>(dep_time, <span class="dt">label =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> wday)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_bar</span>()</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There’s an interesting pattern if we look at the average departure delay by minute within the hour. It looks like flights leaving in minutes 20-30 and 50-60 have much lower delays than the rest of the hour!</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">minute =</span> <span class="kw">minute</span>(dep_time)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(minute) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">avg_delay =</span> <span class="kw">mean</span>(arr_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">n =</span> <span class="kw">n</span>()) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(minute, avg_delay)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Interestingly, if we look at the <em>scheduled</em> departure time we don’t see such a strong pattern:</p>
<pre class="sourceCode r"><code class="sourceCode r">sched_dep &lt;-<span class="st"> </span>flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">minute =</span> <span class="kw">minute</span>(sched_dep_time)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(minute) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">avg_delay =</span> <span class="kw">mean</span>(arr_delay, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>),
    <span class="dt">n =</span> <span class="kw">n</span>())

<span class="kw">ggplot</span>(sched_dep, <span class="kw">aes</span>(minute, avg_delay)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>So why do we see that pattern with the actual departure times? Well, like much data collected by humans, there’s a strong bias towards flights leaving at “nice” departure times. Always be alert for this sort of pattern whenever you work with data that involves human judgement!</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sched_dep, <span class="kw">aes</span>(minute, n)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="rounding" class="section level3">
<h3><span class="header-section-number">16.3.2</span> Rounding</h3>
<p>An alternative approach to plotting individual components is to round the date to a nearby unit of time, with <code>floor_date()</code>, <code>round_date()</code>, and <code>ceiling_date()</code>. Each function takes a vector of dates to adjust and then the name of the unit round down (floor), round up (ceiling), or round to. This, for example, allows us to plot the number of flights per week:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">count</span>(<span class="dt">week =</span> <span class="kw">floor_date</span>(dep_time, <span class="st">&quot;week&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(week, n)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Computing the difference between a rounded and unrounded date can be particularly useful.</p>
</div>
<div id="setting-components" class="section level3">
<h3><span class="header-section-number">16.3.3</span> Setting components</h3>
<p>You can also use each accessor function to set the components of a date/time:</p>
<pre class="sourceCode r"><code class="sourceCode r">(datetime &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2016-07-08 12:34:56&quot;</span>))
<span class="co">#&gt; [1] &quot;2016-07-08 12:34:56 UTC&quot;</span>

<span class="kw">year</span>(datetime) &lt;-<span class="st"> </span><span class="dv">2020</span>
datetime
<span class="co">#&gt; [1] &quot;2020-07-08 12:34:56 UTC&quot;</span>
<span class="kw">month</span>(datetime) &lt;-<span class="st"> </span><span class="dv">01</span>
datetime
<span class="co">#&gt; [1] &quot;2020-01-08 12:34:56 UTC&quot;</span>
<span class="kw">hour</span>(datetime) &lt;-<span class="st"> </span><span class="kw">hour</span>(datetime) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
datetime
<span class="co">#&gt; [1] &quot;2020-01-08 13:34:56 UTC&quot;</span></code></pre>
<p>Alternatively, rather than modifying in place, you can create a new date-time with <code>update()</code>. This also allows you to set multiple values at once.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">update</span>(datetime, <span class="dt">year =</span> <span class="dv">2020</span>, <span class="dt">month =</span> <span class="dv">2</span>, <span class="dt">mday =</span> <span class="dv">2</span>, <span class="dt">hour =</span> <span class="dv">2</span>)
<span class="co">#&gt; [1] &quot;2020-02-02 02:34:56 UTC&quot;</span></code></pre>
<p>If values are too big, they will roll-over:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ymd</span>(<span class="st">&quot;2015-02-01&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">update</span>(<span class="dt">mday =</span> <span class="dv">30</span>)
<span class="co">#&gt; [1] &quot;2015-03-02&quot;</span>
<span class="kw">ymd</span>(<span class="st">&quot;2015-02-01&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">update</span>(<span class="dt">hour =</span> <span class="dv">400</span>)
<span class="co">#&gt; [1] &quot;2015-02-17 16:00:00 UTC&quot;</span></code></pre>
<p>You can use <code>update()</code> to show the distribution of flights across the course of the day for every day of the year:</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dep_hour =</span> <span class="kw">update</span>(dep_time, <span class="dt">yday =</span> <span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(dep_hour)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="dv">300</span>)</code></pre>
<p><img src="datetimes_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Setting larger components of a date to a constant is a powerful technique that allows you to explore patterns in the smaller components.</p>
</div>
<div id="exercises-46" class="section level3">
<h3><span class="header-section-number">16.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>How does the distribution of flight times within a day change over the
course of the year?</p></li>
<li><p>Compare <code>dep_time</code>, <code>sched_dep_time</code> and <code>dep_delay</code>. Are they consistent?
Explain your findings.</p></li>
<li><p>Compare <code>air_time</code> with the duration between the departure and arrival.
Explain your findings. (Hint: consider the location of the airport.)</p></li>
<li><p>How does the average delay time change over the course of a day?
Should you use <code>dep_time</code> or <code>sched_dep_time</code>? Why?</p></li>
<li><p>On what day of the week should you leave if you want to minimise the
chance of a delay?</p></li>
<li><p>What makes the distribution of <code>diamonds$carat</code> and
<code>flights$sched_dep_time</code> similar?</p></li>
<li><p>Confirm my hypothesis that the early departures of flights in minutes
20-30 and 50-60 are caused by scheduled flights that leave early.
Hint: create a binary variable that tells you whether or not a flight
was delayed.</p></li>
</ol>
</div>
</div>
<div id="time-spans" class="section level2">
<h2><span class="header-section-number">16.4</span> Time spans</h2>
<p>Next you’ll learn about how arithmetic with dates works, including subtraction, addition, and division. Along the way, you’ll learn about three important classes that represent time spans:</p>
<ul>
<li><strong>durations</strong>, which represent an exact number of seconds.</li>
<li><strong>periods</strong>, which represent human units like weeks and months.</li>
<li><strong>intervals</strong>, which represent a starting and ending point.</li>
</ul>
<div id="durations" class="section level3">
<h3><span class="header-section-number">16.4.1</span> Durations</h3>
<p>In R, when you subtract two dates, you get a difftime object:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># How old is Hadley?</span>
h_age &lt;-<span class="st"> </span><span class="kw">today</span>() <span class="op">-</span><span class="st"> </span><span class="kw">ymd</span>(<span class="dv">19791014</span>)
h_age
<span class="co">#&gt; Time difference of 14347 days</span></code></pre>
<p>A difftime class object records a time span of seconds, minutes, hours, days, or weeks. This ambiguity can make difftimes a little painful to work with, so lubridate provides an alternative which always uses seconds: the <strong>duration</strong>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.duration</span>(h_age)
<span class="co">#&gt; [1] &quot;1239580800s (~39.28 years)&quot;</span></code></pre>
<p>Durations come with a bunch of convenient constructors:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dseconds</span>(<span class="dv">15</span>)
<span class="co">#&gt; [1] &quot;15s&quot;</span>
<span class="kw">dminutes</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;600s (~10 minutes)&quot;</span>
<span class="kw">dhours</span>(<span class="kw">c</span>(<span class="dv">12</span>, <span class="dv">24</span>))
<span class="co">#&gt; [1] &quot;43200s (~12 hours)&quot; &quot;86400s (~1 days)&quot;</span>
<span class="kw">ddays</span>(<span class="dv">0</span><span class="op">:</span><span class="dv">5</span>)
<span class="co">#&gt; [1] &quot;0s&quot;                &quot;86400s (~1 days)&quot;  &quot;172800s (~2 days)&quot;</span>
<span class="co">#&gt; [4] &quot;259200s (~3 days)&quot; &quot;345600s (~4 days)&quot; &quot;432000s (~5 days)&quot;</span>
<span class="kw">dweeks</span>(<span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;1814400s (~3 weeks)&quot;</span>
<span class="kw">dyears</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;31536000s (~52.14 weeks)&quot;</span></code></pre>
<p>Durations always record the time span in seconds. Larger units are created by converting minutes, hours, days, weeks, and years to seconds at the standard rate (60 seconds in a minute, 60 minutes in an hour, 24 hours in day, 7 days in a week, 365 days in a year).</p>
<p>You can add and multiply durations:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">dyears</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;63072000s (~2 years)&quot;</span>
<span class="kw">dyears</span>(<span class="dv">1</span>) <span class="op">+</span><span class="st"> </span><span class="kw">dweeks</span>(<span class="dv">12</span>) <span class="op">+</span><span class="st"> </span><span class="kw">dhours</span>(<span class="dv">15</span>)
<span class="co">#&gt; [1] &quot;38847600s (~1.23 years)&quot;</span></code></pre>
<p>You can add and subtract durations to and from days:</p>
<pre class="sourceCode r"><code class="sourceCode r">tomorrow &lt;-<span class="st"> </span><span class="kw">today</span>() <span class="op">+</span><span class="st"> </span><span class="kw">ddays</span>(<span class="dv">1</span>)
last_year &lt;-<span class="st"> </span><span class="kw">today</span>() <span class="op">-</span><span class="st"> </span><span class="kw">dyears</span>(<span class="dv">1</span>)</code></pre>
<p>However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:</p>
<pre class="sourceCode r"><code class="sourceCode r">one_pm &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2016-03-12 13:00:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;America/New_York&quot;</span>)

one_pm
<span class="co">#&gt; [1] &quot;2016-03-12 13:00:00 EST&quot;</span>
one_pm <span class="op">+</span><span class="st"> </span><span class="kw">ddays</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2016-03-13 14:00:00 EDT&quot;</span></code></pre>
<p>Why is one day after 1pm on March 12, 2pm on March 13?! If you look carefully at the date you might also notice that the time zones have changed. Because of DST, March 12 only has 23 hours, so if we add a full days worth of seconds we end up with a different time.</p>
</div>
<div id="periods" class="section level3">
<h3><span class="header-section-number">16.4.2</span> Periods</h3>
<p>To solve this problem, lubridate provides <strong>periods</strong>. Periods are time spans but don’t have a fixed length in seconds, instead they work with “human” times, like days and months. That allows them work in a more intuitive way:</p>
<pre class="sourceCode r"><code class="sourceCode r">one_pm
<span class="co">#&gt; [1] &quot;2016-03-12 13:00:00 EST&quot;</span>
one_pm <span class="op">+</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2016-03-13 13:00:00 EDT&quot;</span></code></pre>
<p>Like durations, periods can be created with a number of friendly constructor functions.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seconds</span>(<span class="dv">15</span>)
<span class="co">#&gt; [1] &quot;15S&quot;</span>
<span class="kw">minutes</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;10M 0S&quot;</span>
<span class="kw">hours</span>(<span class="kw">c</span>(<span class="dv">12</span>, <span class="dv">24</span>))
<span class="co">#&gt; [1] &quot;12H 0M 0S&quot; &quot;24H 0M 0S&quot;</span>
<span class="kw">days</span>(<span class="dv">7</span>)
<span class="co">#&gt; [1] &quot;7d 0H 0M 0S&quot;</span>
<span class="kw">months</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>)
<span class="co">#&gt; [1] &quot;1m 0d 0H 0M 0S&quot; &quot;2m 0d 0H 0M 0S&quot; &quot;3m 0d 0H 0M 0S&quot; &quot;4m 0d 0H 0M 0S&quot;</span>
<span class="co">#&gt; [5] &quot;5m 0d 0H 0M 0S&quot; &quot;6m 0d 0H 0M 0S&quot;</span>
<span class="kw">weeks</span>(<span class="dv">3</span>)
<span class="co">#&gt; [1] &quot;21d 0H 0M 0S&quot;</span>
<span class="kw">years</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;1y 0m 0d 0H 0M 0S&quot;</span></code></pre>
<p>You can add and multiply periods:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">10</span> <span class="op">*</span><span class="st"> </span>(<span class="kw">months</span>(<span class="dv">6</span>) <span class="op">+</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">1</span>))
<span class="co">#&gt; [1] &quot;60m 10d 0H 0M 0S&quot;</span>
<span class="kw">days</span>(<span class="dv">50</span>) <span class="op">+</span><span class="st"> </span><span class="kw">hours</span>(<span class="dv">25</span>) <span class="op">+</span><span class="st"> </span><span class="kw">minutes</span>(<span class="dv">2</span>)
<span class="co">#&gt; [1] &quot;50d 25H 2M 0S&quot;</span></code></pre>
<p>And of course, add them to dates. Compared to durations, periods are more likely to do what you expect:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># A leap year</span>
<span class="kw">ymd</span>(<span class="st">&quot;2016-01-01&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">dyears</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2016-12-31&quot;</span>
<span class="kw">ymd</span>(<span class="st">&quot;2016-01-01&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">years</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2017-01-01&quot;</span>

<span class="co"># Daylight Savings Time</span>
one_pm <span class="op">+</span><span class="st"> </span><span class="kw">ddays</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2016-03-13 14:00:00 EDT&quot;</span>
one_pm <span class="op">+</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;2016-03-13 13:00:00 EDT&quot;</span></code></pre>
<p>Let’s use periods to fix an oddity related to our flight dates. Some planes appear to have arrived at their destination <em>before</em> they departed from New York City.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(arr_time <span class="op">&lt;</span><span class="st"> </span>dep_time) 
<span class="co">#&gt; # A tibble: 10,633 x 9</span>
<span class="co">#&gt;   origin dest  dep_delay arr_delay dep_time            sched_dep_time     </span>
<span class="co">#&gt;   &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             </span>
<span class="co">#&gt; 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00</span>
<span class="co">#&gt; 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00</span>
<span class="co">#&gt; 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00</span>
<span class="co">#&gt; 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00</span>
<span class="co">#&gt; 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00</span>
<span class="co">#&gt; 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00</span>
<span class="co">#&gt; # … with 1.063e+04 more rows, and 3 more variables: arr_time &lt;dttm&gt;,</span>
<span class="co">#&gt; #   sched_arr_time &lt;dttm&gt;, air_time &lt;dbl&gt;</span></code></pre>
<p>These are overnight flights. We used the same date information for both the departure and the arrival times, but these flights arrived on the following day. We can fix this by adding <code>days(1)</code> to the arrival time of each overnight flight.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt &lt;-<span class="st"> </span>flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">overnight =</span> arr_time <span class="op">&lt;</span><span class="st"> </span>dep_time,
    <span class="dt">arr_time =</span> arr_time <span class="op">+</span><span class="st"> </span><span class="kw">days</span>(overnight <span class="op">*</span><span class="st"> </span><span class="dv">1</span>),
    <span class="dt">sched_arr_time =</span> sched_arr_time <span class="op">+</span><span class="st"> </span><span class="kw">days</span>(overnight <span class="op">*</span><span class="st"> </span><span class="dv">1</span>)
  )</code></pre>
<p>Now all of our flights obey the laws of physics.</p>
<pre class="sourceCode r"><code class="sourceCode r">flights_dt <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(overnight, arr_time <span class="op">&lt;</span><span class="st"> </span>dep_time) 
<span class="co">#&gt; # A tibble: 0 x 10</span>
<span class="co">#&gt; # … with 10 variables: origin &lt;chr&gt;, dest &lt;chr&gt;, dep_delay &lt;dbl&gt;,</span>
<span class="co">#&gt; #   arr_delay &lt;dbl&gt;, dep_time &lt;dttm&gt;, sched_dep_time &lt;dttm&gt;,</span>
<span class="co">#&gt; #   arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, air_time &lt;dbl&gt;,</span>
<span class="co">#&gt; #   overnight &lt;lgl&gt;</span></code></pre>
</div>
<div id="intervals" class="section level3">
<h3><span class="header-section-number">16.4.3</span> Intervals</h3>
<p>It’s obvious what <code>dyears(1) / ddays(365)</code> should return: one, because durations are always represented by a number of seconds, and a duration of a year is defined as 365 days worth of seconds.</p>
<p>What should <code>years(1) / days(1)</code> return? Well, if the year was 2015 it should return 365, but if it was 2016, it should return 366! There’s not quite enough information for lubridate to give a single clear answer. What it does instead is give an estimate, with a warning:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">years</span>(<span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">1</span>)
<span class="co">#&gt; estimate only: convert to intervals for accuracy</span>
<span class="co">#&gt; [1] 365</span></code></pre>
<p>If you want a more accurate measurement, you’ll have to use an <strong>interval</strong>. An interval is a duration with a starting point: that makes it precise so you can determine exactly how long it is:</p>
<pre class="sourceCode r"><code class="sourceCode r">next_year &lt;-<span class="st"> </span><span class="kw">today</span>() <span class="op">+</span><span class="st"> </span><span class="kw">years</span>(<span class="dv">1</span>)
(<span class="kw">today</span>() <span class="op">%--%</span><span class="st"> </span>next_year) <span class="op">/</span><span class="st"> </span><span class="kw">ddays</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] 365</span></code></pre>
<p>To find out how many periods fall into an interval, you need to use integer division:</p>
<pre class="sourceCode r"><code class="sourceCode r">(<span class="kw">today</span>() <span class="op">%--%</span><span class="st"> </span>next_year) <span class="op">%/%</span><span class="st"> </span><span class="kw">days</span>(<span class="dv">1</span>)
<span class="co">#&gt; Note: method with signature &#39;Timespan#Timespan&#39; chosen for function &#39;%/%&#39;,</span>
<span class="co">#&gt;  target signature &#39;Interval#Period&#39;.</span>
<span class="co">#&gt;  &quot;Interval#ANY&quot;, &quot;ANY#Period&quot; would also be valid</span>
<span class="co">#&gt; [1] 365</span></code></pre>
</div>
<div id="summary-1" class="section level3">
<h3><span class="header-section-number">16.4.4</span> Summary</h3>
<p>How do you pick between duration, periods, and intervals? As always, pick the simplest data structure that solves your problem. If you only care about physical time, use a duration; if you need to add human times, use a period; if you need to figure out how long a span is in human units, use an interval.</p>
<p>Figure <a href="#fig:dt-algebra">16.1</a> summarises permitted arithmetic operations between the different data types.</p>
<div class="figure" style="text-align: center"><span id="fig:dt-algebra"></span>
<img src="diagrams/datetimes-arithmetic.png" alt="The allowed arithmetic operations between pairs of date/time classes." width="70%" />
<p class="caption">
Figure 16.1: The allowed arithmetic operations between pairs of date/time classes.
</p>
</div>
</div>
<div id="exercises-47" class="section level3">
<h3><span class="header-section-number">16.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why is there <code>months()</code> but no <code>dmonths()</code>?</p></li>
<li><p>Explain <code>days(overnight * 1)</code> to someone who has just started
learning R. How does it work?</p></li>
<li><p>Create a vector of dates giving the first day of every month in 2015.
Create a vector of dates giving the first day of every month
in the <em>current</em> year.</p></li>
<li><p>Write a function that given your birthday (as a date), returns
how old you are in years.</p></li>
<li><p>Why can’t <code>(today() %--% (today() + years(1)) / months(1)</code> work?</p></li>
</ol>
</div>
</div>
<div id="time-zones" class="section level2">
<h2><span class="header-section-number">16.5</span> Time zones</h2>
<p>Time zones are an enormously complicated topic because of their interaction with geopolitical entities. Fortunately we don’t need to dig into all the details as they’re not all important for data analysis, but there are a few challenges we’ll need to tackle head on.</p>
<p>The first challenge is that everyday names of time zones tend to be ambiguous. For example, if you’re American you’re probably familiar with EST, or Eastern Standard Time. However, both Australia and Canada also have EST! To avoid confusion, R uses the international standard IANA time zones. These use a consistent naming scheme “<area>/<location>”, typically in the form “&lt;continent&gt;/&lt;city&gt;” (there are a few exceptions because not every country lies on a continent). Examples include “America/New_York”, “Europe/Paris”, and “Pacific/Auckland”.</p>
<p>You might wonder why the time zone uses a city, when typically you think of time zones as associated with a country or region within a country. This is because the IANA database has to record decades worth of time zone rules. In the course of decades, countries change names (or break apart) fairly frequently, but city names tend to stay the same. Another problem is that name needs to reflect not only to the current behaviour, but also the complete history. For example, there are time zones for both “America/New_York” and “America/Detroit”. These cities both currently use Eastern Standard Time but in 1969-1972 Michigan (the state in which Detroit is located), did not follow DST, so it needs a different name. It’s worth reading the raw time zone database (available at <a href="http://www.iana.org/time-zones" class="uri">http://www.iana.org/time-zones</a>) just to read some of these stories!</p>
<p>You can find out what R thinks your current time zone is with <code>Sys.timezone()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.timezone</span>()
<span class="co">#&gt; [1] &quot;Asia/Taipei&quot;</span></code></pre>
<p>(If R doesn’t know, you’ll get an <code>NA</code>.)</p>
<p>And see the complete list of all time zone names with <code>OlsonNames()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(<span class="kw">OlsonNames</span>())
<span class="co">#&gt; [1] 607</span>
<span class="kw">head</span>(<span class="kw">OlsonNames</span>())
<span class="co">#&gt; [1] &quot;Africa/Abidjan&quot;     &quot;Africa/Accra&quot;       &quot;Africa/Addis_Ababa&quot;</span>
<span class="co">#&gt; [4] &quot;Africa/Algiers&quot;     &quot;Africa/Asmara&quot;      &quot;Africa/Asmera&quot;</span></code></pre>
<p>In R, the time zone is an attribute of the date-time that only controls printing. For example, these three objects represent the same instant in time:</p>
<pre class="sourceCode r"><code class="sourceCode r">(x1 &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2015-06-01 12:00:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;America/New_York&quot;</span>))
<span class="co">#&gt; [1] &quot;2015-06-01 12:00:00 EDT&quot;</span>
(x2 &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2015-06-01 18:00:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;Europe/Copenhagen&quot;</span>))
<span class="co">#&gt; [1] &quot;2015-06-01 18:00:00 CEST&quot;</span>
(x3 &lt;-<span class="st"> </span><span class="kw">ymd_hms</span>(<span class="st">&quot;2015-06-02 04:00:00&quot;</span>, <span class="dt">tz =</span> <span class="st">&quot;Pacific/Auckland&quot;</span>))
<span class="co">#&gt; [1] &quot;2015-06-02 04:00:00 NZST&quot;</span></code></pre>
<p>You can verify that they’re the same time using subtraction:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 <span class="op">-</span><span class="st"> </span>x2
<span class="co">#&gt; Time difference of 0 secs</span>
x1 <span class="op">-</span><span class="st"> </span>x3
<span class="co">#&gt; Time difference of 0 secs</span></code></pre>
<p>Unless otherwise specified, lubridate always uses UTC. UTC (Coordinated Universal Time) is the standard time zone used by the scientific community and roughly equivalent to its predecessor GMT (Greenwich Mean Time). It does not have DST, which makes a convenient representation for computation. Operations that combine date-times, like <code>c()</code>, will often drop the time zone. In that case, the date-times will display in your local time zone:</p>
<pre class="sourceCode r"><code class="sourceCode r">x4 &lt;-<span class="st"> </span><span class="kw">c</span>(x1, x2, x3)
x4
<span class="co">#&gt; [1] &quot;2015-06-02 CST&quot; &quot;2015-06-02 CST&quot; &quot;2015-06-02 CST&quot;</span></code></pre>
<p>You can change the time zone in two ways:</p>
<ul>
<li><p>Keep the instant in time the same, and change how it’s displayed.
Use this when the instant is correct, but you want a more natural
display.</p>
<pre class="sourceCode r"><code class="sourceCode r">x4a &lt;-<span class="st"> </span><span class="kw">with_tz</span>(x4, <span class="dt">tzone =</span> <span class="st">&quot;Australia/Lord_Howe&quot;</span>)
x4a
<span class="co">#&gt; [1] &quot;2015-06-02 02:30:00 +1030&quot; &quot;2015-06-02 02:30:00 +1030&quot;</span>
<span class="co">#&gt; [3] &quot;2015-06-02 02:30:00 +1030&quot;</span>
x4a <span class="op">-</span><span class="st"> </span>x4
<span class="co">#&gt; Time differences in secs</span>
<span class="co">#&gt; [1] 0 0 0</span></code></pre>
<p>(This also illustrates another challenge of times zones: they’re not
all integer hour offsets!)</p></li>
<li><p>Change the underlying instant in time. Use this when you have an
instant that has been labelled with the incorrect time zone, and you
need to fix it.</p>
<pre class="sourceCode r"><code class="sourceCode r">x4b &lt;-<span class="st"> </span><span class="kw">force_tz</span>(x4, <span class="dt">tzone =</span> <span class="st">&quot;Australia/Lord_Howe&quot;</span>)
x4b
<span class="co">#&gt; [1] &quot;2015-06-02 +1030&quot; &quot;2015-06-02 +1030&quot; &quot;2015-06-02 +1030&quot;</span>
x4b <span class="op">-</span><span class="st"> </span>x4
<span class="co">#&gt; Time differences in hours</span>
<span class="co">#&gt; [1] -2.5 -2.5 -2.5</span></code></pre></li>
</ul>
<!--chapter:end:datetimes.Rmd-->
</div>
</div>
<div id="part-program" class="section level1 unnumbered">
<h1><span class="header-section-number">III</span> Program</h1>
</div>
<div id="program-intro" class="section level1">
<h1><span class="header-section-number">17</span> Introduction</h1>
<p>In this part of the book, you’ll improve your programming skills. Programming is a cross-cutting skill needed for all data science work: you must use a computer to do data science; you cannot do it in your head, or with pencil and paper.</p>
<p><img src="diagrams/data-science-program.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Programming produces code, and code is a tool of communication. Obviously code tells the computer what you want it to do. But it also communicates meaning to other humans. Thinking about code as a vehicle for communication is important because every project you do is fundamentally collaborative. Even if you’re not working with other people, you’ll definitely be working with future-you! Writing clear code is important so that others (like future-you) can understand why you tackled an analysis in the way you did. That means getting better at programming also involves getting better at communicating. Over time, you want your code to become not just easier to write, but easier for others to read.</p>
<p>Writing code is similar in many ways to writing prose. One parallel which I find particularly useful is that in both cases rewriting is the key to clarity. The first expression of your ideas is unlikely to be particularly clear, and you may need to rewrite multiple times. After solving a data analysis challenge, it’s often worth looking at your code and thinking about whether or not it’s obvious what you’ve done. If you spend a little time rewriting your code while the ideas are fresh, you can save a lot of time later trying to recreate what your code did. But this doesn’t mean you should rewrite every function: you need to balance what you need to achieve now with saving time in the long run. (But the more you rewrite your functions the more likely your first attempt will be clear.)</p>
<p>In the following four chapters, you’ll learn skills that will allow you to both tackle new programs and to solve existing problems with greater clarity and ease:</p>
<ol style="list-style-type: decimal">
<li><p>In <a href="#pipes">pipes</a>, you will dive deep into the <strong>pipe</strong>, <code>%&gt;%</code>, and learn more
about how it works, what the alternatives are, and when not to use it.</p></li>
<li><p>Copy-and-paste is a powerful tool, but you should avoid doing it more than
twice. Repeating yourself in code is dangerous because it can easily lead
to errors and inconsistencies. Instead, in <a href="#functions">functions</a>, you’ll learn
how to write <strong>functions</strong> which let you extract out repeated code so that
it can be easily reused.</p></li>
<li><p>As you start to write more powerful functions, you’ll need a solid
grounding in R’s <strong>data structures</strong>, provided by <a href="#vectors">vectors</a>. You must master
the four common atomic vectors, the three important S3 classes built on
top of them, and understand the mysteries of the list and data frame.</p></li>
<li><p>Functions extract out repeated code, but you often need to repeat the
same actions on different inputs. You need tools for <strong>iteration</strong> that
let you do similar things again and again. These tools include for loops
and functional programming, which you’ll learn about in <a href="#iteration">iteration</a>.</p></li>
</ol>
<div id="learning-more-2" class="section level2">
<h2><span class="header-section-number">17.1</span> Learning more</h2>
<p>The goal of these chapters is to teach you the minimum about programming that you need to practice data science, which turns out to be a reasonable amount. Once you have mastered the material in this book, I strongly believe you should invest further in your programming skills. Learning more about programming is a long-term investment: it won’t pay off immediately, but in the long term it will allow you to solve new problems more quickly, and let you reuse your insights from previous problems in new scenarios.</p>
<p>To learn more you need to study R as a programming language, not just an interactive environment for data science. We have written two books that will help you do so:</p>
<ul>
<li><p><em>Hands on Programming with R</em><span id="fn21" class="footnote" data-pagedown-footnote-number="21" style="white-space: pre-line;"><a href="https://amzn.com/1449359019" class="uri">https://amzn.com/1449359019</a></span>,
by Garrett Grolemund. This is an introduction to R as a programming language
and is a great place to start if R is your first programming language. It
covers similar material to these chapters, but with a different style and
different motivation examples (based in the casino). It’s a useful complement
if you find that these four chapters go by too quickly.</p></li>
<li><p><em>Advanced R</em><span id="fn22" class="footnote" data-pagedown-footnote-number="22" style="white-space: pre-line;"><a href="https://amzn.com/1466586966" class="uri">https://amzn.com/1466586966</a></span> by Hadley Wickham. This dives into the
details of R the programming language. This is a great place to start if you
have existing programming experience. It’s also a great next step once you’ve
internalised the ideas in these chapters. You can read it online at
<a href="http://adv-r.had.co.nz" class="uri">http://adv-r.had.co.nz</a>.</p></li>
</ul>
<!--chapter:end:program.Rmd-->
</div>
</div>
<div id="pipes" class="section level1">
<h1><span class="header-section-number">18</span> Pipes</h1>
<div id="introduction-11" class="section level2">
<h2><span class="header-section-number">18.1</span> Introduction</h2>
<p>Pipes are a powerful tool for clearly expressing a sequence of multiple operations. So far, you’ve been using them without knowing how they work, or what the alternatives are. Now, in this chapter, it’s time to explore the pipe in more detail. You’ll learn the alternatives to the pipe, when you shouldn’t use the pipe, and some useful related tools.</p>
<div id="prerequisites-11" class="section level3">
<h3><span class="header-section-number">18.1.1</span> Prerequisites</h3>
<p>The pipe, <code>%&gt;%</code>, comes from the <strong>magrittr</strong> package by Stefan Milton Bache. Packages in the tidyverse load <code>%&gt;%</code> for you automatically, so you don’t usually load magrittr explicitly. Here, however, we’re focussing on piping, and we aren’t loading any other packages, so we will load it explicitly.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(magrittr)</code></pre>
</div>
</div>
<div id="piping-alternatives" class="section level2">
<h2><span class="header-section-number">18.2</span> Piping alternatives</h2>
<p>The point of the pipe is to help you write code in a way that is easier to read and understand. To see why the pipe is so useful, we’re going to explore a number of ways of writing the same code. Let’s use code to tell a story about a little bunny named Foo Foo:</p>
<blockquote>
<p>Little bunny Foo Foo<br />
Went hopping through the forest<br />
Scooping up the field mice<br />
And bopping them on the head</p>
</blockquote>
<p>This is a popular Children’s poem that is accompanied by hand actions.</p>
<p>We’ll start by defining an object to represent little bunny Foo Foo:</p>
<pre class="sourceCode r"><code class="sourceCode r">foo_foo &lt;-<span class="st"> </span><span class="kw">little_bunny</span>()</code></pre>
<p>And we’ll use a function for each key verb: <code>hop()</code>, <code>scoop()</code>, and <code>bop()</code>. Using this object and these verbs, there are (at least) four ways we could retell the story in code:</p>
<ol style="list-style-type: decimal">
<li>Save each intermediate step as a new object.</li>
<li>Overwrite the original object many times.</li>
<li>Compose functions.</li>
<li>Use the pipe.</li>
</ol>
<p>We’ll work through each approach, showing you the code and talking about the advantages and disadvantages.</p>
<div id="intermediate-steps" class="section level3">
<h3><span class="header-section-number">18.2.1</span> Intermediate steps</h3>
<p>The simplest approach is to save each step as a new object:</p>
<pre class="sourceCode r"><code class="sourceCode r">foo_foo_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">hop</span>(foo_foo, <span class="dt">through =</span> forest)
foo_foo_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">scoop</span>(foo_foo_<span class="dv">1</span>, <span class="dt">up =</span> field_mice)
foo_foo_<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">bop</span>(foo_foo_<span class="dv">2</span>, <span class="dt">on =</span> head)</code></pre>
<p>The main downside of this form is that it forces you to name each intermediate element. If there are natural names, this is a good idea, and you should do it. But many times, like this in this example, there aren’t natural names, and you add numeric suffixes to make the names unique. That leads to two problems:</p>
<ol style="list-style-type: decimal">
<li><p>The code is cluttered with unimportant names</p></li>
<li><p>You have to carefully increment the suffix on each line.</p></li>
</ol>
<p>Whenever I write code like this, I invariably use the wrong number on one line and then spend 10 minutes scratching my head and trying to figure out what went wrong with my code.</p>
<p>You may also worry that this form creates many copies of your data and takes up a lot of memory. Surprisingly, that’s not the case. First, note that proactively worrying about memory is not a useful way to spend your time: worry about it when it becomes a problem (i.e. you run out of memory), not before. Second, R isn’t stupid, and it will share columns across data frames, where possible. Let’s take a look at an actual data manipulation pipeline where we add a new column to <code>ggplot2::diamonds</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds &lt;-<span class="st"> </span>ggplot2<span class="op">::</span>diamonds
diamonds2 &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">mutate</span>(<span class="dt">price_per_carat =</span> price <span class="op">/</span><span class="st"> </span>carat)

pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds)
<span class="co">#&gt; 3.46 MB</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds2)
<span class="co">#&gt; 3.89 MB</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds, diamonds2)
<span class="co">#&gt; 3.89 MB</span></code></pre>
<p><code>pryr::object_size()</code> gives the memory occupied by all of its arguments. The results seem counterintuitive at first:</p>
<ul>
<li><code>diamonds</code> takes up 3.46 MB,</li>
<li><code>diamonds2</code> takes up 3.89 MB,</li>
<li><code>diamonds</code> and <code>diamonds2</code> together take up 3.89 MB!</li>
</ul>
<p>How can that work? Well, <code>diamonds2</code> has 10 columns in common with <code>diamonds</code>: there’s no need to duplicate all that data, so the two data frames have variables in common. These variables will only get copied if you modify one of them. In the following example, we modify a single value in <code>diamonds$carat</code>. That means the <code>carat</code> variable can no longer be shared between the two data frames, and a copy must be made. The size of each data frame is unchanged, but the collective size increases:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds<span class="op">$</span>carat[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds)
<span class="co">#&gt; 3.46 MB</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds2)
<span class="co">#&gt; 3.89 MB</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(diamonds, diamonds2)
<span class="co">#&gt; 4.32 MB</span></code></pre>
<p>(Note that we use <code>pryr::object_size()</code> here, not the built-in <code>object.size()</code>. <code>object.size()</code> only takes a single object so it can’t compute how data is shared across multiple objects.)</p>
</div>
<div id="overwrite-the-original" class="section level3">
<h3><span class="header-section-number">18.2.2</span> Overwrite the original</h3>
<p>Instead of creating intermediate objects at each step, we could overwrite the original object:</p>
<pre class="sourceCode r"><code class="sourceCode r">foo_foo &lt;-<span class="st"> </span><span class="kw">hop</span>(foo_foo, <span class="dt">through =</span> forest)
foo_foo &lt;-<span class="st"> </span><span class="kw">scoop</span>(foo_foo, <span class="dt">up =</span> field_mice)
foo_foo &lt;-<span class="st"> </span><span class="kw">bop</span>(foo_foo, <span class="dt">on =</span> head)</code></pre>
<p>This is less typing (and less thinking), so you’re less likely to make mistakes. However, there are two problems:</p>
<ol style="list-style-type: decimal">
<li><p>Debugging is painful: if you make a mistake you’ll need to re-run the
complete pipeline from the beginning.</p></li>
<li><p>The repetition of the object being transformed (we’ve written <code>foo_foo</code> six
times!) obscures what’s changing on each line.</p></li>
</ol>
</div>
<div id="function-composition" class="section level3">
<h3><span class="header-section-number">18.2.3</span> Function composition</h3>
<p>Another approach is to abandon assignment and just string the function calls together:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bop</span>(
  <span class="kw">scoop</span>(
    <span class="kw">hop</span>(foo_foo, <span class="dt">through =</span> forest),
    <span class="dt">up =</span> field_mice
  ), 
  <span class="dt">on =</span> head
)</code></pre>
<p>Here the disadvantage is that you have to read from inside-out, from right-to-left, and that the arguments end up spread far apart (evocatively called the
dagwood sandwhich<span id="fn23" class="footnote" data-pagedown-footnote-number="23" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/Dagwood_sandwich" class="uri">https://en.wikipedia.org/wiki/Dagwood_sandwich</a></span> problem). In short, this code is hard for a human to consume.</p>
</div>
<div id="use-the-pipe" class="section level3">
<h3><span class="header-section-number">18.2.4</span> Use the pipe</h3>
<p>Finally, we can use the pipe:</p>
<pre class="sourceCode r"><code class="sourceCode r">foo_foo <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">hop</span>(<span class="dt">through =</span> forest) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">scoop</span>(<span class="dt">up =</span> field_mice) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">bop</span>(<span class="dt">on =</span> head)</code></pre>
<p>This is my favourite form, because it focusses on verbs, not nouns. You can read this series of function compositions like it’s a set of imperative actions. Foo Foo hops, then scoops, then bops. The downside, of course, is that you need to be familiar with the pipe. If you’ve never seen <code>%&gt;%</code> before, you’ll have no idea what this code does. Fortunately, most people pick up the idea very quickly, so when you share your code with others who aren’t familiar with the pipe, you can easily teach them.</p>
<p>The pipe works by performing a “lexical transformation”: behind the scenes, magrittr reassembles the code in the pipe to a form that works by overwriting an intermediate object. When you run a pipe like the one above, magrittr does something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">my_pipe &lt;-<span class="st"> </span><span class="cf">function</span>(.) {
  . &lt;-<span class="st"> </span><span class="kw">hop</span>(., <span class="dt">through =</span> forest)
  . &lt;-<span class="st"> </span><span class="kw">scoop</span>(., <span class="dt">up =</span> field_mice)
  <span class="kw">bop</span>(., <span class="dt">on =</span> head)
}
<span class="kw">my_pipe</span>(foo_foo)</code></pre>
<p>This means that the pipe won’t work for two classes of functions:</p>
<ol style="list-style-type: decimal">
<li><p>Functions that use the current environment. For example, <code>assign()</code>
will create a new variable with the given name in the current environment:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assign</span>(<span class="st">&quot;x&quot;</span>, <span class="dv">10</span>)
x
<span class="co">#&gt; [1] 10</span>

<span class="st">&quot;x&quot;</span> <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">assign</span>(<span class="dv">100</span>)
x
<span class="co">#&gt; [1] 10</span></code></pre>
<p>The use of assign with the pipe does not work because it assigns it to
a temporary environment used by <code>%&gt;%</code>. If you do want to use assign with the
pipe, you must be explicit about the environment:</p>
<pre class="sourceCode r"><code class="sourceCode r">env &lt;-<span class="st"> </span><span class="kw">environment</span>()
<span class="st">&quot;x&quot;</span> <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">assign</span>(<span class="dv">100</span>, <span class="dt">envir =</span> env)
x
<span class="co">#&gt; [1] 100</span></code></pre>
<p>Other functions with this problem include <code>get()</code> and <code>load()</code>.</p></li>
<li><p>Functions that use lazy evaluation. In R, function arguments
are only computed when the function uses them, not prior to calling the
function. The pipe computes each element in turn, so you can’t
rely on this behaviour.</p>
<p>One place that this is a problem is <code>tryCatch()</code>, which lets you capture
and handle errors:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tryCatch</span>(<span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>), <span class="dt">error =</span> <span class="cf">function</span>(e) <span class="st">&quot;An error&quot;</span>)
<span class="co">#&gt; [1] &quot;An error&quot;</span>

<span class="kw">stop</span>(<span class="st">&quot;!&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">tryCatch</span>(<span class="dt">error =</span> <span class="cf">function</span>(e) <span class="st">&quot;An error&quot;</span>)
<span class="co">#&gt; Error in eval(lhs, parent, parent): !</span></code></pre>
<p>There are a relatively wide class of functions with this behaviour,
including <code>try()</code>, <code>suppressMessages()</code>, and <code>suppressWarnings()</code>
in base R.</p></li>
</ol>
</div>
</div>
<div id="when-not-to-use-the-pipe" class="section level2">
<h2><span class="header-section-number">18.3</span> When not to use the pipe</h2>
<p>The pipe is a powerful tool, but it’s not the only tool at your disposal, and it doesn’t solve every problem! Pipes are most useful for rewriting a fairly short linear sequence of operations. I think you should reach for another tool when:</p>
<ul>
<li><p>Your pipes are longer than (say) ten steps. In that case, create
intermediate objects with meaningful names. That will make debugging easier,
because you can more easily check the intermediate results, and it makes
it easier to understand your code, because the variable names can help
communicate intent.</p></li>
<li><p>You have multiple inputs or outputs. If there isn’t one primary object
being transformed, but two or more objects being combined together,
don’t use the pipe.</p></li>
<li><p>You are starting to think about a directed graph with a complex
dependency structure. Pipes are fundamentally linear and expressing
complex relationships with them will typically yield confusing code.</p></li>
</ul>
</div>
<div id="other-tools-from-magrittr" class="section level2">
<h2><span class="header-section-number">18.4</span> Other tools from magrittr</h2>
<p>All packages in the tidyverse automatically make <code>%&gt;%</code> available for you, so you don’t normally load magrittr explicitly. However, there are some other useful tools inside magrittr that you might want to try out:</p>
<ul>
<li><p>When working with more complex pipes, it’s sometimes useful to call a
function for its side-effects. Maybe you want to print out the current
object, or plot it, or save it to disk. Many times, such functions don’t
return anything, effectively terminating the pipe.</p>
<p>To work around this problem, you can use the “tee” pipe. <code>%T&gt;%</code> works like
<code>%&gt;%</code> except that it returns the left-hand side instead of the right-hand
side. It’s called “tee” because it’s like a literal T-shaped pipe.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rnorm</span>(<span class="dv">100</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">matrix</span>(<span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">plot</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt;  NULL</span>

<span class="kw">rnorm</span>(<span class="dv">100</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">matrix</span>(<span class="dt">ncol =</span> <span class="dv">2</span>) <span class="op">%T&gt;%</span>
<span class="st">  </span><span class="kw">plot</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt;  num [1:50, 1:2] -0.387 -0.785 -1.057 -0.796 -1.756 ...</span></code></pre>
<p><img src="pipes_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" /><img src="pipes_files/figure-html/unnamed-chunk-13-2.png" width="70%" style="display: block; margin: auto;" /></p></li>
<li><p>If you’re working with functions that don’t have a data frame based API<br />
(i.e. you pass them individual vectors, not a data frame and expressions
to be evaluated in the context of that data frame), you might find <code>%$%</code>
useful. It “explodes” out the variables in a data frame so that you can
refer to them explicitly. This is useful when working with many functions
in base R:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%$%</span>
<span class="st">  </span><span class="kw">cor</span>(disp, mpg)
<span class="co">#&gt; [1] -0.848</span></code></pre></li>
<li><p>For assignment magrittr provides the <code>%&lt;&gt;%</code> operator which allows you to
replace code like:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars &lt;-<span class="st"> </span>mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">transform</span>(<span class="dt">cyl =</span> cyl <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)</code></pre>
<p>with</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&lt;&gt;%</span><span class="st"> </span><span class="kw">transform</span>(<span class="dt">cyl =</span> cyl <span class="op">*</span><span class="st"> </span><span class="dv">2</span>)</code></pre>
<p>I’m not a fan of this operator because I think assignment is such a
special operation that it should always be clear when it’s occurring.
In my opinion, a little bit of duplication (i.e. repeating the
name of the object twice) is fine in return for making assignment
more explicit.</p></li>
</ul>
<!--chapter:end:pipes.Rmd-->
</div>
</div>
<div id="functions" class="section level1">
<h1><span class="header-section-number">19</span> Functions</h1>
<div id="introduction-12" class="section level2">
<h2><span class="header-section-number">19.1</span> Introduction</h2>
<p>One of the best ways to improve your reach as a data scientist is to write functions. Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting. Writing a function has three big advantages over using copy-and-paste:</p>
<ol style="list-style-type: decimal">
<li><p>You can give a function an evocative name that makes your code easier to
understand.</p></li>
<li><p>As requirements change, you only need to update code in one place, instead
of many.</p></li>
<li><p>You eliminate the chance of making incidental mistakes when you copy and
paste (i.e. updating a variable name in one place, but not in another).</p></li>
</ol>
<p>Writing good functions is a lifetime journey. Even after using R for many years I still learn new techniques and better ways of approaching old problems. The goal of this chapter is not to teach you every esoteric detail of functions but to get you started with some pragmatic advice that you can apply immediately.</p>
<p>As well as practical advice for writing functions, this chapter also gives you some suggestions for how to style your code. Good code style is like correct punctuation. Youcanmanagewithoutit, but it sure makes things easier to read! As with styles of punctuation, there are many possible variations. Here we present the style we use in our code, but the most important thing is to be consistent.</p>
<div id="prerequisites-12" class="section level3">
<h3><span class="header-section-number">19.1.1</span> Prerequisites</h3>
<p>The focus of this chapter is on writing functions in base R, so you won’t need any extra packages.</p>
</div>
</div>
<div id="when-should-you-write-a-function" class="section level2">
<h2><span class="header-section-number">19.2</span> When should you write a function?</h2>
<p>You should consider writing a function whenever you’ve copied and pasted a block of code more than twice (i.e. you now have three copies of the same code). For example, take a look at this code. What does it do?</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tibble</span>(
  <span class="dt">a =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">b =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">c =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">d =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>)
)

df<span class="op">$</span>a &lt;-<span class="st"> </span>(df<span class="op">$</span>a <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span><span class="st"> </span>
<span class="st">  </span>(<span class="kw">max</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
df<span class="op">$</span>b &lt;-<span class="st"> </span>(df<span class="op">$</span>b <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>b, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span><span class="st"> </span>
<span class="st">  </span>(<span class="kw">max</span>(df<span class="op">$</span>b, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
df<span class="op">$</span>c &lt;-<span class="st"> </span>(df<span class="op">$</span>c <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>c, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span><span class="st"> </span>
<span class="st">  </span>(<span class="kw">max</span>(df<span class="op">$</span>c, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>c, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
df<span class="op">$</span>d &lt;-<span class="st"> </span>(df<span class="op">$</span>d <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>d, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span><span class="st"> </span>
<span class="st">  </span>(<span class="kw">max</span>(df<span class="op">$</span>d, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>d, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</code></pre>
<p>You might be able to puzzle out that this rescales each column to have a range from 0 to 1. But did you spot the mistake? I made an error when copying-and-pasting the code for <code>df$b</code>: I forgot to change an <code>a</code> to a <code>b</code>. Extracting repeated code out into a function is a good idea because it prevents you from making this type of mistake.</p>
<p>To write a function you need to first analyse the code. How many inputs does it have?</p>
<pre class="sourceCode r"><code class="sourceCode r">(df<span class="op">$</span>a <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span>
<span class="st">  </span>(<span class="kw">max</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(df<span class="op">$</span>a, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))</code></pre>
<p>This code only has one input: <code>df$a</code>. (If you’re surprised that <code>TRUE</code> is not an input, you can explore why in the exercise below.) To make the inputs more clear, it’s a good idea to rewrite the code using temporary variables with general names. Here this code only requires a single numeric vector, so I’ll call it <code>x</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>df<span class="op">$</span>a
(x <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)) <span class="op">/</span><span class="st"> </span>(<span class="kw">max</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt;  [1] 0.289 0.751 0.000 0.678 0.853 1.000 0.172 0.611 0.612 0.601</span></code></pre>
<p>There is some duplication in this code. We’re computing the range of the data three times, so it makes sense to do it in one step:</p>
<pre class="sourceCode r"><code class="sourceCode r">rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
(x <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>]) <span class="op">/</span><span class="st"> </span>(rng[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>])
<span class="co">#&gt;  [1] 0.289 0.751 0.000 0.678 0.853 1.000 0.172 0.611 0.612 0.601</span></code></pre>
<p>Pulling out intermediate calculations into named variables is a good practice because it makes it more clear what the code is doing. Now that I’ve simplified the code, and checked that it still works, I can turn it into a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">rescale01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  (x <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>]) <span class="op">/</span><span class="st"> </span>(rng[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>])
}
<span class="kw">rescale01</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">10</span>))
<span class="co">#&gt; [1] 0.0 0.5 1.0</span></code></pre>
<p>There are three key steps to creating a new function:</p>
<ol style="list-style-type: decimal">
<li><p>You need to pick a <strong>name</strong> for the function. Here I’ve used <code>rescale01</code>
because this function rescales a vector to lie between 0 and 1.</p></li>
<li><p>You list the inputs, or <strong>arguments</strong>, to the function inside <code>function</code>.
Here we have just one argument. If we had more the call would look like
<code>function(x, y, z)</code>.</p></li>
<li><p>You place the code you have developed in <strong>body</strong> of the function, a
<code>{</code> block that immediately follows <code>function(...)</code>.</p></li>
</ol>
<p>Note the overall process: I only made the function after I’d figured out how to make it work with a simple input. It’s easier to start with working code and turn it into a function; it’s harder to create a function and then try to make it work.</p>
<p>At this point it’s a good idea to check your function with a few different inputs:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rescale01</span>(<span class="kw">c</span>(<span class="op">-</span><span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">10</span>))
<span class="co">#&gt; [1] 0.0 0.5 1.0</span>
<span class="kw">rescale01</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="ot">NA</span>, <span class="dv">5</span>))
<span class="co">#&gt; [1] 0.00 0.25 0.50   NA 1.00</span></code></pre>
<p>As you write more and more functions you’ll eventually want to convert these informal, interactive tests into formal, automated tests. That process is called unit testing. Unfortunately, it’s beyond the scope of this book, but you can learn about it in <a href="http://r-pkgs.had.co.nz/tests.html" class="uri">http://r-pkgs.had.co.nz/tests.html</a>.</p>
<p>We can simplify the original example now that we have a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">df<span class="op">$</span>a &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>a)
df<span class="op">$</span>b &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>b)
df<span class="op">$</span>c &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>c)
df<span class="op">$</span>d &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>d)</code></pre>
<p>Compared to the original, this code is easier to understand and we’ve eliminated one class of copy-and-paste errors. There is still quite a bit of duplication since we’re doing the same thing to multiple columns. We’ll learn how to eliminate that duplication in <a href="#iteration">iteration</a>, once you’ve learned more about R’s data structures in <a href="#vectors">vectors</a>.</p>
<p>Another advantage of functions is that if our requirements change, we only need to make the change in one place. For example, we might discover that some of our variables include infinite values, and <code>rescale01()</code> fails:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="ot">Inf</span>)
<span class="kw">rescale01</span>(x)
<span class="co">#&gt;  [1]   0   0   0   0   0   0   0   0   0   0 NaN</span></code></pre>
<p>Because we’ve extracted the code into a function, we only need to make the fix in one place:</p>
<pre class="sourceCode r"><code class="sourceCode r">rescale01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>, <span class="dt">finite =</span> <span class="ot">TRUE</span>)
  (x <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>]) <span class="op">/</span><span class="st"> </span>(rng[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>])
}
<span class="kw">rescale01</span>(x)
<span class="co">#&gt;  [1] 0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000   Inf</span></code></pre>
<p>This is an important part of the “do not repeat yourself” (or DRY) principle. The more repetition you have in your code, the more places you need to remember to update when things change (and they always do!), and the more likely you are to create bugs over time.</p>
<div id="practice-2" class="section level3">
<h3><span class="header-section-number">19.2.1</span> Practice</h3>
<ol style="list-style-type: decimal">
<li><p>Why is <code>TRUE</code> not a parameter to <code>rescale01()</code>? What would happen if
<code>x</code> contained a single missing value, and <code>na.rm</code> was <code>FALSE</code>?</p></li>
<li><p>In the second variant of <code>rescale01()</code>, infinite values are left
unchanged. Rewrite <code>rescale01()</code> so that <code>-Inf</code> is mapped to 0, and
<code>Inf</code> is mapped to 1.</p></li>
<li><p>Practice turning the following code snippets into functions. Think about
what each function does. What would you call it? How many arguments does it
need? Can you rewrite it to be more expressive or less duplicative?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(<span class="kw">is.na</span>(x))

x <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

<span class="kw">sd</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="op">/</span><span class="st"> </span><span class="kw">mean</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></li>
<li><p>Follow <a href="http://nicercode.github.io/intro/writing-functions.html" class="uri">http://nicercode.github.io/intro/writing-functions.html</a> to
write your own functions to compute the variance and skew of a numeric
vector.</p></li>
<li><p>Write <code>both_na()</code>, a function that takes two vectors of the same length
and returns the number of positions that have an <code>NA</code> in both vectors.</p></li>
<li><p>What do the following functions do? Why are they useful even though they
are so short?</p>
<pre class="sourceCode r"><code class="sourceCode r">is_directory &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">file.info</span>(x)<span class="op">$</span>isdir
is_readable &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">file.access</span>(x, <span class="dv">4</span>) <span class="op">==</span><span class="st"> </span><span class="dv">0</span></code></pre></li>
<li><p>Read the complete lyrics<span id="fn24" class="footnote" data-pagedown-footnote-number="24" style="white-space: pre-line;"><a href="https://en.wikipedia.org/wiki/Little_Bunny_Foo_Foo" class="uri">https://en.wikipedia.org/wiki/Little_Bunny_Foo_Foo</a></span>
to “Little Bunny Foo Foo”. There’s a lot of duplication in this song.
Extend the initial piping example to recreate the complete song, and use
functions to reduce the duplication.</p></li>
</ol>
</div>
</div>
<div id="functions-are-for-humans-and-computers" class="section level2">
<h2><span class="header-section-number">19.3</span> Functions are for humans and computers</h2>
<p>It’s important to remember that functions are not just for the computer, but are also for humans. R doesn’t care what your function is called, or what comments it contains, but these are important for human readers. This section discusses some things that you should bear in mind when writing functions that humans can understand.</p>
<p>The name of a function is important. Ideally, the name of your function will be short, but clearly evoke what the function does. That’s hard! But it’s better to be clear than short, as RStudio’s autocomplete makes it easy to type long names.</p>
<p>Generally, function names should be verbs, and arguments should be nouns. There are some exceptions: nouns are ok if the function computes a very well known noun (i.e. <code>mean()</code> is better than <code>compute_mean()</code>), or accessing some property of an object (i.e. <code>coef()</code> is better than <code>get_coefficients()</code>). A good sign that a noun might be a better choice is if you’re using a very broad verb like “get”, “compute”, “calculate”, or “determine”. Use your best judgement and don’t be afraid to rename a function if you figure out a better name later.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Too short</span>
<span class="kw">f</span>()

<span class="co"># Not a verb, or descriptive</span>
<span class="kw">my_awesome_function</span>()

<span class="co"># Long, but clear</span>
<span class="kw">impute_missing</span>()
<span class="kw">collapse_years</span>()</code></pre>
<p>If your function name is composed of multiple words, I recommend using “snake_case”, where each lowercase word is separated by an underscore. camelCase is a popular alternative. It doesn’t really matter which one you pick, the important thing is to be consistent: pick one or the other and stick with it. R itself is not very consistent, but there’s nothing you can do about that. Make sure you don’t fall into the same trap by making your code as consistent as possible.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Never do this!</span>
col_mins &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {}
rowMaxes &lt;-<span class="st"> </span><span class="cf">function</span>(y, x) {}</code></pre>
<p>If you have a family of functions that do similar things, make sure they have consistent names and arguments. Use a common prefix to indicate that they are connected. That’s better than a common suffix because autocomplete allows you to type the prefix and see all the members of the family.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Good</span>
<span class="kw">input_select</span>()
<span class="kw">input_checkbox</span>()
<span class="kw">input_text</span>()

<span class="co"># Not so good</span>
<span class="kw">select_input</span>()
<span class="kw">checkbox_input</span>()
<span class="kw">text_input</span>()</code></pre>
<p>A good example of this design is the stringr package: if you don’t remember exactly which function you need, you can type <code>str_</code> and jog your memory.</p>
<p>Where possible, avoid overriding existing functions and variables. It’s impossible to do in general because so many good names are already taken by other packages, but avoiding the most common names from base R will avoid confusion.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Don&#39;t do this!</span>
T &lt;-<span class="st"> </span><span class="ot">FALSE</span>
c &lt;-<span class="st"> </span><span class="dv">10</span>
mean &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">sum</span>(x)</code></pre>
<p>Use comments, lines starting with <code>#</code>, to explain the “why” of your code. You generally should avoid comments that explain the “what” or the “how”. If you can’t understand what the code does from reading it, you should think about how to rewrite it to be more clear. Do you need to add some intermediate variables with useful names? Do you need to break out a subcomponent of a large function so you can name it? However, your code can never capture the reasoning behind your decisions: why did you choose this approach instead of an alternative? What else did you try that didn’t work? It’s a great idea to capture that sort of thinking in a comment.</p>
<p>Another important use of comments is to break up your file into easily readable chunks. Use long lines of <code>-</code> and <code>=</code> to make it easy to spot the breaks.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load data --------------------------------------</span>

<span class="co"># Plot data --------------------------------------</span></code></pre>
<p>RStudio provides a keyboard shortcut to create these headers (Cmd/Ctrl + Shift + R), and will display them in the code navigation drop-down at the bottom-left of the editor:</p>
<p><img src="screenshots/rstudio-nav.png" width="125" style="display: block; margin: auto;" /></p>
<div id="exercises-48" class="section level3">
<h3><span class="header-section-number">19.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Read the source code for each of the following three functions, puzzle out
what they do, and then brainstorm better names.</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(string, prefix) {
  <span class="kw">substr</span>(string, <span class="dv">1</span>, <span class="kw">nchar</span>(prefix)) <span class="op">==</span><span class="st"> </span>prefix
}
f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">1</span>) <span class="kw">return</span>(<span class="ot">NULL</span>)
  x[<span class="op">-</span><span class="kw">length</span>(x)]
}
f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  <span class="kw">rep</span>(y, <span class="dt">length.out =</span> <span class="kw">length</span>(x))
}</code></pre></li>
<li><p>Take a function that you’ve written recently and spend 5 minutes
brainstorming a better name for it and its arguments.</p></li>
<li><p>Compare and contrast <code>rnorm()</code> and <code>MASS::mvrnorm()</code>. How could you make
them more consistent?</p></li>
<li><p>Make a case for why <code>norm_r()</code>, <code>norm_d()</code> etc would be better than
<code>rnorm()</code>, <code>dnorm()</code>. Make a case for the opposite.</p></li>
</ol>
</div>
</div>
<div id="conditional-execution" class="section level2">
<h2><span class="header-section-number">19.4</span> Conditional execution</h2>
<p>An <code>if</code> statement allows you to conditionally execute code. It looks like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (condition) {
  <span class="co"># code executed when condition is TRUE</span>
} <span class="cf">else</span> {
  <span class="co"># code executed when condition is FALSE</span>
}</code></pre>
<p>To get help on <code>if</code> you need to surround it in backticks: <code>?`if`</code>. The help isn’t particularly helpful if you’re not already an experienced programmer, but at least you know how to get to it!</p>
<p>Here’s a simple function that uses an <code>if</code> statement. The goal of this function is to return a logical vector describing whether or not each element of a vector is named.</p>
<pre class="sourceCode r"><code class="sourceCode r">has_name &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  nms &lt;-<span class="st"> </span><span class="kw">names</span>(x)
  <span class="cf">if</span> (<span class="kw">is.null</span>(nms)) {
    <span class="kw">rep</span>(<span class="ot">FALSE</span>, <span class="kw">length</span>(x))
  } <span class="cf">else</span> {
    <span class="op">!</span><span class="kw">is.na</span>(nms) <span class="op">&amp;</span><span class="st"> </span>nms <span class="op">!=</span><span class="st"> &quot;&quot;</span>
  }
}</code></pre>
<p>This function takes advantage of the standard return rule: a function returns the last value that it computed. Here that is either one of the two branches of the <code>if</code> statement.</p>
<div id="conditions" class="section level3">
<h3><span class="header-section-number">19.4.1</span> Conditions</h3>
<p>The <code>condition</code> must evaluate to either <code>TRUE</code> or <code>FALSE</code>. If it’s a vector, you’ll get a warning message; if it’s an <code>NA</code>, you’ll get an error. Watch out for these messages in your own code:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)) {}
<span class="co">#&gt; Warning in if (c(TRUE, FALSE)) {: the condition has length &gt; 1 and only the</span>
<span class="co">#&gt; first element will be used</span>
<span class="co">#&gt; NULL</span>

<span class="cf">if</span> (<span class="ot">NA</span>) {}
<span class="co">#&gt; Error in if (NA) {: missing value where TRUE/FALSE needed</span></code></pre>
<p>You can use <code>||</code> (or) and <code>&amp;&amp;</code> (and) to combine multiple logical expressions. These operators are “short-circuiting”: as soon as <code>||</code> sees the first <code>TRUE</code> it returns <code>TRUE</code> without computing anything else. As soon as <code>&amp;&amp;</code> sees the first <code>FALSE</code> it returns <code>FALSE</code>. You should never use <code>|</code> or <code>&amp;</code> in an <code>if</code> statement: these are vectorised operations that apply to multiple values (that’s why you use them in <code>filter()</code>). If you do have a logical vector, you can use <code>any()</code> or <code>all()</code> to collapse it to a single value.</p>
<p>Be careful when testing for equality. <code>==</code> is vectorised, which means that it’s easy to get more than one output. Either check the length is already 1, collapse with <code>all()</code> or <code>any()</code>, or use the non-vectorised <code>identical()</code>. <code>identical()</code> is very strict: it always returns either a single <code>TRUE</code> or a single <code>FALSE</code>, and doesn’t coerce types. This means that you need to be careful when comparing integers and doubles:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">identical</span>(0L, <span class="dv">0</span>)
<span class="co">#&gt; [1] FALSE</span></code></pre>
<p>You also need to be wary of floating point numbers:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
x
<span class="co">#&gt; [1] 2</span>
x <span class="op">==</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] FALSE</span>
x <span class="op">-</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] 4.44e-16</span></code></pre>
<p>Instead use <code>dplyr::near()</code> for comparisons, as described in <a href="#comparisons">comparisons</a>.</p>
<p>And remember, <code>x == NA</code> doesn’t do anything useful!</p>
</div>
<div id="multiple-conditions" class="section level3">
<h3><span class="header-section-number">19.4.2</span> Multiple conditions</h3>
<p>You can chain multiple if statements together:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (this) {
  <span class="co"># do that</span>
} <span class="cf">else</span> <span class="cf">if</span> (that) {
  <span class="co"># do something else</span>
} <span class="cf">else</span> {
  <span class="co"># </span>
}</code></pre>
<p>But if you end up with a very long series of chained <code>if</code> statements, you should consider rewriting. One useful technique is the <code>switch()</code> function. It allows you to evaluate selected code based on position or name.</p>
<pre><code>#&gt; function(x, y, op) {
#&gt;   switch(op,
#&gt;     plus = x + y,
#&gt;     minus = x - y,
#&gt;     times = x * y,
#&gt;     divide = x / y,
#&gt;     stop(&quot;Unknown op!&quot;)
#&gt;   )
#&gt; }</code></pre>
<p>Another useful function that can often eliminate long chains of <code>if</code> statements is <code>cut()</code>. It’s used to discretise continuous variables.</p>
</div>
<div id="code-style" class="section level3">
<h3><span class="header-section-number">19.4.3</span> Code style</h3>
<p>Both <code>if</code> and <code>function</code> should (almost) always be followed by squiggly brackets (<code>{}</code>), and the contents should be indented by two spaces. This makes it easier to see the hierarchy in your code by skimming the left-hand margin.</p>
<p>An opening curly brace should never go on its own line and should always be followed by a new line. A closing curly brace should always go on its own line, unless it’s followed by <code>else</code>. Always indent the code inside curly braces.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Good</span>
<span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;&amp;</span><span class="st"> </span>debug) {
  <span class="kw">message</span>(<span class="st">&quot;Y is negative&quot;</span>)
}

<span class="cf">if</span> (y <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
  <span class="kw">log</span>(x)
} <span class="cf">else</span> {
  y <span class="op">^</span><span class="st"> </span>x
}

<span class="co"># Bad</span>
<span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;&amp;</span><span class="st"> </span>debug)
<span class="kw">message</span>(<span class="st">&quot;Y is negative&quot;</span>)

<span class="cf">if</span> (y <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
  <span class="kw">log</span>(x)
} 
<span class="cf">else</span> {
  y <span class="op">^</span><span class="st"> </span>x
}</code></pre>
<p>It’s ok to drop the curly braces if you have a very short <code>if</code> statement that can fit on one line:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">10</span>
x &lt;-<span class="st"> </span><span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">20</span>) <span class="st">&quot;Too low&quot;</span> <span class="cf">else</span> <span class="st">&quot;Too high&quot;</span></code></pre>
<p>I recommend this only for very brief <code>if</code> statements. Otherwise, the full form is easier to read:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (y <span class="op">&lt;</span><span class="st"> </span><span class="dv">20</span>) {
  x &lt;-<span class="st"> &quot;Too low&quot;</span> 
} <span class="cf">else</span> {
  x &lt;-<span class="st"> &quot;Too high&quot;</span>
}</code></pre>
</div>
<div id="exercises-49" class="section level3">
<h3><span class="header-section-number">19.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What’s the difference between <code>if</code> and <code>ifelse()</code>? Carefully read the help
and construct three examples that illustrate the key differences.</p></li>
<li><p>Write a greeting function that says “good morning”, “good afternoon”,
or “good evening”, depending on the time of day. (Hint: use a time
argument that defaults to <code>lubridate::now()</code>. That will make it
easier to test your function.)</p></li>
<li><p>Implement a <code>fizzbuzz</code> function. It takes a single number as input. If
the number is divisible by three, it returns “fizz”. If it’s divisible by
five it returns “buzz”. If it’s divisible by three and five, it returns
“fizzbuzz”. Otherwise, it returns the number. Make sure you first write
working code before you create the function.</p></li>
<li><p>How could you use <code>cut()</code> to simplify this set of nested if-else statements?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (temp <span class="op">&lt;=</span><span class="st"> </span><span class="dv">0</span>) {
  <span class="st">&quot;freezing&quot;</span>
} <span class="cf">else</span> <span class="cf">if</span> (temp <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span>) {
  <span class="st">&quot;cold&quot;</span>
} <span class="cf">else</span> <span class="cf">if</span> (temp <span class="op">&lt;=</span><span class="st"> </span><span class="dv">20</span>) {
  <span class="st">&quot;cool&quot;</span>
} <span class="cf">else</span> <span class="cf">if</span> (temp <span class="op">&lt;=</span><span class="st"> </span><span class="dv">30</span>) {
  <span class="st">&quot;warm&quot;</span>
} <span class="cf">else</span> {
  <span class="st">&quot;hot&quot;</span>
}</code></pre>
<p>How would you change the call to <code>cut()</code> if I’d used <code>&lt;</code> instead of <code>&lt;=</code>?
What is the other chief advantage of <code>cut()</code> for this problem? (Hint:
what happens if you have many values in <code>temp</code>?)</p></li>
<li><p>What happens if you use <code>switch()</code> with numeric values?</p></li>
<li><p>What does this <code>switch()</code> call do? What happens if <code>x</code> is “e”?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">switch</span>(x, 
  <span class="dt">a =</span> ,
  <span class="dt">b =</span> <span class="st">&quot;ab&quot;</span>,
  <span class="dt">c =</span> ,
  <span class="dt">d =</span> <span class="st">&quot;cd&quot;</span>
)</code></pre>
<p>Experiment, then carefully read the documentation.</p></li>
</ol>
</div>
</div>
<div id="function-arguments" class="section level2">
<h2><span class="header-section-number">19.5</span> Function arguments</h2>
<p>The arguments to a function typically fall into two broad sets: one set supplies the <strong>data</strong> to compute on, and the other supplies arguments that control the <strong>details</strong> of the computation. For example:</p>
<ul>
<li><p>In <code>log()</code>, the data is <code>x</code>, and the detail is the <code>base</code> of the logarithm.</p></li>
<li><p>In <code>mean()</code>, the data is <code>x</code>, and the details are how much data to trim
from the ends (<code>trim</code>) and how to handle missing values (<code>na.rm</code>).</p></li>
<li><p>In <code>t.test()</code>, the data are <code>x</code> and <code>y</code>, and the details of the test are
<code>alternative</code>, <code>mu</code>, <code>paired</code>, <code>var.equal</code>, and <code>conf.level</code>.</p></li>
<li><p>In <code>str_c()</code> you can supply any number of strings to <code>...</code>, and the details
of the concatenation are controlled by <code>sep</code> and <code>collapse</code>.</p></li>
</ul>
<p>Generally, data arguments should come first. Detail arguments should go on the end, and usually should have default values. You specify a default value in the same way you call a function with a named argument:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Compute confidence interval around mean using normal approximation</span>
mean_ci &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">conf =</span> <span class="fl">0.95</span>) {
  se &lt;-<span class="st"> </span><span class="kw">sd</span>(x) <span class="op">/</span><span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">length</span>(x))
  alpha &lt;-<span class="st"> </span><span class="dv">1</span> <span class="op">-</span><span class="st"> </span>conf
  <span class="kw">mean</span>(x) <span class="op">+</span><span class="st"> </span>se <span class="op">*</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="kw">c</span>(alpha <span class="op">/</span><span class="st"> </span><span class="dv">2</span>, <span class="dv">1</span> <span class="op">-</span><span class="st"> </span>alpha <span class="op">/</span><span class="st"> </span><span class="dv">2</span>))
}

x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
<span class="kw">mean_ci</span>(x)
<span class="co">#&gt; [1] 0.498 0.610</span>
<span class="kw">mean_ci</span>(x, <span class="dt">conf =</span> <span class="fl">0.99</span>)
<span class="co">#&gt; [1] 0.480 0.628</span></code></pre>
<p>The default value should almost always be the most common value. The few exceptions to this rule are to do with safety. For example, it makes sense for <code>na.rm</code> to default to <code>FALSE</code> because missing values are important. Even though <code>na.rm = TRUE</code> is what you usually put in your code, it’s a bad idea to silently ignore missing values by default.</p>
<p>When you call a function, you typically omit the names of the data arguments, because they are used so commonly. If you override the default value of a detail argument, you should use the full name:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Good</span>
<span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

<span class="co"># Bad</span>
<span class="kw">mean</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, , <span class="ot">FALSE</span>)
<span class="kw">mean</span>(, <span class="ot">TRUE</span>, <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="ot">NA</span>))</code></pre>
<p>You can refer to an argument by its unique prefix (e.g. <code>mean(x, n = TRUE)</code>), but this is generally best avoided given the possibilities for confusion.</p>
<p>Notice that when you call a function, you should place a space around <code>=</code> in function calls, and always put a space after a comma, not before (just like in regular English). Using whitespace makes it easier to skim the function for the important components.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Good</span>
average &lt;-<span class="st"> </span><span class="kw">mean</span>(feet <span class="op">/</span><span class="st"> </span><span class="dv">12</span> <span class="op">+</span><span class="st"> </span>inches, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)

<span class="co"># Bad</span>
average&lt;-<span class="kw">mean</span>(feet<span class="op">/</span><span class="dv">12</span><span class="op">+</span>inches,<span class="dt">na.rm=</span><span class="ot">TRUE</span>)</code></pre>
<div id="choosing-names" class="section level3">
<h3><span class="header-section-number">19.5.1</span> Choosing names</h3>
<p>The names of the arguments are also important. R doesn’t care, but the readers of your code (including future-you!) will. Generally you should prefer longer, more descriptive names, but there are a handful of very common, very short names. It’s worth memorising these:</p>
<ul>
<li><code>x</code>, <code>y</code>, <code>z</code>: vectors.</li>
<li><code>w</code>: a vector of weights.</li>
<li><code>df</code>: a data frame.</li>
<li><code>i</code>, <code>j</code>: numeric indices (typically rows and columns).</li>
<li><code>n</code>: length, or number of rows.</li>
<li><code>p</code>: number of columns.</li>
</ul>
<p>Otherwise, consider matching names of arguments in existing R functions. For example, use <code>na.rm</code> to determine if missing values should be removed.</p>
</div>
<div id="checking-values" class="section level3">
<h3><span class="header-section-number">19.5.2</span> Checking values</h3>
<p>As you start to write more functions, you’ll eventually get to the point where you don’t remember exactly how your function works. At this point it’s easy to call your function with invalid inputs. To avoid this problem, it’s often useful to make constraints explicit. For example, imagine you’ve written some functions for computing weighted summary statistics:</p>
<pre class="sourceCode r"><code class="sourceCode r">wt_mean &lt;-<span class="st"> </span><span class="cf">function</span>(x, w) {
  <span class="kw">sum</span>(x <span class="op">*</span><span class="st"> </span>w) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(w)
}
wt_var &lt;-<span class="st"> </span><span class="cf">function</span>(x, w) {
  mu &lt;-<span class="st"> </span><span class="kw">wt_mean</span>(x, w)
  <span class="kw">sum</span>(w <span class="op">*</span><span class="st"> </span>(x <span class="op">-</span><span class="st"> </span>mu) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(w)
}
wt_sd &lt;-<span class="st"> </span><span class="cf">function</span>(x, w) {
  <span class="kw">sqrt</span>(<span class="kw">wt_var</span>(x, w))
}</code></pre>
<p>What happens if <code>x</code> and <code>w</code> are not the same length?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">wt_mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)
<span class="co">#&gt; [1] 7.67</span></code></pre>
<p>In this case, because of R’s vector recycling rules, we don’t get an error.</p>
<p>It’s good practice to check important preconditions, and throw an error (with <code>stop()</code>), if they are not true:</p>
<pre class="sourceCode r"><code class="sourceCode r">wt_mean &lt;-<span class="st"> </span><span class="cf">function</span>(x, w) {
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(w)) {
    <span class="kw">stop</span>(<span class="st">&quot;`x` and `w` must be the same length&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
  <span class="kw">sum</span>(w <span class="op">*</span><span class="st"> </span>x) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(w)
}</code></pre>
<p>Be careful not to take this too far. There’s a tradeoff between how much time you spend making your function robust, versus how long you spend writing it. For example, if you also added a <code>na.rm</code> argument, I probably wouldn’t check it carefully:</p>
<pre class="sourceCode r"><code class="sourceCode r">wt_mean &lt;-<span class="st"> </span><span class="cf">function</span>(x, w, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.logical</span>(na.rm)) {
    <span class="kw">stop</span>(<span class="st">&quot;`na.rm` must be logical&quot;</span>)
  }
  <span class="cf">if</span> (<span class="kw">length</span>(na.rm) <span class="op">!=</span><span class="st"> </span><span class="dv">1</span>) {
    <span class="kw">stop</span>(<span class="st">&quot;`na.rm` must be length 1&quot;</span>)
  }
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">!=</span><span class="st"> </span><span class="kw">length</span>(w)) {
    <span class="kw">stop</span>(<span class="st">&quot;`x` and `w` must be the same length&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
  }
  
  <span class="cf">if</span> (na.rm) {
    miss &lt;-<span class="st"> </span><span class="kw">is.na</span>(x) <span class="op">|</span><span class="st"> </span><span class="kw">is.na</span>(w)
    x &lt;-<span class="st"> </span>x[<span class="op">!</span>miss]
    w &lt;-<span class="st"> </span>w[<span class="op">!</span>miss]
  }
  <span class="kw">sum</span>(w <span class="op">*</span><span class="st"> </span>x) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(w)
}</code></pre>
<p>This is a lot of extra work for little additional gain. A useful compromise is the built-in <code>stopifnot()</code>: it checks that each argument is <code>TRUE</code>, and produces a generic error message if not.</p>
<pre class="sourceCode r"><code class="sourceCode r">wt_mean &lt;-<span class="st"> </span><span class="cf">function</span>(x, w, <span class="dt">na.rm =</span> <span class="ot">FALSE</span>) {
  <span class="kw">stopifnot</span>(<span class="kw">is.logical</span>(na.rm), <span class="kw">length</span>(na.rm) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)
  <span class="kw">stopifnot</span>(<span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="kw">length</span>(w))
  
  <span class="cf">if</span> (na.rm) {
    miss &lt;-<span class="st"> </span><span class="kw">is.na</span>(x) <span class="op">|</span><span class="st"> </span><span class="kw">is.na</span>(w)
    x &lt;-<span class="st"> </span>x[<span class="op">!</span>miss]
    w &lt;-<span class="st"> </span>w[<span class="op">!</span>miss]
  }
  <span class="kw">sum</span>(w <span class="op">*</span><span class="st"> </span>x) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(w)
}
<span class="kw">wt_mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">6</span>, <span class="dv">6</span><span class="op">:</span><span class="dv">1</span>, <span class="dt">na.rm =</span> <span class="st">&quot;foo&quot;</span>)
<span class="co">#&gt; Error: is.logical(na.rm) is not TRUE</span></code></pre>
<p>Note that when using <code>stopifnot()</code> you assert what should be true rather than checking for what might be wrong.</p>
</div>
<div id="dot-dot-dot" class="section level3">
<h3><span class="header-section-number">19.5.3</span> Dot-dot-dot (…)</h3>
<p>Many functions in R take an arbitrary number of inputs:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)
<span class="co">#&gt; [1] 55</span>
stringr<span class="op">::</span><span class="kw">str_c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>, <span class="st">&quot;f&quot;</span>)
<span class="co">#&gt; [1] &quot;abcdef&quot;</span></code></pre>
<p>How do these functions work? They rely on a special argument: <code>...</code> (pronounced dot-dot-dot). This special argument captures any number of arguments that aren’t otherwise matched.</p>
<p>It’s useful because you can then send those <code>...</code> on to another function. This is a useful catch-all if your function primarily wraps another function. For example, I commonly create these helper functions that wrap around <code>str_c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">commas &lt;-<span class="st"> </span><span class="cf">function</span>(...) stringr<span class="op">::</span><span class="kw">str_c</span>(..., <span class="dt">collapse =</span> <span class="st">&quot;, &quot;</span>)
<span class="kw">commas</span>(letters[<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>])
<span class="co">#&gt; [1] &quot;a, b, c, d, e, f, g, h, i, j&quot;</span>

rule &lt;-<span class="st"> </span><span class="cf">function</span>(..., <span class="dt">pad =</span> <span class="st">&quot;-&quot;</span>) {
  title &lt;-<span class="st"> </span><span class="kw">paste0</span>(...)
  width &lt;-<span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;width&quot;</span>) <span class="op">-</span><span class="st"> </span><span class="kw">nchar</span>(title) <span class="op">-</span><span class="st"> </span><span class="dv">5</span>
  <span class="kw">cat</span>(title, <span class="st">&quot; &quot;</span>, stringr<span class="op">::</span><span class="kw">str_dup</span>(pad, width), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
}
<span class="kw">rule</span>(<span class="st">&quot;Important output&quot;</span>)
<span class="co">#&gt; Important output ------------------------------------------------------</span></code></pre>
<p>Here <code>...</code> lets me forward on any arguments that I don’t want to deal with to <code>str_c()</code>. It’s a very convenient technique. But it does come at a price: any misspelled arguments will not raise an error. This makes it easy for typos to go unnoticed:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>)
<span class="kw">sum</span>(x, <span class="dt">na.mr =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 4</span></code></pre>
<p>If you just want to capture the values of the <code>...</code>, use <code>list(...)</code>.</p>
</div>
<div id="lazy-evaluation" class="section level3">
<h3><span class="header-section-number">19.5.4</span> Lazy evaluation</h3>
<p>Arguments in R are lazily evaluated: they’re not computed until they’re needed. That means if they’re never used, they’re never called. This is an important property of R as a programming language, but is generally not important when you’re writing your own functions for data analysis. You can read more about lazy evaluation at <a href="http://adv-r.had.co.nz/Functions.html#lazy-evaluation" class="uri">http://adv-r.had.co.nz/Functions.html#lazy-evaluation</a>.</p>
</div>
<div id="exercises-50" class="section level3">
<h3><span class="header-section-number">19.5.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does <code>commas(letters, collapse = &quot;-&quot;)</code> do? Why?</p></li>
<li><p>It’d be nice if you could supply multiple characters to the <code>pad</code> argument,
e.g. <code>rule(&quot;Title&quot;, pad = &quot;-+&quot;)</code>. Why doesn’t this currently work? How
could you fix it?</p></li>
<li><p>What does the <code>trim</code> argument to <code>mean()</code> do? When might you use it?</p></li>
<li><p>The default value for the <code>method</code> argument to <code>cor()</code> is
<code>c(&quot;pearson&quot;, &quot;kendall&quot;, &quot;spearman&quot;)</code>. What does that mean? What
value is used by default?</p></li>
</ol>
</div>
</div>
<div id="return-values" class="section level2">
<h2><span class="header-section-number">19.6</span> Return values</h2>
<p>Figuring out what your function should return is usually straightforward: it’s why you created the function in the first place! There are two things you should consider when returning a value:</p>
<ol style="list-style-type: decimal">
<li><p>Does returning early make your function easier to read?</p></li>
<li><p>Can you make your function pipeable?</p></li>
</ol>
<div id="explicit-return-statements" class="section level3">
<h3><span class="header-section-number">19.6.1</span> Explicit return statements</h3>
<p>The value returned by the function is usually the last statement it evaluates, but you can choose to return early by using <code>return()</code>. I think it’s best to save the use of <code>return()</code> to signal that you can return early with a simpler solution. A common reason to do this is because the inputs are empty:</p>
<pre class="sourceCode r"><code class="sourceCode r">complicated_function &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, z) {
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">0</span> <span class="op">||</span><span class="st"> </span><span class="kw">length</span>(y) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) {
    <span class="kw">return</span>(<span class="dv">0</span>)
  }
    
  <span class="co"># Complicated code here</span>
}</code></pre>
<p>Another reason is because you have a <code>if</code> statement with one complex block and one simple block. For example, you might write an if statement like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="cf">if</span> (x) {
    <span class="co"># Do </span>
    <span class="co"># something</span>
    <span class="co"># that</span>
    <span class="co"># takes</span>
    <span class="co"># many</span>
    <span class="co"># lines</span>
    <span class="co"># to</span>
    <span class="co"># express</span>
  } <span class="cf">else</span> {
    <span class="co"># return something short</span>
  }
}</code></pre>
<p>But if the first block is very long, by the time you get to the <code>else</code>, you’ve forgotten the <code>condition</code>. One way to rewrite it is to use an early return for the simple case:</p>
<pre class="sourceCode r"><code class="sourceCode r">
f &lt;-<span class="st"> </span><span class="cf">function</span>() {
  <span class="cf">if</span> (<span class="op">!</span>x) {
    <span class="kw">return</span>(something_short)
  }

  <span class="co"># Do </span>
  <span class="co"># something</span>
  <span class="co"># that</span>
  <span class="co"># takes</span>
  <span class="co"># many</span>
  <span class="co"># lines</span>
  <span class="co"># to</span>
  <span class="co"># express</span>
}</code></pre>
<p>This tends to make the code easier to understand, because you don’t need quite so much context to understand it.</p>
</div>
<div id="writing-pipeable-functions" class="section level3">
<h3><span class="header-section-number">19.6.2</span> Writing pipeable functions</h3>
<p>If you want to write your own pipeable functions, it’s important to think about the return value. Knowing the return value’s object type will mean that your pipeline will “just work”. For example, with dplyr and tidyr the object type is the data frame.</p>
<p>There are two basic types of pipeable functions: transformations and side-effects. With <strong>transformations</strong>, an object is passed to the function’s first argument and a modified object is returned. With <strong>side-effects</strong>, the passed object is not transformed. Instead, the function performs an action on the object, like drawing a plot or saving a file. Side-effects functions should “invisibly” return the first argument, so that while they’re not printed they can still be used in a pipeline. For example, this simple function prints the number of missing values in a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">show_missings &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  n &lt;-<span class="st"> </span><span class="kw">sum</span>(<span class="kw">is.na</span>(df))
  <span class="kw">cat</span>(<span class="st">&quot;Missing values: &quot;</span>, n, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep =</span> <span class="st">&quot;&quot;</span>)
  
  <span class="kw">invisible</span>(df)
}</code></pre>
<p>If we call it interactively, the <code>invisible()</code> means that the input <code>df</code> doesn’t get printed out:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">show_missings</span>(mtcars)
<span class="co">#&gt; Missing values: 0</span></code></pre>
<p>But it’s still there, it’s just not printed by default:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">show_missings</span>(mtcars) 
<span class="co">#&gt; Missing values: 0</span>
<span class="kw">class</span>(x)
<span class="co">#&gt; [1] &quot;data.frame&quot;</span>
<span class="kw">dim</span>(x)
<span class="co">#&gt; [1] 32 11</span></code></pre>
<p>And we can still use it in a pipe:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">show_missings</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">mpg =</span> <span class="kw">ifelse</span>(mpg <span class="op">&lt;</span><span class="st"> </span><span class="dv">20</span>, <span class="ot">NA</span>, mpg)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">show_missings</span>() 
<span class="co">#&gt; Missing values: 0</span>
<span class="co">#&gt; Missing values: 18</span></code></pre>
</div>
</div>
<div id="environment" class="section level2">
<h2><span class="header-section-number">19.7</span> Environment</h2>
<p>The last component of a function is its environment. This is not something you need to understand deeply when you first start writing functions. However, it’s important to know a little bit about environments because they are crucial to how functions work. The environment of a function controls how R finds the value associated with a name. For example, take this function:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  x <span class="op">+</span><span class="st"> </span>y
} </code></pre>
<p>In many programming languages, this would be an error, because <code>y</code> is not defined inside the function. In R, this is valid code because R uses rules called <strong>lexical scoping</strong> to find the value associated with a name. Since <code>y</code> is not defined inside the function, R will look in the <strong>environment</strong> where the function was defined:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">100</span>
<span class="kw">f</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] 110</span>

y &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="kw">f</span>(<span class="dv">10</span>)
<span class="co">#&gt; [1] 1010</span></code></pre>
<p>This behaviour seems like a recipe for bugs, and indeed you should avoid creating functions like this deliberately, but by and large it doesn’t cause too many problems (especially if you regularly restart R to get to a clean slate).</p>
<p>The advantage of this behaviour is that from a language standpoint it allows R to be very consistent. Every name is looked up using the same set of rules. For <code>f()</code> that includes the behaviour of two things that you might not expect: <code>{</code> and <code>+</code>. This allows you to do devious things like:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">+</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) {
  <span class="cf">if</span> (<span class="kw">runif</span>(<span class="dv">1</span>) <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.1</span>) {
    <span class="kw">sum</span>(x, y)
  } <span class="cf">else</span> {
    <span class="kw">sum</span>(x, y) <span class="op">*</span><span class="st"> </span><span class="fl">1.1</span>
  }
}
<span class="kw">table</span>(<span class="kw">replicate</span>(<span class="dv">1000</span>, <span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span>))
<span class="co">#&gt; </span>
<span class="co">#&gt;   3 3.3 </span>
<span class="co">#&gt; 100 900</span>
<span class="kw">rm</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>)</code></pre>
<p>This is a common phenomenon in R. R places few limits on your power. You can do many things that you can’t do in other programming languages. You can do many things that 99% of the time are extremely ill-advised (like overriding how addition works!). But this power and flexibility is what makes tools like ggplot2 and dplyr possible. Learning how to make best use of this flexibility is beyond the scope of this book, but you can read about in <em>Advanced R</em><span id="fn25" class="footnote" data-pagedown-footnote-number="25" style="white-space: pre-line;"><a href="http://adv-r.had.co.nz" class="uri">http://adv-r.had.co.nz</a></span>.</p>
<!--chapter:end:functions.Rmd-->
</div>
</div>
<div id="vectors" class="section level1">
<h1><span class="header-section-number">20</span> Vectors</h1>
<div id="introduction-13" class="section level2">
<h2><span class="header-section-number">20.1</span> Introduction</h2>
<p>So far this book has focussed on tibbles and packages that work with them. But as you start to write your own functions, and dig deeper into R, you need to learn about vectors, the objects that underlie tibbles. If you’ve learned R in a more traditional way, you’re probably already familiar with vectors, as most R resources start with vectors and work their way up to tibbles. I think it’s better to start with tibbles because they’re immediately useful, and then work your way down to the underlying components.</p>
<p>Vectors are particularly important as most of the functions you will write will work with vectors. It is possible to write functions that work with tibbles (like ggplot2, dplyr, and tidyr), but the tools you need to write such functions are currently idiosyncratic and immature. I am working on a better approach, <a href="https://github.com/hadley/lazyeval" class="uri">https://github.com/hadley/lazyeval</a>, but it will not be ready in time for the publication of the book. Even when complete, you’ll still need to understand vectors, it’ll just make it easier to write a user-friendly layer on top.</p>
<div id="prerequisites-13" class="section level3">
<h3><span class="header-section-number">20.1.1</span> Prerequisites</h3>
<p>The focus of this chapter is on base R data structures, so it isn’t essential to load any packages. We will, however, use a handful of functions from the <strong>purrr</strong> package to avoid some inconsistencies in base R.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="vector-basics" class="section level2">
<h2><span class="header-section-number">20.2</span> Vector basics</h2>
<p>There are two types of vectors:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Atomic</strong> vectors, of which there are six types:
<strong>logical</strong>, <strong>integer</strong>, <strong>double</strong>, <strong>character</strong>, <strong>complex</strong>, and
<strong>raw</strong>. Integer and double vectors are collectively known as
<strong>numeric</strong> vectors.</p></li>
<li><p><strong>Lists</strong>, which are sometimes called recursive vectors because lists can
contain other lists.</p></li>
</ol>
<p>The chief difference between atomic vectors and lists is that atomic vectors are <strong>homogeneous</strong>, while lists can be <strong>heterogeneous</strong>. There’s one other related object: <code>NULL</code>. <code>NULL</code> is often used to represent the absence of a vector (as opposed to <code>NA</code> which is used to represent the absence of a value in a vector). <code>NULL</code> typically behaves like a vector of length 0. Figure <a href="#fig:datatypes">20.1</a> summarises the interrelationships.</p>
<div class="figure" style="text-align: center"><span id="fig:datatypes"></span>
<img src="diagrams/data-structures-overview.png" alt="The hierarchy of R's vector types" width="50%" />
<p class="caption">
Figure 20.1: The hierarchy of R’s vector types
</p>
</div>
<p>Every vector has two key properties:</p>
<ol style="list-style-type: decimal">
<li><p>Its <strong>type</strong>, which you can determine with <code>typeof()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(letters)
<span class="co">#&gt; [1] &quot;character&quot;</span>
<span class="kw">typeof</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="co">#&gt; [1] &quot;integer&quot;</span></code></pre></li>
<li><p>Its <strong>length</strong>, which you can determine with <code>length()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)
<span class="kw">length</span>(x)
<span class="co">#&gt; [1] 3</span></code></pre></li>
</ol>
<p>Vectors can also contain arbitrary additional metadata in the form of attributes. These attributes are used to create <strong>augmented vectors</strong> which build on additional behaviour. There are three important types of augmented vector:</p>
<ul>
<li>Factors are built on top of integer vectors.</li>
<li>Dates and date-times are built on top of numeric vectors.</li>
<li>Data frames and tibbles are built on top of lists.</li>
</ul>
<p>This chapter will introduce you to these important vectors from simplest to most complicated. You’ll start with atomic vectors, then build up to lists, and finish off with augmented vectors.</p>
</div>
<div id="important-types-of-atomic-vector" class="section level2">
<h2><span class="header-section-number">20.3</span> Important types of atomic vector</h2>
<p>The four most important types of atomic vector are logical, integer, double, and character. Raw and complex are rarely used during a data analysis, so I won’t discuss them here.</p>
<div id="logical" class="section level3">
<h3><span class="header-section-number">20.3.1</span> Logical</h3>
<p>Logical vectors are the simplest type of atomic vector because they can take only three possible values: <code>FALSE</code>, <code>TRUE</code>, and <code>NA</code>. Logical vectors are usually constructed with comparison operators, as described in <a href="#comparisons">comparisons</a>. You can also create them by hand with <code>c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">%%</span><span class="st"> </span><span class="dv">3</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>
<span class="co">#&gt;  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE</span>

<span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">NA</span>)
<span class="co">#&gt; [1]  TRUE  TRUE FALSE    NA</span></code></pre>
</div>
<div id="numeric" class="section level3">
<h3><span class="header-section-number">20.3.2</span> Numeric</h3>
<p>Integer and double vectors are known collectively as numeric vectors. In R, numbers are doubles by default. To make an integer, place an <code>L</code> after the number:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="dv">1</span>)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">typeof</span>(1L)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="fl">1.5</span>L
<span class="co">#&gt; [1] 1.5</span></code></pre>
<p>The distinction between integers and doubles is not usually important, but there are two important differences that you should be aware of:</p>
<ol style="list-style-type: decimal">
<li><p>Doubles are approximations. Doubles represent floating point numbers that
can not always be precisely represented with a fixed amount of memory.
This means that you should consider all doubles to be approximations.
For example, what is square of the square root of two?</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">2</span>) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
x
<span class="co">#&gt; [1] 2</span>
x <span class="op">-</span><span class="st"> </span><span class="dv">2</span>
<span class="co">#&gt; [1] 4.44e-16</span></code></pre>
<p>This behaviour is common when working with floating point numbers: most
calculations include some approximation error. Instead of comparing floating
point numbers using <code>==</code>, you should use <code>dplyr::near()</code> which allows for
some numerical tolerance.</p></li>
<li><p>Integers have one special value: <code>NA</code>, while doubles have four:
<code>NA</code>, <code>NaN</code>, <code>Inf</code> and <code>-Inf</code>. All three special values <code>NaN</code>, <code>Inf</code> and <code>-Inf</code> can arise during division:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>) <span class="op">/</span><span class="st"> </span><span class="dv">0</span>
<span class="co">#&gt; [1] -Inf  NaN  Inf</span></code></pre>
<p>Avoid using <code>==</code> to check for these other special values. Instead use the
helper functions <code>is.finite()</code>, <code>is.infinite()</code>, and <code>is.nan()</code>:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>0</th>
<th>Inf</th>
<th>NA</th>
<th>NaN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>is.finite()</code></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is.infinite()</code></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is.na()</code></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr class="even">
<td><code>is.nan()</code></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
<div id="character" class="section level3">
<h3><span class="header-section-number">20.3.3</span> Character</h3>
<p>Character vectors are the most complex type of atomic vector, because each element of a character vector is a string, and a string can contain an arbitrary amount of data.</p>
<p>You’ve already learned a lot about working with strings in <a href="#strings">strings</a>. Here I wanted to mention one important feature of the underlying string implementation: R uses a global string pool. This means that each unique string is only stored in memory once, and every use of the string points to that representation. This reduces the amount of memory needed by duplicated strings. You can see this behaviour in practice with <code>pryr::object_size()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;This is a reasonably long string.&quot;</span>
pryr<span class="op">::</span><span class="kw">object_size</span>(x)
<span class="co">#&gt; 136 B</span>

y &lt;-<span class="st"> </span><span class="kw">rep</span>(x, <span class="dv">1000</span>)
pryr<span class="op">::</span><span class="kw">object_size</span>(y)
<span class="co">#&gt; 8.13 kB</span></code></pre>
<p><code>y</code> doesn’t take up 1,000x as much memory as <code>x</code>, because each element of <code>y</code> is just a pointer to that same string. A pointer is 8 bytes, so 1000 pointers to a 136 B string is 8 * 1000 + 136 = 8.13 kB.</p>
</div>
<div id="missing-values-4" class="section level3">
<h3><span class="header-section-number">20.3.4</span> Missing values</h3>
<p>Note that each type of atomic vector has its own missing value:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="ot">NA</span>            <span class="co"># logical</span>
<span class="co">#&gt; [1] NA</span>
<span class="ot">NA_integer_</span>   <span class="co"># integer</span>
<span class="co">#&gt; [1] NA</span>
<span class="ot">NA_real_</span>      <span class="co"># double</span>
<span class="co">#&gt; [1] NA</span>
<span class="ot">NA_character_</span> <span class="co"># character</span>
<span class="co">#&gt; [1] NA</span></code></pre>
<p>Normally you don’t need to know about these different types because you can always use <code>NA</code> and it will be converted to the correct type using the implicit coercion rules described next. However, there are some functions that are strict about their inputs, so it’s useful to have this knowledge sitting in your back pocket so you can be specific when needed.</p>
</div>
<div id="exercises-51" class="section level3">
<h3><span class="header-section-number">20.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Describe the difference between <code>is.finite(x)</code> and <code>!is.infinite(x)</code>.</p></li>
<li><p>Read the source code for <code>dplyr::near()</code> (Hint: to see the source code,
drop the <code>()</code>). How does it work?</p></li>
<li><p>A logical vector can take 3 possible values. How many possible
values can an integer vector take? How many possible values can
a double take? Use google to do some research.</p></li>
<li><p>Brainstorm at least four functions that allow you to convert a double to an
integer. How do they differ? Be precise.</p></li>
<li><p>What functions from the readr package allow you to turn a string
into logical, integer, and double vector?</p></li>
</ol>
</div>
</div>
<div id="using-atomic-vectors" class="section level2">
<h2><span class="header-section-number">20.4</span> Using atomic vectors</h2>
<p>Now that you understand the different types of atomic vector, it’s useful to review some of the important tools for working with them. These include:</p>
<ol style="list-style-type: decimal">
<li><p>How to convert from one type to another, and when that happens
automatically.</p></li>
<li><p>How to tell if an object is a specific type of vector.</p></li>
<li><p>What happens when you work with vectors of different lengths.</p></li>
<li><p>How to name the elements of a vector.</p></li>
<li><p>How to pull out elements of interest.</p></li>
</ol>
<div id="coercion" class="section level3">
<h3><span class="header-section-number">20.4.1</span> Coercion</h3>
<p>There are two ways to convert, or coerce, one type of vector to another:</p>
<ol style="list-style-type: decimal">
<li><p>Explicit coercion happens when you call a function like <code>as.logical()</code>,
<code>as.integer()</code>, <code>as.double()</code>, or <code>as.character()</code>. Whenever you find
yourself using explicit coercion, you should always check whether you can
make the fix upstream, so that the vector never had the wrong type in
the first place. For example, you may need to tweak your readr
<code>col_types</code> specification.</p></li>
<li><p>Implicit coercion happens when you use a vector in a specific context
that expects a certain type of vector. For example, when you use a logical
vector with a numeric summary function, or when you use a double vector
where an integer vector is expected.</p></li>
</ol>
<p>Because explicit coercion is used relatively rarely, and is largely easy to understand, I’ll focus on implicit coercion here.</p>
<p>You’ve already seen the most important type of implicit coercion: using a logical vector in a numeric context. In this case <code>TRUE</code> is converted to <code>1</code> and <code>FALSE</code> converted to <code>0</code>. That means the sum of a logical vector is the number of trues, and the mean of a logical vector is the proportion of trues:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">20</span>, <span class="dv">100</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>)
y &lt;-<span class="st"> </span>x <span class="op">&gt;</span><span class="st"> </span><span class="dv">10</span>
<span class="kw">sum</span>(y)  <span class="co"># how many are greater than 10?</span>
<span class="co">#&gt; [1] 44</span>
<span class="kw">mean</span>(y) <span class="co"># what proportion are greater than 10?</span>
<span class="co">#&gt; [1] 0.44</span></code></pre>
<p>You may see some code (typically older) that relies on implicit coercion in the opposite direction, from integer to logical:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">if</span> (<span class="kw">length</span>(x)) {
  <span class="co"># do something</span>
}</code></pre>
<p>In this case, 0 is converted to <code>FALSE</code> and everything else is converted to <code>TRUE</code>. I think this makes it harder to understand your code, and I don’t recommend it. Instead be explicit: <code>length(x) &gt; 0</code>.</p>
<p>It’s also important to understand what happens when you try and create a vector containing multiple types with <code>c()</code>: the most complex type always wins.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="kw">c</span>(<span class="ot">TRUE</span>, 1L))
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">typeof</span>(<span class="kw">c</span>(1L, <span class="fl">1.5</span>))
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">typeof</span>(<span class="kw">c</span>(<span class="fl">1.5</span>, <span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; [1] &quot;character&quot;</span></code></pre>
<p>An atomic vector can not have a mix of different types because the type is a property of the complete vector, not the individual elements. If you need to mix multiple types in the same vector, you should use a list, which you’ll learn about shortly.</p>
</div>
<div id="test-functions" class="section level3">
<h3><span class="header-section-number">20.4.2</span> Test functions</h3>
<p>Sometimes you want to do different things based on the type of vector. One option is to use <code>typeof()</code>. Another is to use a test function which returns a <code>TRUE</code> or <code>FALSE</code>. Base R provides many functions like <code>is.vector()</code> and <code>is.atomic()</code>, but they often return surprising results. Instead, it’s safer to use the <code>is_*</code> functions provided by purrr, which are summarised in the table below.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>lgl</th>
<th>int</th>
<th>dbl</th>
<th>chr</th>
<th>list</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>is_logical()</code></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is_integer()</code></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_double()</code></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is_numeric()</code></td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_character()</code></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
</tr>
<tr class="even">
<td><code>is_atomic()</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_list()</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
</tr>
<tr class="even">
<td><code>is_vector()</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
<p>Each predicate also comes with a “scalar” version, like <code>is_scalar_atomic()</code>, which checks that the length is 1. This is useful, for example, if you want to check that an argument to your function is a single logical value.</p>
</div>
<div id="scalars-and-recycling-rules" class="section level3">
<h3><span class="header-section-number">20.4.3</span> Scalars and recycling rules</h3>
<p>As well as implicitly coercing the types of vectors to be compatible, R will also implicitly coerce the length of vectors. This is called vector <strong>recycling</strong>, because the shorter vector is repeated, or recycled, to the same length as the longer vector.</p>
<p>This is generally most useful when you are mixing vectors and “scalars”. I put scalars in quotes because R doesn’t actually have scalars: instead, a single number is a vector of length 1. Because there are no scalars, most built-in functions are <strong>vectorised</strong>, meaning that they will operate on a vector of numbers. That’s why, for example, this code works:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sample</span>(<span class="dv">10</span>) <span class="op">+</span><span class="st"> </span><span class="dv">100</span>
<span class="co">#&gt;  [1] 109 108 104 102 103 110 106 107 105 101</span>
<span class="kw">runif</span>(<span class="dv">10</span>) <span class="op">&gt;</span><span class="st"> </span><span class="fl">0.5</span>
<span class="co">#&gt;  [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE</span></code></pre>
<p>In R, basic mathematical operations work with vectors. That means that you should never need to perform explicit iteration when performing simple mathematical computations.</p>
<p>It’s intuitive what should happen if you add two vectors of the same length, or a vector and a “scalar”, but what happens if you add two vectors of different lengths?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">2</span>
<span class="co">#&gt;  [1]  2  4  4  6  6  8  8 10 10 12</span></code></pre>
<p>Here, R will expand the shortest vector to the same length as the longest, so called recycling. This is silent except when the length of the longer is not an integer multiple of the length of the shorter:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="dv">1</span><span class="op">:</span><span class="dv">10</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span>
<span class="co">#&gt; Warning in 1:10 + 1:3: longer object length is not a multiple of shorter</span>
<span class="co">#&gt; object length</span>
<span class="co">#&gt;  [1]  2  4  6  5  7  9  8 10 12 11</span></code></pre>
<p>While vector recycling can be used to create very succinct, clever code, it can also silently conceal problems. For this reason, the vectorised functions in tidyverse will throw errors when you recycle anything other than a scalar. If you do want to recycle, you’ll need to do it yourself with <code>rep()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>)
<span class="co">#&gt; Error: Tibble columns must have consistent lengths, only values of length one are recycled:</span>
<span class="co">#&gt; * Length 2: Column `y`</span>
<span class="co">#&gt; * Length 4: Column `x`</span>

<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dv">2</span>))
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1     1</span>
<span class="co">#&gt; 2     2     2</span>
<span class="co">#&gt; 3     3     1</span>
<span class="co">#&gt; 4     4     2</span>

<span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dt">y =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">each =</span> <span class="dv">2</span>))
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;int&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1     1     1</span>
<span class="co">#&gt; 2     2     1</span>
<span class="co">#&gt; 3     3     2</span>
<span class="co">#&gt; 4     4     2</span></code></pre>
</div>
<div id="naming-vectors" class="section level3">
<h3><span class="header-section-number">20.4.4</span> Naming vectors</h3>
<p>All types of vectors can be named. You can name them during creation with <code>c()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(<span class="dt">x =</span> <span class="dv">1</span>, <span class="dt">y =</span> <span class="dv">2</span>, <span class="dt">z =</span> <span class="dv">4</span>)
<span class="co">#&gt; x y z </span>
<span class="co">#&gt; 1 2 4</span></code></pre>
<p>Or after the fact with <code>purrr::set_names()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set_names</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>))
<span class="co">#&gt; a b c </span>
<span class="co">#&gt; 1 2 3</span></code></pre>
<p>Named vectors are most useful for subsetting, described next.</p>
</div>
<div id="vector-subsetting" class="section level3">
<h3><span class="header-section-number">20.4.5</span> Subsetting</h3>
<p>So far we’ve used <code>dplyr::filter()</code> to filter the rows in a tibble. <code>filter()</code> only works with tibble, so we’ll need new tool for vectors: <code>[</code>. <code>[</code> is the subsetting function, and is called like <code>x[a]</code>. There are four types of things that you can subset a vector with:</p>
<ol style="list-style-type: decimal">
<li><p>A numeric vector containing only integers. The integers must either be all
positive, all negative, or zero.</p>
<p>Subsetting with positive integers keeps the elements at those positions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;one&quot;</span>, <span class="st">&quot;two&quot;</span>, <span class="st">&quot;three&quot;</span>, <span class="st">&quot;four&quot;</span>, <span class="st">&quot;five&quot;</span>)
x[<span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>)]
<span class="co">#&gt; [1] &quot;three&quot; &quot;two&quot;   &quot;five&quot;</span></code></pre>
<p>By repeating a position, you can actually make a longer output than
input:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">5</span>, <span class="dv">2</span>)]
<span class="co">#&gt; [1] &quot;one&quot;  &quot;one&quot;  &quot;five&quot; &quot;five&quot; &quot;five&quot; &quot;two&quot;</span></code></pre>
<p>Negative values drop the elements at the specified positions:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">-3</span>, <span class="dv">-5</span>)]
<span class="co">#&gt; [1] &quot;two&quot;  &quot;four&quot;</span></code></pre>
<p>It’s an error to mix positive and negative values:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-1</span>)]
<span class="co">#&gt; Error in x[c(1, -1)]: only 0&#39;s may be mixed with negative subscripts</span></code></pre>
<p>The error message mentions subsetting with zero, which returns no values:</p>
<pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">0</span>]
<span class="co">#&gt; character(0)</span></code></pre>
<p>This is not useful very often, but it can be helpful if you want to create
unusual data structures to test your functions with.</p></li>
<li><p>Subsetting with a logical vector keeps all values corresponding to a
<code>TRUE</code> value. This is most often useful in conjunction with the
comparison functions.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">3</span>, <span class="ot">NA</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="ot">NA</span>)

<span class="co"># All non-missing values of x</span>
x[<span class="op">!</span><span class="kw">is.na</span>(x)]
<span class="co">#&gt; [1] 10  3  5  8  1</span>

<span class="co"># All even (or missing!) values of x</span>
x[x <span class="op">%%</span><span class="st"> </span><span class="dv">2</span> <span class="op">==</span><span class="st"> </span><span class="dv">0</span>]
<span class="co">#&gt; [1] 10 NA  8 NA</span></code></pre></li>
<li><p>If you have a named vector, you can subset it with a character vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">abc =</span> <span class="dv">1</span>, <span class="dt">def =</span> <span class="dv">2</span>, <span class="dt">xyz =</span> <span class="dv">5</span>)
x[<span class="kw">c</span>(<span class="st">&quot;xyz&quot;</span>, <span class="st">&quot;def&quot;</span>)]
<span class="co">#&gt; xyz def </span>
<span class="co">#&gt;   5   2</span></code></pre>
<p>Like with positive integers, you can also use a character vector to
duplicate individual entries.</p></li>
<li><p>The simplest type of subsetting is nothing, <code>x[]</code>, which returns the
complete <code>x</code>. This is not useful for subsetting vectors, but it is useful
when subsetting matrices (and other high dimensional structures) because
it lets you select all the rows or all the columns, by leaving that
index blank. For example, if <code>x</code> is 2d, <code>x[1, ]</code> selects the first row and
all the columns, and <code>x[, -1]</code> selects all rows and all columns except
the first.</p></li>
</ol>
<p>To learn more about the applications of subsetting, reading the “Subsetting” chapter of <em>Advanced R</em>: <a href="http://adv-r.had.co.nz/Subsetting.html#applications" class="uri">http://adv-r.had.co.nz/Subsetting.html#applications</a>.</p>
<p>There is an important variation of <code>[</code> called <code>[[</code>. <code>[[</code> only ever extracts a single element, and always drops names. It’s a good idea to use it whenever you want to make it clear that you’re extracting a single item, as in a for loop. The distinction between <code>[</code> and <code>[[</code> is most important for lists, as we’ll see shortly.</p>
</div>
<div id="exercises-52" class="section level3">
<h3><span class="header-section-number">20.4.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does <code>mean(is.na(x))</code> tell you about a vector <code>x</code>? What about
<code>sum(!is.finite(x))</code>?</p></li>
<li><p>Carefully read the documentation of <code>is.vector()</code>. What does it actually
test for? Why does <code>is.atomic()</code> not agree with the definition of
atomic vectors above?</p></li>
<li><p>Compare and contrast <code>setNames()</code> with <code>purrr::set_names()</code>.</p></li>
<li><p>Create functions that take a vector as input and returns:</p>
<ol style="list-style-type: decimal">
<li><p>The last value. Should you use <code>[</code> or <code>[[</code>?</p></li>
<li><p>The elements at even numbered positions.</p></li>
<li><p>Every element except the last value.</p></li>
<li><p>Only even numbers (and no missing values).</p></li>
</ol></li>
<li><p>Why is <code>x[-which(x &gt; 0)]</code> not the same as <code>x[x &lt;= 0]</code>?</p></li>
<li><p>What happens when you subset with a positive integer that’s bigger
than the length of the vector? What happens when you subset with a
name that doesn’t exist?</p></li>
</ol>
</div>
</div>
<div id="lists" class="section level2">
<h2><span class="header-section-number">20.5</span> Recursive vectors (lists)</h2>
<p>Lists are a step up in complexity from atomic vectors, because lists can contain other lists. This makes them suitable for representing hierarchical or tree-like structures. You create a list with <code>list()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
x
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1] 3</span></code></pre>
<p>A very useful tool for working with lists is <code>str()</code> because it focusses on the <strong>str</strong>ucture, not the contents.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(x)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num 1</span>
<span class="co">#&gt;  $ : num 2</span>
<span class="co">#&gt;  $ : num 3</span>

x_named &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">3</span>)
<span class="kw">str</span>(x_named)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ a: num 1</span>
<span class="co">#&gt;  $ b: num 2</span>
<span class="co">#&gt;  $ c: num 3</span></code></pre>
<p>Unlike atomic vectors, <code>list()</code> can contain a mix of objects:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="st">&quot;a&quot;</span>, 1L, <span class="fl">1.5</span>, <span class="ot">TRUE</span>)
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 4</span>
<span class="co">#&gt;  $ : chr &quot;a&quot;</span>
<span class="co">#&gt;  $ : int 1</span>
<span class="co">#&gt;  $ : num 1.5</span>
<span class="co">#&gt;  $ : logi TRUE</span></code></pre>
<p>Lists can even contain other lists!</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">list</span>(<span class="dv">3</span>, <span class="dv">4</span>))
<span class="kw">str</span>(z)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ : num 1</span>
<span class="co">#&gt;   ..$ : num 2</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ : num 3</span>
<span class="co">#&gt;   ..$ : num 4</span></code></pre>
<div id="visualising-lists" class="section level3">
<h3><span class="header-section-number">20.5.1</span> Visualising lists</h3>
<p>To explain more complicated list manipulation functions, it’s helpful to have a visual representation of lists. For example, take these three lists:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>))
x2 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">list</span>(<span class="dv">3</span>, <span class="dv">4</span>))
x3 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="kw">list</span>(<span class="dv">2</span>, <span class="kw">list</span>(<span class="dv">3</span>)))</code></pre>
<p>I’ll draw them as follows:</p>
<p><img src="diagrams/lists-structure.png" width="75%" style="display: block; margin: auto;" /></p>
<p>There are three principles:</p>
<ol style="list-style-type: decimal">
<li><p>Lists have rounded corners. Atomic vectors have square corners.</p></li>
<li><p>Children are drawn inside their parent, and have a slightly darker
background to make it easier to see the hierarchy.</p></li>
<li><p>The orientation of the children (i.e. rows or columns) isn’t important,
so I’ll pick a row or column orientation to either save space or illustrate
an important property in the example.</p></li>
</ol>
</div>
<div id="subsetting-1" class="section level3">
<h3><span class="header-section-number">20.5.2</span> Subsetting</h3>
<p>There are three ways to subset a list, which I’ll illustrate with a list named <code>a</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">b =</span> <span class="st">&quot;a string&quot;</span>, <span class="dt">c =</span> pi, <span class="dt">d =</span> <span class="kw">list</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">-5</span>))</code></pre>
<ul>
<li><p><code>[</code> extracts a sub-list. The result will always be a list.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(a[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>])
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ a: int [1:3] 1 2 3</span>
<span class="co">#&gt;  $ b: chr &quot;a string&quot;</span>
<span class="kw">str</span>(a[<span class="dv">4</span>])
<span class="co">#&gt; List of 1</span>
<span class="co">#&gt;  $ d:List of 2</span>
<span class="co">#&gt;   ..$ : num -1</span>
<span class="co">#&gt;   ..$ : num -5</span></code></pre>
<p>Like with vectors, you can subset with a logical, integer, or character
vector.</p></li>
<li><p><code>[[</code> extracts a single component from a list. It removes a level of
hierarchy from the list.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(a[[<span class="dv">1</span>]])
<span class="co">#&gt;  int [1:3] 1 2 3</span>
<span class="kw">str</span>(a[[<span class="dv">4</span>]])
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ : num -1</span>
<span class="co">#&gt;  $ : num -5</span></code></pre></li>
<li><p><code>$</code> is a shorthand for extracting named elements of a list. It works
similarly to <code>[[</code> except that you don’t need to use quotes.</p>
<pre class="sourceCode r"><code class="sourceCode r">a<span class="op">$</span>a
<span class="co">#&gt; [1] 1 2 3</span>
a[[<span class="st">&quot;a&quot;</span>]]
<span class="co">#&gt; [1] 1 2 3</span></code></pre></li>
</ul>
<p>The distinction between <code>[</code> and <code>[[</code> is really important for lists, because <code>[[</code> drills down into the list while <code>[</code> returns a new, smaller list. Compare the code and output above with the visual representation in Figure <a href="#fig:lists-subsetting">20.2</a>.</p>
<div class="figure" style="text-align: center"><span id="fig:lists-subsetting"></span>
<img src="diagrams/lists-subsetting.png" alt="Subsetting a list, visually." width="75%" />
<p class="caption">
Figure 20.2: Subsetting a list, visually.
</p>
</div>
</div>
<div id="lists-of-condiments" class="section level3">
<h3><span class="header-section-number">20.5.3</span> Lists of condiments</h3>
<p>The difference between <code>[</code> and <code>[[</code> is very important, but it’s easy to get confused. To help you remember, let me show you an unusual pepper shaker.</p>
<p><img src="images/pepper.jpg" width="25%" style="display: block; margin: auto;" /></p>
<p>If this pepper shaker is your list <code>x</code>, then, <code>x[1]</code> is a pepper shaker containing a single pepper packet:</p>
<p><img src="images/pepper-1.jpg" width="25%" style="display: block; margin: auto;" /></p>
<p><code>x[2]</code> would look the same, but would contain the second packet. <code>x[1:2]</code> would be a pepper shaker containing two pepper packets.</p>
<p><code>x[[1]]</code> is:</p>
<p><img src="images/pepper-2.jpg" width="25%" style="display: block; margin: auto;" /></p>
<p>If you wanted to get the content of the pepper package, you’d need <code>x[[1]][[1]]</code>:</p>
<p><img src="images/pepper-3.jpg" width="25%" style="display: block; margin: auto;" /></p>
</div>
<div id="exercises-53" class="section level3">
<h3><span class="header-section-number">20.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Draw the following lists as nested sets:</p>
<ol style="list-style-type: decimal">
<li><code>list(a, b, list(c, d), list(e, f))</code></li>
<li><code>list(list(list(list(list(list(a))))))</code></li>
</ol></li>
<li><p>What happens if you subset a tibble as if you’re subsetting a list?
What are the key differences between a list and a tibble?</p></li>
</ol>
</div>
</div>
<div id="attributes" class="section level2">
<h2><span class="header-section-number">20.6</span> Attributes</h2>
<p>Any vector can contain arbitrary additional metadata through its <strong>attributes</strong>. You can think of attributes as named list of vectors that can be attached to any object.
You can get and set individual attribute values with <code>attr()</code> or see them all at once with <code>attributes()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">attr</span>(x, <span class="st">&quot;greeting&quot;</span>)
<span class="co">#&gt; NULL</span>
<span class="kw">attr</span>(x, <span class="st">&quot;greeting&quot;</span>) &lt;-<span class="st"> &quot;Hi!&quot;</span>
<span class="kw">attr</span>(x, <span class="st">&quot;farewell&quot;</span>) &lt;-<span class="st"> &quot;Bye!&quot;</span>
<span class="kw">attributes</span>(x)
<span class="co">#&gt; $greeting</span>
<span class="co">#&gt; [1] &quot;Hi!&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $farewell</span>
<span class="co">#&gt; [1] &quot;Bye!&quot;</span></code></pre>
<p>There are three very important attributes that are used to implement fundamental parts of R:</p>
<ol style="list-style-type: decimal">
<li><strong>Names</strong> are used to name the elements of a vector.</li>
<li><strong>Dimensions</strong> (dims, for short) make a vector behave like a matrix or array.</li>
<li><strong>Class</strong> is used to implement the S3 object oriented system.</li>
</ol>
<p>You’ve seen names above, and we won’t cover dimensions because we don’t use matrices in this book. It remains to describe the class, which controls how <strong>generic functions</strong> work. Generic functions are key to object oriented programming in R, because they make functions behave differently for different classes of input. A detailed discussion of object oriented programming is beyond the scope of this book, but you can read more about it in <em>Advanced R</em> at <a href="http://adv-r.had.co.nz/OO-essentials.html#s3" class="uri">http://adv-r.had.co.nz/OO-essentials.html#s3</a>.</p>
<p>Here’s what a typical generic function looks like:</p>
<pre class="sourceCode r"><code class="sourceCode r">as.Date
<span class="co">#&gt; function (x, ...) </span>
<span class="co">#&gt; UseMethod(&quot;as.Date&quot;)</span>
<span class="co">#&gt; &lt;bytecode: 0x5592b6e35750&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre>
<p>The call to “UseMethod” means that this is a generic function, and it will call a specific <strong>method</strong>, a function, based on the class of the first argument. (All methods are functions; not all functions are methods). You can list all the methods for a generic with <code>methods()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">methods</span>(<span class="st">&quot;as.Date&quot;</span>)
<span class="co">#&gt; [1] as.Date.character as.Date.date      as.Date.dates     as.Date.default  </span>
<span class="co">#&gt; [5] as.Date.factor    as.Date.numeric   as.Date.POSIXct   as.Date.POSIXlt  </span>
<span class="co">#&gt; see &#39;?methods&#39; for accessing help and source code</span></code></pre>
<p>For example, if <code>x</code> is a character vector, <code>as.Date()</code> will call <code>as.Date.character()</code>; if it’s a factor, it’ll call <code>as.Date.factor()</code>.</p>
<p>You can see the specific implementation of a method with <code>getS3method()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getS3method</span>(<span class="st">&quot;as.Date&quot;</span>, <span class="st">&quot;default&quot;</span>)
<span class="co">#&gt; function (x, ...) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     if (inherits(x, &quot;Date&quot;)) </span>
<span class="co">#&gt;         return(x)</span>
<span class="co">#&gt;     if (is.logical(x) &amp;&amp; all(is.na(x))) </span>
<span class="co">#&gt;         return(structure(as.numeric(x), class = &quot;Date&quot;))</span>
<span class="co">#&gt;     stop(gettextf(&quot;do not know how to convert &#39;%s&#39; to class %s&quot;, </span>
<span class="co">#&gt;         deparse(substitute(x)), dQuote(&quot;Date&quot;)), domain = NA)</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;bytecode: 0x5592b72e7f60&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span>
<span class="kw">getS3method</span>(<span class="st">&quot;as.Date&quot;</span>, <span class="st">&quot;numeric&quot;</span>)
<span class="co">#&gt; function (x, origin, ...) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     if (missing(origin)) </span>
<span class="co">#&gt;         stop(&quot;&#39;origin&#39; must be supplied&quot;)</span>
<span class="co">#&gt;     as.Date(origin, ...) + x</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;bytecode: 0x5592b72ea5e8&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre>
<p>The most important S3 generic is <code>print()</code>: it controls how the object is printed when you type its name at the console. Other important generics are the subsetting functions <code>[</code>, <code>[[</code>, and <code>$</code>.</p>
</div>
<div id="augmented-vectors" class="section level2">
<h2><span class="header-section-number">20.7</span> Augmented vectors</h2>
<p>Atomic vectors and lists are the building blocks for other important vector types like factors and dates. I call these <strong>augmented vectors</strong>, because they are vectors with additional <strong>attributes</strong>, including class. Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. In this book, we make use of four important augmented vectors:</p>
<ul>
<li>Factors</li>
<li>Dates</li>
<li>Date-times</li>
<li>Tibbles</li>
</ul>
<p>These are described below.</p>
<div id="factors-1" class="section level3">
<h3><span class="header-section-number">20.7.1</span> Factors</h3>
<p>Factors are designed to represent categorical data that can take a fixed set of possible values. Factors are built on top of integers, and have a levels attribute:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">&quot;ab&quot;</span>, <span class="st">&quot;cd&quot;</span>, <span class="st">&quot;ab&quot;</span>), <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;ab&quot;</span>, <span class="st">&quot;cd&quot;</span>, <span class="st">&quot;ef&quot;</span>))
<span class="kw">typeof</span>(x)
<span class="co">#&gt; [1] &quot;integer&quot;</span>
<span class="kw">attributes</span>(x)
<span class="co">#&gt; $levels</span>
<span class="co">#&gt; [1] &quot;ab&quot; &quot;cd&quot; &quot;ef&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;factor&quot;</span></code></pre>
</div>
<div id="dates-and-date-times" class="section level3">
<h3><span class="header-section-number">20.7.2</span> Dates and date-times</h3>
<p>Dates in R are numeric vectors that represent the number of days since 1 January 1970.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">as.Date</span>(<span class="st">&quot;1971-01-01&quot;</span>)
<span class="kw">unclass</span>(x)
<span class="co">#&gt; [1] 365</span>

<span class="kw">typeof</span>(x)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(x)
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;Date&quot;</span></code></pre>
<p>Date-times are numeric vectors with class <code>POSIXct</code> that represent the number of seconds since 1 January 1970. (In case you were wondering, “POSIXct” stands for “Portable Operating System Interface”, calendar time.)</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>lubridate<span class="op">::</span><span class="kw">ymd_hm</span>(<span class="st">&quot;1970-01-01 01:00&quot;</span>)
<span class="kw">unclass</span>(x)
<span class="co">#&gt; [1] 3600</span>
<span class="co">#&gt; attr(,&quot;tzone&quot;)</span>
<span class="co">#&gt; [1] &quot;UTC&quot;</span>

<span class="kw">typeof</span>(x)
<span class="co">#&gt; [1] &quot;double&quot;</span>
<span class="kw">attributes</span>(x)
<span class="co">#&gt; $tzone</span>
<span class="co">#&gt; [1] &quot;UTC&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</span></code></pre>
<p>The <code>tzone</code> attribute is optional. It controls how the time is printed, not what absolute time it refers to.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attr</span>(x, <span class="st">&quot;tzone&quot;</span>) &lt;-<span class="st"> &quot;US/Pacific&quot;</span>
x
<span class="co">#&gt; [1] &quot;1969-12-31 17:00:00 PST&quot;</span>

<span class="kw">attr</span>(x, <span class="st">&quot;tzone&quot;</span>) &lt;-<span class="st"> &quot;US/Eastern&quot;</span>
x
<span class="co">#&gt; [1] &quot;1969-12-31 20:00:00 EST&quot;</span></code></pre>
<p>There is another type of date-times called POSIXlt. These are built on top of named lists:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">as.POSIXlt</span>(x)
<span class="kw">typeof</span>(y)
<span class="co">#&gt; [1] &quot;list&quot;</span>
<span class="kw">attributes</span>(y)
<span class="co">#&gt; $names</span>
<span class="co">#&gt;  [1] &quot;sec&quot;    &quot;min&quot;    &quot;hour&quot;   &quot;mday&quot;   &quot;mon&quot;    &quot;year&quot;   &quot;wday&quot;  </span>
<span class="co">#&gt;  [8] &quot;yday&quot;   &quot;isdst&quot;  &quot;zone&quot;   &quot;gmtoff&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;POSIXlt&quot; &quot;POSIXt&quot; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $tzone</span>
<span class="co">#&gt; [1] &quot;US/Eastern&quot; &quot;EST&quot;        &quot;EDT&quot;</span></code></pre>
<p>POSIXlts are rare inside the tidyverse. They do crop up in base R, because they are needed to extract specific components of a date, like the year or month. Since lubridate provides helpers for you to do this instead, you don’t need them. POSIXct’s are always easier to work with, so if you find you have a POSIXlt, you should always convert it to a regular data time <code>lubridate::as_date_time()</code>.</p>
</div>
<div id="tibbles-1" class="section level3">
<h3><span class="header-section-number">20.7.3</span> Tibbles</h3>
<p>Tibbles are augmented lists: they have class “tbl_df” + “tbl” + “data.frame”, and <code>names</code> (column) and <code>row.names</code> attributes:</p>
<pre class="sourceCode r"><code class="sourceCode r">tb &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">y =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>)
<span class="kw">typeof</span>(tb)
<span class="co">#&gt; [1] &quot;list&quot;</span>
<span class="kw">attributes</span>(tb)
<span class="co">#&gt; $names</span>
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] 1 2 3 4 5</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;tbl_df&quot;     &quot;tbl&quot;        &quot;data.frame&quot;</span></code></pre>
<p>The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length. All functions that work with tibbles enforce this constraint.</p>
<p>Traditional data.frames have a very similar structure:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">y =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>)
<span class="kw">typeof</span>(df)
<span class="co">#&gt; [1] &quot;list&quot;</span>
<span class="kw">attributes</span>(df)
<span class="co">#&gt; $names</span>
<span class="co">#&gt; [1] &quot;x&quot; &quot;y&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $row.names</span>
<span class="co">#&gt; [1] 1 2 3 4 5</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $class</span>
<span class="co">#&gt; [1] &quot;data.frame&quot;</span></code></pre>
<p>The main difference is the class. The class of tibble includes “data.frame” which means tibbles inherit the regular data frame behaviour by default.</p>
</div>
<div id="exercises-54" class="section level3">
<h3><span class="header-section-number">20.7.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What does <code>hms::hms(3600)</code> return? How does it print? What primitive
type is the augmented vector built on top of? What attributes does it
use?</p></li>
<li><p>Try and make a tibble that has columns with different lengths. What
happens?</p></li>
<li><p>Based on the definition above, is it ok to have a list as a
column of a tibble?</p></li>
</ol>
<!--chapter:end:vectors.Rmd-->
</div>
</div>
</div>
<div id="iteration" class="section level1">
<h1><span class="header-section-number">21</span> Iteration</h1>
<div id="introduction-14" class="section level2">
<h2><span class="header-section-number">21.1</span> Introduction</h2>
<p>In <a href="#functions">functions</a>, we talked about how important it is to reduce duplication in your code by creating functions instead of copying-and-pasting. Reducing code duplication has three main benefits:</p>
<ol style="list-style-type: decimal">
<li><p>It’s easier to see the intent of your code, because your eyes are
drawn to what’s different, not what stays the same.</p></li>
<li><p>It’s easier to respond to changes in requirements. As your needs
change, you only need to make changes in one place, rather than
remembering to change every place that you copied-and-pasted the
code.</p></li>
<li><p>You’re likely to have fewer bugs because each line of code is
used in more places.</p></li>
</ol>
<p>One tool for reducing duplication is functions, which reduce duplication by identifying repeated patterns of code and extract them out into independent pieces that can be easily reused and updated. Another tool for reducing duplication is <strong>iteration</strong>, which helps you when you need to do the same thing to multiple inputs: repeating the same operation on different columns, or on different datasets.
In this chapter you’ll learn about two important iteration paradigms: imperative programming and functional programming. On the imperative side you have tools like for loops and while loops, which are a great place to start because they make iteration very explicit, so it’s obvious what’s happening. However, for loops are quite verbose, and require quite a bit of bookkeeping code that is duplicated for every for loop. Functional programming (FP) offers tools to extract out this duplicated code, so each common for loop pattern gets its own function. Once you master the vocabulary of FP, you can solve many common iteration problems with less code, more ease, and fewer errors.</p>
<div id="prerequisites-14" class="section level3">
<h3><span class="header-section-number">21.1.1</span> Prerequisites</h3>
<p>Once you’ve mastered the for loops provided by base R, you’ll learn some of the powerful programming tools provided by purrr, one of the tidyverse core packages.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="for-loops" class="section level2">
<h2><span class="header-section-number">21.2</span> For loops</h2>
<p>Imagine we have this simple tibble:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">a =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">b =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">c =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">d =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>)
)</code></pre>
<p>We want to compute the median of each column. You <em>could</em> do with copy-and-paste:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">median</span>(df<span class="op">$</span>a)
<span class="co">#&gt; [1] -0.246</span>
<span class="kw">median</span>(df<span class="op">$</span>b)
<span class="co">#&gt; [1] -0.287</span>
<span class="kw">median</span>(df<span class="op">$</span>c)
<span class="co">#&gt; [1] -0.0567</span>
<span class="kw">median</span>(df<span class="op">$</span>d)
<span class="co">#&gt; [1] 0.144</span></code></pre>
<p>But that breaks our rule of thumb: never copy and paste more than twice. Instead, we could use a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">ncol</span>(df))  <span class="co"># 1. output</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {            <span class="co"># 2. sequence</span>
  output[[i]] &lt;-<span class="st"> </span><span class="kw">median</span>(df[[i]])      <span class="co"># 3. body</span>
}
output
<span class="co">#&gt; [1] -0.2458 -0.2873 -0.0567  0.1443</span></code></pre>
<p>Every for loop has three components:</p>
<ol style="list-style-type: decimal">
<li><p>The <strong>output</strong>: <code>output &lt;- vector(&quot;double&quot;, length(x))</code>.
Before you start the loop, you must always allocate sufficient space
for the output. This is very important for efficiency: if you grow
the for loop at each iteration using <code>c()</code> (for example), your for loop
will be very slow.</p>
<p>A general way of creating an empty vector of given length is the <code>vector()</code>
function. It has two arguments: the type of the vector (“logical”,
“integer”, “double”, “character”, etc) and the length of the vector.</p></li>
<li><p>The <strong>sequence</strong>: <code>i in seq_along(df)</code>. This determines what to loop over:
each run of the for loop will assign <code>i</code> to a different value from
<code>seq_along(df)</code>. It’s useful to think of <code>i</code> as a pronoun, like “it”.</p>
<p>You might not have seen <code>seq_along()</code> before. It’s a safe version of the
familiar <code>1:length(l)</code>, with an important difference: if you have a
zero-length vector, <code>seq_along()</code> does the right thing:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="dv">0</span>)
<span class="kw">seq_along</span>(y)
<span class="co">#&gt; integer(0)</span>
<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(y)
<span class="co">#&gt; [1] 1 0</span></code></pre>
<p>You probably won’t create a zero-length vector deliberately, but
it’s easy to create them accidentally. If you use <code>1:length(x)</code> instead
of <code>seq_along(x)</code>, you’re likely to get a confusing error message.</p></li>
<li><p>The <strong>body</strong>: <code>output[[i]] &lt;- median(df[[i]])</code>. This is the code that does
the work. It’s run repeatedly, each time with a different value for <code>i</code>.
The first iteration will run <code>output[[1]] &lt;- median(df[[1]])</code>,
the second will run <code>output[[2]] &lt;- median(df[[2]])</code>, and so on.</p></li>
</ol>
<p>That’s all there is to the for loop! Now is a good time to practice creating some basic (and not so basic) for loops using the exercises below. Then we’ll move on some variations of the for loop that help you solve other problems that will crop up in practice.</p>
<div id="exercises-55" class="section level3">
<h3><span class="header-section-number">21.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Write for loops to:</p>
<ol style="list-style-type: decimal">
<li>Compute the mean of every column in <code>mtcars</code>.</li>
<li>Determine the type of each column in <code>nycflights13::flights</code>.</li>
<li>Compute the number of unique values in each column of <code>iris</code>.</li>
<li>Generate 10 random normals for each of <span class="math inline">\(\mu = -10\)</span>, <span class="math inline">\(0\)</span>, <span class="math inline">\(10\)</span>, and <span class="math inline">\(100\)</span>.</li>
</ol>
<p>Think about the output, sequence, and body <strong>before</strong> you start writing
the loop.</p></li>
<li><p>Eliminate the for loop in each of the following examples by taking
advantage of an existing function that works with vectors:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> &quot;&quot;</span>
<span class="cf">for</span> (x <span class="cf">in</span> letters) {
  out &lt;-<span class="st"> </span>stringr<span class="op">::</span><span class="kw">str_c</span>(out, x)
}

x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">100</span>)
sd &lt;-<span class="st"> </span><span class="dv">0</span>
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
  sd &lt;-<span class="st"> </span>sd <span class="op">+</span><span class="st"> </span>(x[i] <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
}
sd &lt;-<span class="st"> </span><span class="kw">sqrt</span>(sd <span class="op">/</span><span class="st"> </span>(<span class="kw">length</span>(x) <span class="op">-</span><span class="st"> </span><span class="dv">1</span>))

x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;numeric&quot;</span>, <span class="kw">length</span>(x))
out[<span class="dv">1</span>] &lt;-<span class="st"> </span>x[<span class="dv">1</span>]
<span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(x)) {
  out[i] &lt;-<span class="st"> </span>out[i <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>x[i]
}</code></pre></li>
<li><p>Combine your function writing and for loop skills:</p>
<ol style="list-style-type: decimal">
<li><p>Write a for loop that <code>prints()</code> the lyrics to the children’s song
“Alice the camel”.</p></li>
<li><p>Convert the nursery rhyme “ten in the bed” to a function. Generalise
it to any number of people in any sleeping structure.</p></li>
<li><p>Convert the song “99 bottles of beer on the wall” to a function.
Generalise to any number of any vessel containing any liquid on
any surface.</p></li>
</ol></li>
<li><p>It’s common to see for loops that don’t preallocate the output and instead
increase the length of a vector at each step:</p>
<pre class="sourceCode r"><code class="sourceCode r">output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;integer&quot;</span>, <span class="dv">0</span>)
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
  output &lt;-<span class="st"> </span><span class="kw">c</span>(output, <span class="kw">lengths</span>(x[[i]]))
}
output</code></pre>
<p>How does this affect performance? Design and execute an experiment.</p></li>
</ol>
</div>
</div>
<div id="for-loop-variations" class="section level2">
<h2><span class="header-section-number">21.3</span> For loop variations</h2>
<p>Once you have the basic for loop under your belt, there are some variations that you should be aware of. These variations are important regardless of how you do iteration, so don’t forget about them once you’ve mastered the FP techniques you’ll learn about in the next section.</p>
<p>There are four variations on the basic theme of the for loop:</p>
<ol style="list-style-type: decimal">
<li>Modifying an existing object, instead of creating a new object.</li>
<li>Looping over names or values, instead of indices.</li>
<li>Handling outputs of unknown length.</li>
<li>Handling sequences of unknown length.</li>
</ol>
<div id="modifying-an-existing-object" class="section level3">
<h3><span class="header-section-number">21.3.1</span> Modifying an existing object</h3>
<p>Sometimes you want to use a for loop to modify an existing object. For example, remember our challenge from <a href="#functions">functions</a>. We wanted to rescale every column in a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">a =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">b =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">c =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">d =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>)
)
rescale01 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {
  rng &lt;-<span class="st"> </span><span class="kw">range</span>(x, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  (x <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>]) <span class="op">/</span><span class="st"> </span>(rng[<span class="dv">2</span>] <span class="op">-</span><span class="st"> </span>rng[<span class="dv">1</span>])
}

df<span class="op">$</span>a &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>a)
df<span class="op">$</span>b &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>b)
df<span class="op">$</span>c &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>c)
df<span class="op">$</span>d &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df<span class="op">$</span>d)</code></pre>
<p>To solve this with a for loop we again think about the three components:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Output</strong>: we already have the output — it’s the same as the input!</p></li>
<li><p><strong>Sequence</strong>: we can think about a data frame as a list of columns, so
we can iterate over each column with <code>seq_along(df)</code>.</p></li>
<li><p><strong>Body</strong>: apply <code>rescale01()</code>.</p></li>
</ol>
<p>This gives us:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
  df[[i]] &lt;-<span class="st"> </span><span class="kw">rescale01</span>(df[[i]])
}</code></pre>
<p>Typically you’ll be modifying a list or data frame with this sort of loop, so remember to use <code>[[</code>, not <code>[</code>. You might have spotted that I used <code>[[</code> in all my for loops: I think it’s better to use <code>[[</code> even for atomic vectors because it makes it clear that I want to work with a single element.</p>
</div>
<div id="looping-patterns" class="section level3">
<h3><span class="header-section-number">21.3.2</span> Looping patterns</h3>
<p>There are three basic ways to loop over a vector. So far I’ve shown you the most general: looping over the numeric indices with <code>for (i in seq_along(xs))</code>, and extracting the value with <code>x[[i]]</code>. There are two other forms:</p>
<ol style="list-style-type: decimal">
<li><p>Loop over the elements: <code>for (x in xs)</code>. This is most useful if you only
care about side-effects, like plotting or saving a file, because it’s
difficult to save the output efficiently.</p></li>
<li><p>Loop over the names: <code>for (nm in names(xs))</code>. This gives you name, which
you can use to access the value with <code>x[[nm]]</code>. This is useful if you want
to use the name in a plot title or a file name. If you’re creating
named output, make sure to name the results vector like so:</p>
<pre class="sourceCode r"><code class="sourceCode r">results &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
<span class="kw">names</span>(results) &lt;-<span class="st"> </span><span class="kw">names</span>(x)</code></pre></li>
</ol>
<p>Iteration over the numeric indices is the most general form, because given the position you can extract both the name and the value:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
  name &lt;-<span class="st"> </span><span class="kw">names</span>(x)[[i]]
  value &lt;-<span class="st"> </span>x[[i]]
}</code></pre>
</div>
<div id="unknown-output-length" class="section level3">
<h3><span class="header-section-number">21.3.3</span> Unknown output length</h3>
<p>Sometimes you might not know how long the output will be. For example, imagine you want to simulate some random vectors of random lengths. You might be tempted to solve this problem by progressively growing the vector:</p>
<pre class="sourceCode r"><code class="sourceCode r">means &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>)

output &lt;-<span class="st"> </span><span class="kw">double</span>()
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(means)) {
  n &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">100</span>, <span class="dv">1</span>)
  output &lt;-<span class="st"> </span><span class="kw">c</span>(output, <span class="kw">rnorm</span>(n, means[[i]]))
}
<span class="kw">str</span>(output)
<span class="co">#&gt;  num [1:202] 0.912 0.205 2.584 -0.789 0.588 ...</span></code></pre>
<p>But this is not very efficient because in each iteration, R has to copy all the data from the previous iterations. In technical terms you get “quadratic” (<span class="math inline">\(O(n^2)\)</span>) behaviour which means that a loop with three times as many elements would take nine (<span class="math inline">\(3^2\)</span>) times as long to run.</p>
<p>A better solution to save the results in a list, and then combine into a single vector after the loop is done:</p>
<pre class="sourceCode r"><code class="sourceCode r">out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(means))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(means)) {
  n &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">100</span>, <span class="dv">1</span>)
  out[[i]] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(n, means[[i]])
}
<span class="kw">str</span>(out)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:83] 0.367 1.13 -0.941 0.218 1.415 ...</span>
<span class="co">#&gt;  $ : num [1:21] -0.485 -0.425 2.937 1.688 1.324 ...</span>
<span class="co">#&gt;  $ : num [1:40] 2.34 1.59 2.93 3.84 1.3 ...</span>
<span class="kw">str</span>(<span class="kw">unlist</span>(out))
<span class="co">#&gt;  num [1:144] 0.367 1.13 -0.941 0.218 1.415 ...</span></code></pre>
<p>Here I’ve used <code>unlist()</code> to flatten a list of vectors into a single vector. A stricter option is to use <code>purrr::flatten_dbl()</code> — it will throw an error if the input isn’t a list of doubles.</p>
<p>This pattern occurs in other places too:</p>
<ol style="list-style-type: decimal">
<li><p>You might be generating a long string. Instead of <code>paste()</code>ing together
each iteration with the previous, save the output in a character vector and
then combine that vector into a single string with
<code>paste(output, collapse = &quot;&quot;)</code>.</p></li>
<li><p>You might be generating a big data frame. Instead of sequentially
<code>rbind()</code>ing in each iteration, save the output in a list, then use
<code>dplyr::bind_rows(output)</code> to combine the output into a single
data frame.</p></li>
</ol>
<p>Watch out for this pattern. Whenever you see it, switch to a more complex result object, and then combine in one step at the end.</p>
</div>
<div id="unknown-sequence-length" class="section level3">
<h3><span class="header-section-number">21.3.4</span> Unknown sequence length</h3>
<p>Sometimes you don’t even know how long the input sequence should run for. This is common when doing simulations. For example, you might want to loop until you get three heads in a row. You can’t do that sort of iteration with the for loop. Instead, you can use a while loop. A while loop is simpler than for loop because it only has two components, a condition and a body:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">while</span> (condition) {
  <span class="co"># body</span>
}</code></pre>
<p>A while loop is also more general than a for loop, because you can rewrite any for loop as a while loop, but you can’t rewrite every while loop as a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
  <span class="co"># body</span>
}

<span class="co"># Equivalent to</span>
i &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="cf">while</span> (i <span class="op">&lt;=</span><span class="st"> </span><span class="kw">length</span>(x)) {
  <span class="co"># body</span>
  i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span> 
}</code></pre>
<p>Here’s how we could use a while loop to find how many tries it takes to get three heads in a row:</p>
<pre class="sourceCode r"><code class="sourceCode r">flip &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="kw">sample</span>(<span class="kw">c</span>(<span class="st">&quot;T&quot;</span>, <span class="st">&quot;H&quot;</span>), <span class="dv">1</span>)

flips &lt;-<span class="st"> </span><span class="dv">0</span>
nheads &lt;-<span class="st"> </span><span class="dv">0</span>

<span class="cf">while</span> (nheads <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span>) {
  <span class="cf">if</span> (<span class="kw">flip</span>() <span class="op">==</span><span class="st"> &quot;H&quot;</span>) {
    nheads &lt;-<span class="st"> </span>nheads <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  } <span class="cf">else</span> {
    nheads &lt;-<span class="st"> </span><span class="dv">0</span>
  }
  flips &lt;-<span class="st"> </span>flips <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
}
flips
<span class="co">#&gt; [1] 3</span></code></pre>
<p>I mention while loops only briefly, because I hardly ever use them. They’re most often used for simulation, which is outside the scope of this book. However, it is good to know they exist so that you’re prepared for problems where the number of iterations is not known in advance.</p>
</div>
<div id="exercises-56" class="section level3">
<h3><span class="header-section-number">21.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Imagine you have a directory full of CSV files that you want to read in.
You have their paths in a vector,
<code>files &lt;- dir(&quot;data/&quot;, pattern = &quot;\\.csv$&quot;, full.names = TRUE)</code>, and now
want to read each one with <code>read_csv()</code>. Write the for loop that will
load them into a single data frame.</p></li>
<li><p>What happens if you use <code>for (nm in names(x))</code> and <code>x</code> has no names?
What if only some of the elements are named? What if the names are
not unique?</p></li>
<li><p>Write a function that prints the mean of each numeric column in a data
frame, along with its name. For example, <code>show_mean(iris)</code> would print:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">show_mean</span>(iris)
<span class="co">#&gt; Sepal.Length: 5.84</span>
<span class="co">#&gt; Sepal.Width:  3.06</span>
<span class="co">#&gt; Petal.Length: 3.76</span>
<span class="co">#&gt; Petal.Width:  1.20</span></code></pre>
<p>(Extra challenge: what function did I use to make sure that the numbers
lined up nicely, even though the variable names had different lengths?)</p></li>
<li><p>What does this code do? How does it work?</p>
<pre class="sourceCode r"><code class="sourceCode r">trans &lt;-<span class="st"> </span><span class="kw">list</span>( 
  <span class="dt">disp =</span> <span class="cf">function</span>(x) x <span class="op">*</span><span class="st"> </span><span class="fl">0.0163871</span>,
  <span class="dt">am =</span> <span class="cf">function</span>(x) {
    <span class="kw">factor</span>(x, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;auto&quot;</span>, <span class="st">&quot;manual&quot;</span>))
  }
)
<span class="cf">for</span> (var <span class="cf">in</span> <span class="kw">names</span>(trans)) {
  mtcars[[var]] &lt;-<span class="st"> </span>trans[[var]](mtcars[[var]])
}</code></pre></li>
</ol>
</div>
</div>
<div id="for-loops-vs.functionals" class="section level2">
<h2><span class="header-section-number">21.4</span> For loops vs. functionals</h2>
<p>For loops are not as important in R as they are in other languages because R is a functional programming language. This means that it’s possible to wrap up for loops in a function, and call that function instead of using the for loop directly.</p>
<p>To see why this is important, consider (again) this simple data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">a =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">b =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">c =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>),
  <span class="dt">d =</span> <span class="kw">rnorm</span>(<span class="dv">10</span>)
)</code></pre>
<p>Imagine you want to compute the mean of every column. You could do that with a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">length</span>(df))
<span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
  output[[i]] &lt;-<span class="st"> </span><span class="kw">mean</span>(df[[i]])
}
output
<span class="co">#&gt; [1]  0.2026 -0.2068  0.1275 -0.0917</span></code></pre>
<p>You realise that you’re going to want to compute the means of every column pretty frequently, so you extract it out into a function:</p>
<pre class="sourceCode r"><code class="sourceCode r">col_mean &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">length</span>(df))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
    output[i] &lt;-<span class="st"> </span><span class="kw">mean</span>(df[[i]])
  }
  output
}</code></pre>
<p>But then you think it’d also be helpful to be able to compute the median, and the standard deviation, so you copy and paste your <code>col_mean()</code> function and replace the <code>mean()</code> with <code>median()</code> and <code>sd()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">col_median &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">length</span>(df))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
    output[i] &lt;-<span class="st"> </span><span class="kw">median</span>(df[[i]])
  }
  output
}
col_sd &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  output &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">length</span>(df))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
    output[i] &lt;-<span class="st"> </span><span class="kw">sd</span>(df[[i]])
  }
  output
}</code></pre>
<p>Uh oh! You’ve copied-and-pasted this code twice, so it’s time to think about how to generalise it. Notice that most of this code is for-loop boilerplate and it’s hard to see the one thing (<code>mean()</code>, <code>median()</code>, <code>sd()</code>) that is different between the functions.</p>
<p>What would you do if you saw a set of functions like this:</p>
<pre class="sourceCode r"><code class="sourceCode r">f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">^</span><span class="st"> </span><span class="dv">1</span>
f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">^</span><span class="st"> </span><span class="dv">2</span>
f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">^</span><span class="st"> </span><span class="dv">3</span></code></pre>
<p>Hopefully, you’d notice that there’s a lot of duplication, and extract it out into an additional argument:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(x, i) <span class="kw">abs</span>(x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x)) <span class="op">^</span><span class="st"> </span>i</code></pre>
<p>You’ve reduced the chance of bugs (because you now have 1/3 of the original code), and made it easy to generalise to new situations.</p>
<p>We can do exactly the same thing with <code>col_mean()</code>, <code>col_median()</code> and <code>col_sd()</code> by adding an argument that supplies the function to apply to each column:</p>
<pre class="sourceCode r"><code class="sourceCode r">col_summary &lt;-<span class="st"> </span><span class="cf">function</span>(df, fun) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;double&quot;</span>, <span class="kw">length</span>(df))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(df)) {
    out[i] &lt;-<span class="st"> </span><span class="kw">fun</span>(df[[i]])
  }
  out
}
<span class="kw">col_summary</span>(df, median)
<span class="co">#&gt; [1]  0.237 -0.218  0.254 -0.133</span>
<span class="kw">col_summary</span>(df, mean)
<span class="co">#&gt; [1]  0.2026 -0.2068  0.1275 -0.0917</span></code></pre>
<p>The idea of passing a function to another function is extremely powerful idea, and it’s one of the behaviours that makes R a functional programming language. It might take you a while to wrap your head around the idea, but it’s worth the investment. In the rest of the chapter, you’ll learn about and use the <strong>purrr</strong> package, which provides functions that eliminate the need for many common for loops. The apply family of functions in base R (<code>apply()</code>, <code>lapply()</code>, <code>tapply()</code>, etc) solve a similar problem, but purrr is more consistent and thus is easier to learn.</p>
<p>The goal of using purrr functions instead of for loops is to allow you break common list manipulation challenges into independent pieces:</p>
<ol style="list-style-type: decimal">
<li><p>How can you solve the problem for a single element of the list? Once
you’ve solved that problem, purrr takes care of generalising your
solution to every element in the list.</p></li>
<li><p>If you’re solving a complex problem, how can you break it down into
bite-sized pieces that allow you to advance one small step towards a
solution? With purrr, you get lots of small pieces that you can
compose together with the pipe.</p></li>
</ol>
<p>This structure makes it easier to solve new problems. It also makes it easier to understand your solutions to old problems when you re-read your old code.</p>
<div id="exercises-57" class="section level3">
<h3><span class="header-section-number">21.4.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Read the documentation for <code>apply()</code>. In the 2d case, what two for loops
does it generalise?</p></li>
<li><p>Adapt <code>col_summary()</code> so that it only applies to numeric columns
You might want to start with an <code>is_numeric()</code> function that returns
a logical vector that has a TRUE corresponding to each numeric column.</p></li>
</ol>
</div>
</div>
<div id="the-map-functions" class="section level2">
<h2><span class="header-section-number">21.5</span> The map functions</h2>
<p>The pattern of looping over a vector, doing something to each element and saving the results is so common that the purrr package provides a family of functions to do it for you. There is one function for each type of output:</p>
<ul>
<li><code>map()</code> makes a list.</li>
<li><code>map_lgl()</code> makes a logical vector.</li>
<li><code>map_int()</code> makes an integer vector.</li>
<li><code>map_dbl()</code> makes a double vector.</li>
<li><code>map_chr()</code> makes a character vector.</li>
</ul>
<p>Each function takes a vector as input, applies a function to each piece, and then returns a new vector that’s the same length (and has the same names) as the input. The type of the vector is determined by the suffix to the map function.</p>
<p>Once you master these functions, you’ll find it takes much less time to solve iteration problems. But you should never feel bad about using a for loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. The important thing is that you solve the problem that you’re working on, not write the most concise and elegant code (although that’s definitely something you want to strive towards!).</p>
<p>Some people will tell you to avoid for loops because they are slow. They’re wrong! (Well at least they’re rather out of date, as for loops haven’t been slow for many years). The chief benefits of using functions like <code>map()</code> is not speed, but clarity: they make your code easier to write and to read.</p>
<p>We can use these functions to perform the same computations as the last for loop. Those summary functions returned doubles, so we need to use <code>map_dbl()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(df, mean)
<span class="co">#&gt;       a       b       c       d </span>
<span class="co">#&gt;  0.2026 -0.2068  0.1275 -0.0917</span>
<span class="kw">map_dbl</span>(df, median)
<span class="co">#&gt;      a      b      c      d </span>
<span class="co">#&gt;  0.237 -0.218  0.254 -0.133</span>
<span class="kw">map_dbl</span>(df, sd)
<span class="co">#&gt;     a     b     c     d </span>
<span class="co">#&gt; 0.796 0.759 1.164 1.062</span></code></pre>
<p>Compared to using a for loop, focus is on the operation being performed (i.e. <code>mean()</code>, <code>median()</code>, <code>sd()</code>), not the bookkeeping required to loop over every element and store the output. This is even more apparent if we use the pipe:</p>
<pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(mean)
<span class="co">#&gt;       a       b       c       d </span>
<span class="co">#&gt;  0.2026 -0.2068  0.1275 -0.0917</span>
df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(median)
<span class="co">#&gt;      a      b      c      d </span>
<span class="co">#&gt;  0.237 -0.218  0.254 -0.133</span>
df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(sd)
<span class="co">#&gt;     a     b     c     d </span>
<span class="co">#&gt; 0.796 0.759 1.164 1.062</span></code></pre>
<p>There are a few differences between <code>map_*()</code> and <code>col_summary()</code>:</p>
<ul>
<li><p>All purrr functions are implemented in C. This makes them a little faster
at the expense of readability.</p></li>
<li><p>The second argument, <code>.f</code>, the function to apply, can be a formula, a
character vector, or an integer vector. You’ll learn about those handy
shortcuts in the next section.</p></li>
<li><p><code>map_*()</code> uses … ([dot dot dot]) to pass along additional arguments
to <code>.f</code> each time it’s called:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(df, mean, <span class="dt">trim =</span> <span class="fl">0.5</span>)
<span class="co">#&gt;      a      b      c      d </span>
<span class="co">#&gt;  0.237 -0.218  0.254 -0.133</span></code></pre></li>
<li><p>The map functions also preserve names:</p>
<pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">y =</span> <span class="dv">4</span><span class="op">:</span><span class="dv">5</span>)
<span class="kw">map_int</span>(z, length)
<span class="co">#&gt; x y </span>
<span class="co">#&gt; 3 2</span></code></pre></li>
</ul>
<div id="shortcuts" class="section level3">
<h3><span class="header-section-number">21.5.1</span> Shortcuts</h3>
<p>There are a few shortcuts that you can use with <code>.f</code> in order to save a little typing. Imagine you want to fit a linear model to each group in a dataset. The following toy example splits the up the <code>mtcars</code> dataset in to three pieces (one for each value of cylinder) and fits the same linear model to each piece:</p>
<pre class="sourceCode r"><code class="sourceCode r">models &lt;-<span class="st"> </span>mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">split</span>(.<span class="op">$</span>cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="cf">function</span>(df) <span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> df))</code></pre>
<p>The syntax for creating an anonymous function in R is quite verbose so purrr provides a convenient shortcut: a one-sided formula.</p>
<pre class="sourceCode r"><code class="sourceCode r">models &lt;-<span class="st"> </span>mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">split</span>(.<span class="op">$</span>cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="kw">lm</span>(mpg <span class="op">~</span><span class="st"> </span>wt, <span class="dt">data =</span> .))</code></pre>
<p>Here I’ve used <code>.</code> as a pronoun: it refers to the current list element (in the same way that <code>i</code> referred to the current index in the for loop).</p>
<p>When you’re looking at many models, you might want to extract a summary statistic like the <span class="math inline">\(R^2\)</span>. To do that we need to first run <code>summary()</code> and then extract the component called <code>r.squared</code>. We could do that using the shorthand for anonymous functions:</p>
<pre class="sourceCode r"><code class="sourceCode r">models <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(summary) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map_dbl</span>(<span class="op">~</span>.<span class="op">$</span>r.squared)
<span class="co">#&gt;     4     6     8 </span>
<span class="co">#&gt; 0.509 0.465 0.423</span></code></pre>
<p>But extracting named components is a common operation, so purrr provides an even shorter shortcut: you can use a string.</p>
<pre class="sourceCode r"><code class="sourceCode r">models <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(summary) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map_dbl</span>(<span class="st">&quot;r.squared&quot;</span>)
<span class="co">#&gt;     4     6     8 </span>
<span class="co">#&gt; 0.509 0.465 0.423</span></code></pre>
<p>You can also use an integer to select elements by position:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>), <span class="kw">list</span>(<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>), <span class="kw">list</span>(<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>))
x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(<span class="dv">2</span>)
<span class="co">#&gt; [1] 2 5 8</span></code></pre>
</div>
<div id="base-r" class="section level3">
<h3><span class="header-section-number">21.5.2</span> Base R</h3>
<p>If you’re familiar with the apply family of functions in base R, you might have noticed some similarities with the purrr functions:</p>
<ul>
<li><p><code>lapply()</code> is basically identical to <code>map()</code>, except that <code>map()</code> is
consistent with all the other functions in purrr, and you can use the
shortcuts for <code>.f</code>.</p></li>
<li><p>Base <code>sapply()</code> is a wrapper around <code>lapply()</code> that automatically
simplifies the output. This is useful for interactive work but is
problematic in a function because you never know what sort of output
you’ll get:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">c</span>(<span class="fl">0.27</span>, <span class="fl">0.37</span>, <span class="fl">0.57</span>, <span class="fl">0.91</span>, <span class="fl">0.20</span>),
  <span class="kw">c</span>(<span class="fl">0.90</span>, <span class="fl">0.94</span>, <span class="fl">0.66</span>, <span class="fl">0.63</span>, <span class="fl">0.06</span>), 
  <span class="kw">c</span>(<span class="fl">0.21</span>, <span class="fl">0.18</span>, <span class="fl">0.69</span>, <span class="fl">0.38</span>, <span class="fl">0.77</span>)
)
x2 &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">c</span>(<span class="fl">0.50</span>, <span class="fl">0.72</span>, <span class="fl">0.99</span>, <span class="fl">0.38</span>, <span class="fl">0.78</span>), 
  <span class="kw">c</span>(<span class="fl">0.93</span>, <span class="fl">0.21</span>, <span class="fl">0.65</span>, <span class="fl">0.13</span>, <span class="fl">0.27</span>), 
  <span class="kw">c</span>(<span class="fl">0.39</span>, <span class="fl">0.01</span>, <span class="fl">0.38</span>, <span class="fl">0.87</span>, <span class="fl">0.34</span>)
)

threshold &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">cutoff =</span> <span class="fl">0.8</span>) x[x <span class="op">&gt;</span><span class="st"> </span>cutoff]
x1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sapply</span>(threshold) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num 0.91</span>
<span class="co">#&gt;  $ : num [1:2] 0.9 0.94</span>
<span class="co">#&gt;  $ : num(0)</span>
x2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">sapply</span>(threshold) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str</span>()
<span class="co">#&gt;  num [1:3] 0.99 0.93 0.87</span></code></pre></li>
<li><p><code>vapply()</code> is a safe alternative to <code>sapply()</code> because you supply an
additional argument that defines the type. The only problem with
<code>vapply()</code> is that it’s a lot of typing:
<code>vapply(df, is.numeric, logical(1))</code> is equivalent to
<code>map_lgl(df, is.numeric)</code>. One advantage of <code>vapply()</code> over purrr’s map
functions is that it can also produce matrices — the map functions only
ever produce vectors.</p></li>
</ul>
<p>I focus on purrr functions here because they have more consistent names and arguments, helpful shortcuts, and in the future will provide easy parallelism and progress bars.</p>
</div>
<div id="exercises-58" class="section level3">
<h3><span class="header-section-number">21.5.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Write code that uses one of the map functions to:</p>
<ol style="list-style-type: decimal">
<li>Compute the mean of every column in <code>mtcars</code>.</li>
<li>Determine the type of each column in <code>nycflights13::flights</code>.</li>
<li>Compute the number of unique values in each column of <code>iris</code>.</li>
<li>Generate 10 random normals for each of <span class="math inline">\(\mu = -10\)</span>, <span class="math inline">\(0\)</span>, <span class="math inline">\(10\)</span>, and <span class="math inline">\(100\)</span>.</li>
</ol></li>
<li><p>How can you create a single vector that for each column in a data frame
indicates whether or not it’s a factor?</p></li>
<li><p>What happens when you use the map functions on vectors that aren’t lists?
What does <code>map(1:5, runif)</code> do? Why?</p></li>
<li><p>What does <code>map(-2:2, rnorm, n = 5)</code> do? Why?
What does <code>map_dbl(-2:2, rnorm, n = 5)</code> do? Why?</p></li>
<li><p>Rewrite <code>map(x, function(df) lm(mpg ~ wt, data = df))</code> to eliminate the
anonymous function.</p></li>
</ol>
</div>
</div>
<div id="dealing-with-failure" class="section level2">
<h2><span class="header-section-number">21.6</span> Dealing with failure</h2>
<p>When you use the map functions to repeat many operations, the chances are much higher that one of those operations will fail. When this happens, you’ll get an error message, and no output. This is annoying: why does one failure prevent you from accessing all the other successes? How do you ensure that one bad apple doesn’t ruin the whole barrel?</p>
<p>In this section you’ll learn how to deal this situation with a new function: <code>safely()</code>. <code>safely()</code> is an adverb: it takes a function (a verb) and returns a modified version. In this case, the modified function will never throw an error. Instead, it always returns a list with two elements:</p>
<ol style="list-style-type: decimal">
<li><p><code>result</code> is the original result. If there was an error, this will be <code>NULL</code>.</p></li>
<li><p><code>error</code> is an error object. If the operation was successful, this will be
<code>NULL</code>.</p></li>
</ol>
<p>(You might be familiar with the <code>try()</code> function in base R. It’s similar, but because it sometimes returns the original result and it sometimes returns an error object it’s more difficult to work with.)</p>
<p>Let’s illustrate this with a simple example: <code>log()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">safe_log &lt;-<span class="st"> </span><span class="kw">safely</span>(log)
<span class="kw">str</span>(<span class="kw">safe_log</span>(<span class="dv">10</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: num 2.3</span>
<span class="co">#&gt;  $ error : NULL</span>
<span class="kw">str</span>(<span class="kw">safe_log</span>(<span class="st">&quot;a&quot;</span>))
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result: NULL</span>
<span class="co">#&gt;  $ error :List of 2</span>
<span class="co">#&gt;   ..$ message: chr &quot;non-numeric argument to mathematical function&quot;</span>
<span class="co">#&gt;   ..$ call   : language .Primitive(&quot;log&quot;)(x, base)</span>
<span class="co">#&gt;   ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>When the function succeeds, the <code>result</code> element contains the result and the <code>error</code> element is <code>NULL</code>. When the function fails, the <code>result</code> element is <code>NULL</code> and the <code>error</code> element contains an error object.</p>
<p><code>safely()</code> is designed to work with map:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="st">&quot;a&quot;</span>)
y &lt;-<span class="st"> </span>x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(<span class="kw">safely</span>(log))
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: num 0</span>
<span class="co">#&gt;   ..$ error : NULL</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: num 2.3</span>
<span class="co">#&gt;   ..$ error : NULL</span>
<span class="co">#&gt;  $ :List of 2</span>
<span class="co">#&gt;   ..$ result: NULL</span>
<span class="co">#&gt;   ..$ error :List of 2</span>
<span class="co">#&gt;   .. ..$ message: chr &quot;non-numeric argument to mathematical function&quot;</span>
<span class="co">#&gt;   .. ..$ call   : language .Primitive(&quot;log&quot;)(x, base)</span>
<span class="co">#&gt;   .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>This would be easier to work with if we had two lists: one of all the errors and one of all the output. That’s easy to get with <code>purrr::transpose()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>y <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">transpose</span>()
<span class="kw">str</span>(y)
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ result:List of 3</span>
<span class="co">#&gt;   ..$ : num 0</span>
<span class="co">#&gt;   ..$ : num 2.3</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;  $ error :List of 3</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;   ..$ : NULL</span>
<span class="co">#&gt;   ..$ :List of 2</span>
<span class="co">#&gt;   .. ..$ message: chr &quot;non-numeric argument to mathematical function&quot;</span>
<span class="co">#&gt;   .. ..$ call   : language .Primitive(&quot;log&quot;)(x, base)</span>
<span class="co">#&gt;   .. ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;simpleError&quot; &quot;error&quot; &quot;condition&quot;</span></code></pre>
<p>It’s up to you how to deal with the errors, but typically you’ll either look at the values of <code>x</code> where <code>y</code> is an error, or work with the values of <code>y</code> that are ok:</p>
<pre class="sourceCode r"><code class="sourceCode r">is_ok &lt;-<span class="st"> </span>y<span class="op">$</span>error <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_lgl</span>(is_null)
x[<span class="op">!</span>is_ok]
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] &quot;a&quot;</span>
y<span class="op">$</span>result[is_ok] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">flatten_dbl</span>()
<span class="co">#&gt; [1] 0.0 2.3</span></code></pre>
<p>Purrr provides two other useful adverbs:</p>
<ul>
<li><p>Like <code>safely()</code>, <code>possibly()</code> always succeeds. It’s simpler than <code>safely()</code>,
because you give it a default value to return when there is an error.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="st">&quot;a&quot;</span>)
x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map_dbl</span>(<span class="kw">possibly</span>(log, <span class="ot">NA_real_</span>))
<span class="co">#&gt; [1] 0.0 2.3  NA</span></code></pre></li>
<li><p><code>quietly()</code> performs a similar role to <code>safely()</code>, but instead of capturing
errors, it captures printed output, messages, and warnings:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">-1</span>)
x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(<span class="kw">quietly</span>(log)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str</span>()
<span class="co">#&gt; List of 2</span>
<span class="co">#&gt;  $ :List of 4</span>
<span class="co">#&gt;   ..$ result  : num 0</span>
<span class="co">#&gt;   ..$ output  : chr &quot;&quot;</span>
<span class="co">#&gt;   ..$ warnings: chr(0) </span>
<span class="co">#&gt;   ..$ messages: chr(0) </span>
<span class="co">#&gt;  $ :List of 4</span>
<span class="co">#&gt;   ..$ result  : num NaN</span>
<span class="co">#&gt;   ..$ output  : chr &quot;&quot;</span>
<span class="co">#&gt;   ..$ warnings: chr &quot;NaNs produced&quot;</span>
<span class="co">#&gt;   ..$ messages: chr(0)</span></code></pre></li>
</ul>
</div>
<div id="mapping-over-multiple-arguments" class="section level2">
<h2><span class="header-section-number">21.7</span> Mapping over multiple arguments</h2>
<p>So far we’ve mapped along a single input. But often you have multiple related inputs that you need iterate along in parallel. That’s the job of the <code>map2()</code> and <code>pmap()</code> functions. For example, imagine you want to simulate some random normals with different means. You know how to do that with <code>map()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">mu &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">-3</span>)
mu <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(rnorm, <span class="dt">n =</span> <span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:5] 5.45 5.5 5.78 6.51 3.18</span>
<span class="co">#&gt;  $ : num [1:5] 10.79 9.03 10.89 10.76 10.65</span>
<span class="co">#&gt;  $ : num [1:5] -3.54 -3.08 -5.01 -3.51 -2.9</span></code></pre>
<p>What if you also want to vary the standard deviation? One way to do that would be to iterate over the indices and index into vectors of means and sds:</p>
<pre class="sourceCode r"><code class="sourceCode r">sigma &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>)
<span class="kw">seq_along</span>(mu) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="kw">rnorm</span>(<span class="dv">5</span>, mu[[.]], sigma[[.]])) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:5] 4.94 2.57 4.37 4.12 5.29</span>
<span class="co">#&gt;  $ : num [1:5] 11.72 5.32 11.46 10.24 12.22</span>
<span class="co">#&gt;  $ : num [1:5] 3.68 -6.12 22.24 -7.2 10.37</span></code></pre>
<p>But that obfuscates the intent of the code. Instead we could use <code>map2()</code> which iterates over two vectors in parallel:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map2</span>(mu, sigma, rnorm, <span class="dt">n =</span> <span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:5] 4.78 5.59 4.93 4.3 4.47</span>
<span class="co">#&gt;  $ : num [1:5] 10.85 10.57 6.02 8.82 15.93</span>
<span class="co">#&gt;  $ : num [1:5] -1.12 7.39 -7.5 -10.09 -2.7</span></code></pre>
<p><code>map2()</code> generates this series of function calls:</p>
<p><img src="diagrams/lists-map2.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note that the arguments that vary for each call come <em>before</em> the function; arguments that are the same for every call come <em>after</em>.</p>
<p>Like <code>map()</code>, <code>map2()</code> is just a wrapper around a for loop:</p>
<pre class="sourceCode r"><code class="sourceCode r">map2 &lt;-<span class="st"> </span><span class="cf">function</span>(x, y, f, ...) {
  out &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">&quot;list&quot;</span>, <span class="kw">length</span>(x))
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="kw">seq_along</span>(x)) {
    out[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]], y[[i]], ...)
  }
  out
}</code></pre>
<p>You could also imagine <code>map3()</code>, <code>map4()</code>, <code>map5()</code>, <code>map6()</code> etc, but that would get tedious quickly. Instead, purrr provides <code>pmap()</code> which takes a list of arguments. You might use that if you wanted to vary the mean, standard deviation, and number of samples:</p>
<pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>)
args1 &lt;-<span class="st"> </span><span class="kw">list</span>(n, mu, sigma)
args1 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">pmap</span>(rnorm) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num 4.55</span>
<span class="co">#&gt;  $ : num [1:3] 13.4 18.8 13.2</span>
<span class="co">#&gt;  $ : num [1:5] 0.685 10.801 -11.671 21.363 -2.562</span></code></pre>
<p>That looks like:</p>
<p><img src="diagrams/lists-pmap-unnamed.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you don’t name the elements of list, <code>pmap()</code> will use positional matching when calling the function. That’s a little fragile, and makes the code harder to read, so it’s better to name the arguments:</p>
<pre class="sourceCode r"><code class="sourceCode r">args2 &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">mean =</span> mu, <span class="dt">sd =</span> sigma, <span class="dt">n =</span> n)
args2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">pmap</span>(rnorm) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()</code></pre>
<p>That generates longer, but safer, calls:</p>
<p><img src="diagrams/lists-pmap-named.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Since the arguments are all the same length, it makes sense to store them in a data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">params &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>mean, <span class="op">~</span>sd, <span class="op">~</span>n,
    <span class="dv">5</span>,     <span class="dv">1</span>,  <span class="dv">1</span>,
   <span class="dv">10</span>,     <span class="dv">5</span>,  <span class="dv">3</span>,
   <span class="dv">-3</span>,    <span class="dv">10</span>,  <span class="dv">5</span>
)
params <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">pmap</span>(rnorm)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; [1] 4.68</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; [1] 23.44 12.85  7.28</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[3]]</span>
<span class="co">#&gt; [1]  -5.34 -17.66   0.92   6.06   9.02</span></code></pre>
<p>As soon as your code gets complicated, I think a data frame is a good approach because it ensures that each column has a name and is the same length as all the other columns.</p>
<div id="invoking-different-functions" class="section level3">
<h3><span class="header-section-number">21.7.1</span> Invoking different functions</h3>
<p>There’s one more step up in complexity - as well as varying the arguments to the function you might also vary the function itself:</p>
<pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;runif&quot;</span>, <span class="st">&quot;rnorm&quot;</span>, <span class="st">&quot;rpois&quot;</span>)
param &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">list</span>(<span class="dt">min =</span> <span class="dv">-1</span>, <span class="dt">max =</span> <span class="dv">1</span>), 
  <span class="kw">list</span>(<span class="dt">sd =</span> <span class="dv">5</span>), 
  <span class="kw">list</span>(<span class="dt">lambda =</span> <span class="dv">10</span>)
)</code></pre>
<p>To handle this case, you can use <code>invoke_map()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">invoke_map</span>(f, param, <span class="dt">n =</span> <span class="dv">5</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str</span>()
<span class="co">#&gt; List of 3</span>
<span class="co">#&gt;  $ : num [1:5] 0.762 0.36 -0.714 0.531 0.254</span>
<span class="co">#&gt;  $ : num [1:5] 3.07 -3.09 1.1 5.64 9.07</span>
<span class="co">#&gt;  $ : int [1:5] 9 14 8 9 7</span></code></pre>
<p><img src="diagrams/lists-invoke.png" width="1110" style="display: block; margin: auto;" /></p>
<p>The first argument is a list of functions or character vector of function names. The second argument is a list of lists giving the arguments that vary for each function. The subsequent arguments are passed on to every function.</p>
<p>And again, you can use <code>tribble()</code> to make creating these matching pairs a little easier:</p>
<pre class="sourceCode r"><code class="sourceCode r">sim &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>f,      <span class="op">~</span>params,
  <span class="st">&quot;runif&quot;</span>, <span class="kw">list</span>(<span class="dt">min =</span> <span class="dv">-1</span>, <span class="dt">max =</span> <span class="dv">1</span>),
  <span class="st">&quot;rnorm&quot;</span>, <span class="kw">list</span>(<span class="dt">sd =</span> <span class="dv">5</span>),
  <span class="st">&quot;rpois&quot;</span>, <span class="kw">list</span>(<span class="dt">lambda =</span> <span class="dv">10</span>)
)
sim <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sim =</span> <span class="kw">invoke_map</span>(f, params, <span class="dt">n =</span> <span class="dv">10</span>))</code></pre>
</div>
</div>
<div id="walk" class="section level2">
<h2><span class="header-section-number">21.8</span> Walk</h2>
<p>Walk is an alternative to map that you use when you want to call a function for its side effects, rather than for its return value. You typically do this because you want to render output to the screen or save files to disk - the important thing is the action, not the return value. Here’s a very simple example:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>, <span class="dv">3</span>)

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">walk</span>(print)
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] &quot;a&quot;</span>
<span class="co">#&gt; [1] 3</span></code></pre>
<p><code>walk()</code> is generally not that useful compared to <code>walk2()</code> or <code>pwalk()</code>. For example, if you had a list of plots and a vector of file names, you could use <code>pwalk()</code> to save each file to the corresponding location on disk:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ggplot2)
plots &lt;-<span class="st"> </span>mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">split</span>(.<span class="op">$</span>cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="kw">ggplot</span>(., <span class="kw">aes</span>(mpg, wt)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>())
paths &lt;-<span class="st"> </span>stringr<span class="op">::</span><span class="kw">str_c</span>(<span class="kw">names</span>(plots), <span class="st">&quot;.pdf&quot;</span>)

<span class="kw">pwalk</span>(<span class="kw">list</span>(paths, plots), ggsave, <span class="dt">path =</span> <span class="kw">tempdir</span>())</code></pre>
<p><code>walk()</code>, <code>walk2()</code> and <code>pwalk()</code> all invisibly return <code>.x</code>, the first argument. This makes them suitable for use in the middle of pipelines.</p>
</div>
<div id="other-patterns-of-for-loops" class="section level2">
<h2><span class="header-section-number">21.9</span> Other patterns of for loops</h2>
<p>Purrr provides a number of other functions that abstract over other types of for loops. You’ll use them less frequently than the map functions, but they’re useful to know about. The goal here is to briefly illustrate each function, so hopefully it will come to mind if you see a similar problem in the future. Then you can go look up the documentation for more details.</p>
<div id="predicate-functions" class="section level3">
<h3><span class="header-section-number">21.9.1</span> Predicate functions</h3>
<p>A number of functions work with <strong>predicate</strong> functions that return either a single <code>TRUE</code> or <code>FALSE</code>.</p>
<p><code>keep()</code> and <code>discard()</code> keep elements of the input where the predicate is <code>TRUE</code> or <code>FALSE</code> respectively:</p>
<pre class="sourceCode r"><code class="sourceCode r">iris <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">keep</span>(is.factor) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt; &#39;data.frame&#39;:    150 obs. of  1 variable:</span>
<span class="co">#&gt;  $ Species: Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...</span>

iris <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">discard</span>(is.factor) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">str</span>()
<span class="co">#&gt; &#39;data.frame&#39;:    150 obs. of  4 variables:</span>
<span class="co">#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...</span>
<span class="co">#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...</span>
<span class="co">#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...</span>
<span class="co">#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...</span></code></pre>
<p><code>some()</code> and <code>every()</code> determine if the predicate is true for any or for all of
the elements.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, letters, <span class="kw">list</span>(<span class="dv">10</span>))

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">some</span>(is_character)
<span class="co">#&gt; [1] TRUE</span>

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">every</span>(is_vector)
<span class="co">#&gt; [1] TRUE</span></code></pre>
<p><code>detect()</code> finds the first element where the predicate is true; <code>detect_index()</code> returns its position.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>)
x
<span class="co">#&gt;  [1]  8  7  5  6  9  2 10  1  3  4</span>

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">detect</span>(<span class="op">~</span><span class="st"> </span>. <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt; [1] 8</span>

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">detect_index</span>(<span class="op">~</span><span class="st"> </span>. <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt; [1] 1</span></code></pre>
<p><code>head_while()</code> and <code>tail_while()</code> take elements from the start or end of a vector while a predicate is true:</p>
<pre class="sourceCode r"><code class="sourceCode r">x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">head_while</span>(<span class="op">~</span><span class="st"> </span>. <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt; [1] 8 7</span>

x <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">tail_while</span>(<span class="op">~</span><span class="st"> </span>. <span class="op">&gt;</span><span class="st"> </span><span class="dv">5</span>)
<span class="co">#&gt; integer(0)</span></code></pre>
</div>
<div id="reduce-and-accumulate" class="section level3">
<h3><span class="header-section-number">21.9.2</span> Reduce and accumulate</h3>
<p>Sometimes you have a complex list that you want to reduce to a simple list by repeatedly applying a function that reduces a pair to a singleton. This is useful if you want to apply a two-table dplyr verb to multiple tables. For example, you might have a list of data frames, and you want to reduce to a single data frame by joining the elements together:</p>
<pre class="sourceCode r"><code class="sourceCode r">dfs &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">age =</span> <span class="kw">tibble</span>(<span class="dt">name =</span> <span class="st">&quot;John&quot;</span>, <span class="dt">age =</span> <span class="dv">30</span>),
  <span class="dt">sex =</span> <span class="kw">tibble</span>(<span class="dt">name =</span> <span class="kw">c</span>(<span class="st">&quot;John&quot;</span>, <span class="st">&quot;Mary&quot;</span>), <span class="dt">sex =</span> <span class="kw">c</span>(<span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>)),
  <span class="dt">trt =</span> <span class="kw">tibble</span>(<span class="dt">name =</span> <span class="st">&quot;Mary&quot;</span>, <span class="dt">treatment =</span> <span class="st">&quot;A&quot;</span>)
)

dfs <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">reduce</span>(full_join)
<span class="co">#&gt; Joining, by = &quot;name&quot;</span>
<span class="co">#&gt; Joining, by = &quot;name&quot;</span>
<span class="co">#&gt; # A tibble: 2 x 4</span>
<span class="co">#&gt;   name    age sex   treatment</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    </span>
<span class="co">#&gt; 1 John     30 M     &lt;NA&gt;     </span>
<span class="co">#&gt; 2 Mary     NA F     A</span></code></pre>
<p>Or maybe you have a list of vectors, and want to find the intersection:</p>
<pre class="sourceCode r"><code class="sourceCode r">vs &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">10</span>),
  <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">10</span>),
  <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>)
)

vs <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">reduce</span>(intersect)
<span class="co">#&gt; [1]  1  3 10</span></code></pre>
<p>The reduce function takes a “binary” function (i.e. a function with two primary inputs), and applies it repeatedly to a list until there is only a single element left.</p>
<p>Accumulate is similar but it keeps all the interim results. You could use it to implement a cumulative sum:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">10</span>)
x
<span class="co">#&gt;  [1]  6  9  8  5  2  4  7  1 10  3</span>
x <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">accumulate</span>(<span class="st">`</span><span class="dt">+</span><span class="st">`</span>)
<span class="co">#&gt;  [1]  6 15 23 28 30 34 41 42 52 55</span></code></pre>
</div>
<div id="exercises-59" class="section level3">
<h3><span class="header-section-number">21.9.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Implement your own version of <code>every()</code> using a for loop. Compare it with
<code>purrr::every()</code>. What does purrr’s version do that your version doesn’t?</p></li>
<li><p>Create an enhanced <code>col_summary()</code> that applies a summary function to every
numeric column in a data frame.</p></li>
<li><p>A possible base R equivalent of <code>col_summary()</code> is:</p>
<pre class="sourceCode r"><code class="sourceCode r">col_sum3 &lt;-<span class="st"> </span><span class="cf">function</span>(df, f) {
  is_num &lt;-<span class="st"> </span><span class="kw">sapply</span>(df, is.numeric)
  df_num &lt;-<span class="st"> </span>df[, is_num]

  <span class="kw">sapply</span>(df_num, f)
}</code></pre>
<p>But it has a number of bugs as illustrated with the following inputs:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, 
  <span class="dt">y =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">1</span>,
  <span class="dt">z =</span> <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)
)
<span class="co"># OK</span>
<span class="kw">col_sum3</span>(df, mean)
<span class="co"># Has problems: don&#39;t always return numeric vector</span>
<span class="kw">col_sum3</span>(df[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], mean)
<span class="kw">col_sum3</span>(df[<span class="dv">1</span>], mean)
<span class="kw">col_sum3</span>(df[<span class="dv">0</span>], mean)</code></pre>
<p>What causes the bugs?</p></li>
</ol>
<!--chapter:end:iteration.Rmd-->
</div>
</div>
</div>
<div id="part-model" class="section level1 unnumbered">
<h1><span class="header-section-number">IV</span> Model</h1>
</div>
<div id="model-intro" class="section level1">
<h1><span class="header-section-number">22</span> Introduction</h1>
<p>Now that you are equipped with powerful programming tools we can finally return to modelling. You’ll use your new tools of data wrangling and programming, to fit many models and understand how they work. The focus of this book is on exploration, not confirmation or formal inference. But you’ll learn a few basic tools that help you understand the variation within your models.</p>
<p><img src="diagrams/data-science-model.png" width="75%" style="display: block; margin: auto;" /></p>
<p>The goal of a model is to provide a simple low-dimensional summary of a dataset. Ideally, the model will capture true “signals” (i.e. patterns generated by the phenomenon of interest), and ignore “noise” (i.e. random variation that you’re not interested in). Here we only cover “predictive” models, which, as the name suggests, generate predictions. There is another type of model that we’re not going to discuss: “data discovery” models. These models don’t make predictions, but instead help you discover interesting relationships within your data. (These two categories of models are sometimes called supervised and unsupervised, but I don’t think that terminology is particularly illuminating.)</p>
<p>This book is not going to give you a deep understanding of the mathematical theory that underlies models. It will, however, build your intuition about how statistical models work, and give you a family of useful tools that allow you to use models to better understand your data:</p>
<ul>
<li><p>In <a href="#model-basics">model basics</a>, you’ll learn how models work mechanistically, focussing on
the important family of linear models. You’ll learn general tools for gaining
insight into what a predictive model tells you about your data, focussing on
simple simulated datasets.</p></li>
<li><p>In <a href="#model-building">model building</a>, you’ll learn how to use models to pull out known
patterns in real data. Once you have recognised an important pattern
it’s useful to make it explicit in a model, because then you can
more easily see the subtler signals that remain.</p></li>
<li><p>In <a href="#many-models">many models</a>, you’ll learn how to use many simple models to help
understand complex datasets. This is a powerful technique, but to access
it you’ll need to combine modelling and programming tools.</p></li>
</ul>
<p>These topics are notable because of what they don’t include: any tools for quantitatively assessing models. That is deliberate: precisely quantifying a model requires a couple of big ideas that we just don’t have the space to cover here. For now, you’ll rely on qualitative assessment and your natural scepticism. In <a href="#learning-more-about-models">Learning more about models</a>, we’ll point you to other resources where you can learn more.</p>
<div id="hypothesis-generation-vs.hypothesis-confirmation" class="section level2">
<h2><span class="header-section-number">22.1</span> Hypothesis generation vs. hypothesis confirmation</h2>
<p>In this book, we are going to use models as a tool for exploration, completing the trifecta of the tools for EDA that were introduced in Part 1. This is not how models are usually taught, but as you will see, models are an important tool for exploration. Traditionally, the focus of modelling is on inference, or for confirming that an hypothesis is true. Doing this correctly is not complicated, but it is hard. There is a pair of ideas that you must understand in order to do inference correctly:</p>
<ol style="list-style-type: decimal">
<li><p>Each observation can either be used for exploration or confirmation,
not both.</p></li>
<li><p>You can use an observation as many times as you like for exploration,
but you can only use it once for confirmation. As soon as you use an
observation twice, you’ve switched from confirmation to exploration.</p></li>
</ol>
<p>This is necessary because to confirm a hypothesis you must use data independent of the data that you used to generate the hypothesis. Otherwise you will be over optimistic. There is absolutely nothing wrong with exploration, but you should never sell an exploratory analysis as a confirmatory analysis because it is fundamentally misleading.</p>
<p>If you are serious about doing an confirmatory analysis, one approach is to split your data into three pieces before you begin the analysis:</p>
<ol style="list-style-type: decimal">
<li><p>60% of your data goes into a <strong>training</strong> (or exploration) set. You’re
allowed to do anything you like with this data: visualise it and fit tons
of models to it.</p></li>
<li><p>20% goes into a <strong>query</strong> set. You can use this data to compare models
or visualisations by hand, but you’re not allowed to use it as part of
an automated process.</p></li>
<li><p>20% is held back for a <strong>test</strong> set. You can only use this data ONCE, to
test your final model.</p></li>
</ol>
<p>This partitioning allows you to explore the training data, occasionally generating candidate hypotheses that you check with the query set. When you are confident you have the right model, you can check it once with the test data.</p>
<p>(Note that even when doing confirmatory modelling, you will still need to do EDA. If you don’t do any EDA you will remain blind to the quality problems with your data.)</p>
<!--chapter:end:model.Rmd-->
</div>
</div>
<div id="model-basics" class="section level1">
<h1><span class="header-section-number">23</span> Model basics</h1>
<div id="introduction-15" class="section level2">
<h2><span class="header-section-number">23.1</span> Introduction</h2>
<p>The goal of a model is to provide a simple low-dimensional summary of a dataset. In the context of this book we’re going to use models to partition data into patterns and residuals. Strong patterns will hide subtler trends, so we’ll use models to help peel back layers of structure as we explore a dataset.</p>
<p>However, before we can start using models on interesting, real, datasets, you need to understand the basics of how models work. For that reason, this chapter of the book is unique because it uses only simulated datasets. These datasets are very simple, and not at all interesting, but they will help you understand the essence of modelling before you apply the same techniques to real data in the next chapter.</p>
<p>There are two parts to a model:</p>
<ol style="list-style-type: decimal">
<li><p>First, you define a <strong>family of models</strong> that express a precise, but
generic, pattern that you want to capture. For example, the pattern
might be a straight line, or a quadratic curve. You will express
the model family as an equation like <code>y = a_1 * x + a_2</code> or
<code>y = a_1 * x ^ a_2</code>. Here, <code>x</code> and <code>y</code> are known variables from your
data, and <code>a_1</code> and <code>a_2</code> are parameters that can vary to capture
different patterns.</p></li>
<li><p>Next, you generate a <strong>fitted model</strong> by finding the model from the
family that is the closest to your data. This takes the generic model
family and makes it specific, like <code>y = 3 * x + 7</code> or <code>y = 9 * x ^ 2</code>.</p></li>
</ol>
<p>It’s important to understand that a fitted model is just the closest model from a family of models. That implies that you have the “best” model (according to some criteria); it doesn’t imply that you have a good model and it certainly doesn’t imply that the model is “true”. George Box puts this well in his famous aphorism:</p>
<blockquote>
<p>All models are wrong, but some are useful.</p>
</blockquote>
<p>It’s worth reading the fuller context of the quote:</p>
<blockquote>
<p>Now it would be very remarkable if any system existing in the real world
could be exactly represented by any simple model. However, cunningly chosen
parsimonious models often do provide remarkably useful approximations. For
example, the law PV = RT relating pressure P, volume V and temperature T of
an “ideal” gas via a constant R is not exactly true for any real gas, but it
frequently provides a useful approximation and furthermore its structure is
informative since it springs from a physical view of the behavior of gas
molecules.</p>
<p>For such a model there is no need to ask the question “Is the model true?”.
If “truth” is to be the “whole truth” the answer must be “No”. The only
question of interest is “Is the model illuminating and useful?”.</p>
</blockquote>
<p>The goal of a model is not to uncover truth, but to discover a simple approximation that is still useful.</p>
<div id="prerequisites-15" class="section level3">
<h3><span class="header-section-number">23.1.1</span> Prerequisites</h3>
<p>In this chapter we’ll use the modelr package which wraps around base R’s modelling functions to make them work naturally in a pipe.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)

<span class="kw">library</span>(modelr)
<span class="kw">options</span>(<span class="dt">na.action =</span> na.warn)</code></pre>
</div>
</div>
<div id="a-simple-model" class="section level2">
<h2><span class="header-section-number">23.2</span> A simple model</h2>
<p>Lets take a look at the simulated dataset <code>sim1</code>, included with the modelr package. It contains two continuous variables, <code>x</code> and <code>y</code>. Let’s plot them to see how they’re related:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can see a strong pattern in the data. Let’s use a model to capture that pattern and make it explicit. It’s our job to supply the basic form of the model. In this case, the relationship looks linear, i.e. <code>y = a_0 + a_1 * x</code>. Let’s start by getting a feel for what models from that family look like by randomly generating a few and overlaying them on the data. For this simple case, we can use <code>geom_abline()</code> which takes a slope and intercept as parameters. Later on we’ll learn more general techniques that work with any model.</p>
<pre class="sourceCode r"><code class="sourceCode r">models &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">a1 =</span> <span class="kw">runif</span>(<span class="dv">250</span>, <span class="dv">-20</span>, <span class="dv">40</span>),
  <span class="dt">a2 =</span> <span class="kw">runif</span>(<span class="dv">250</span>, <span class="dv">-5</span>, <span class="dv">5</span>)
)

<span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="kw">aes</span>(<span class="dt">intercept =</span> a1, <span class="dt">slope =</span> a2), <span class="dt">data =</span> models, <span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">4</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() </code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are 250 models on this plot, but a lot are really bad! We need to find the good models by making precise our intuition that a good model is “close” to the data. We need a way to quantify the distance between the data and a model. Then we can fit the model by finding the value of <code>a_0</code> and <code>a_1</code> that generate the model with the smallest distance from this data.</p>
<p>One easy place to start is to find the vertical distance between each point and the model, as in the following diagram. (Note that I’ve shifted the x values slightly so you can see the individual distances.)</p>
<p><img src="model-basics_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This distance is just the difference between the y value given by the model (the <strong>prediction</strong>), and the actual y value in the data (the <strong>response</strong>).</p>
<p>To compute this distance, we first turn our model family into an R function. This takes the model parameters and the data as inputs, and gives values predicted by the model as output:</p>
<pre class="sourceCode r"><code class="sourceCode r">model1 &lt;-<span class="st"> </span><span class="cf">function</span>(a, data) {
  a[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>data<span class="op">$</span>x <span class="op">*</span><span class="st"> </span>a[<span class="dv">2</span>]
}
<span class="kw">model1</span>(<span class="kw">c</span>(<span class="dv">7</span>, <span class="fl">1.5</span>), sim1)
<span class="co">#&gt;  [1]  8.5  8.5  8.5 10.0 10.0 10.0 11.5 11.5 11.5 13.0 13.0 13.0 14.5 14.5</span>
<span class="co">#&gt; [15] 14.5 16.0 16.0 16.0 17.5 17.5 17.5 19.0 19.0 19.0 20.5 20.5 20.5 22.0</span>
<span class="co">#&gt; [29] 22.0 22.0</span></code></pre>
<p>Next, we need some way to compute an overall distance between the predicted and actual values. In other words, the plot above shows 30 distances: how do we collapse that into a single number?</p>
<p>One common way to do this in statistics to use the “root-mean-squared deviation”. We compute the difference between actual and predicted, square them, average them, and the take the square root. This distance has lots of appealing mathematical properties, which we’re not going to talk about here. You’ll just have to take my word for it!</p>
<pre class="sourceCode r"><code class="sourceCode r">measure_distance &lt;-<span class="st"> </span><span class="cf">function</span>(mod, data) {
  diff &lt;-<span class="st"> </span>data<span class="op">$</span>y <span class="op">-</span><span class="st"> </span><span class="kw">model1</span>(mod, data)
  <span class="kw">sqrt</span>(<span class="kw">mean</span>(diff <span class="op">^</span><span class="st"> </span><span class="dv">2</span>))
}
<span class="kw">measure_distance</span>(<span class="kw">c</span>(<span class="dv">7</span>, <span class="fl">1.5</span>), sim1)
<span class="co">#&gt; [1] 2.67</span></code></pre>
<p>Now we can use purrr to compute the distance for all the models defined above. We need a helper function because our distance function expects the model as a numeric vector of length 2.</p>
<pre class="sourceCode r"><code class="sourceCode r">sim1_dist &lt;-<span class="st"> </span><span class="cf">function</span>(a1, a2) {
  <span class="kw">measure_distance</span>(<span class="kw">c</span>(a1, a2), sim1)
}

models &lt;-<span class="st"> </span>models <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dist =</span> purrr<span class="op">::</span><span class="kw">map2_dbl</span>(a1, a2, sim1_dist))
models
<span class="co">#&gt; # A tibble: 250 x 3</span>
<span class="co">#&gt;       a1      a2  dist</span>
<span class="co">#&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 -15.2   0.0889  30.8</span>
<span class="co">#&gt; 2  30.1  -0.827   13.2</span>
<span class="co">#&gt; 3  16.0   2.27    13.2</span>
<span class="co">#&gt; 4 -10.6   1.38    18.7</span>
<span class="co">#&gt; 5 -19.6  -1.04    41.8</span>
<span class="co">#&gt; 6   7.98  4.59    19.3</span>
<span class="co">#&gt; # … with 244 more rows</span></code></pre>
<p>Next, let’s overlay the 10 best models on to the data. I’ve coloured the models by <code>-dist</code>: this is an easy way to make sure that the best models (i.e. the ones with the smallest distance) get the brighest colours.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">colour =</span> <span class="st">&quot;grey30&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_abline</span>(
    <span class="kw">aes</span>(<span class="dt">intercept =</span> a1, <span class="dt">slope =</span> a2, <span class="dt">colour =</span> <span class="op">-</span>dist), 
    <span class="dt">data =</span> <span class="kw">filter</span>(models, <span class="kw">rank</span>(dist) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span>)
  )</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We can also think about these models as observations, and visualising with a scatterplot of <code>a1</code> vs <code>a2</code>, again coloured by <code>-dist</code>. We can no longer directly see how the model compares to the data, but we can see many models at once. Again, I’ve highlighted the 10 best models, this time by drawing red circles underneath them.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(models, <span class="kw">aes</span>(a1, a2)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> <span class="kw">filter</span>(models, <span class="kw">rank</span>(dist) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span>), <span class="dt">size =</span> <span class="dv">4</span>, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> <span class="op">-</span>dist))</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Instead of trying lots of random models, we could be more systematic and generate an evenly spaced grid of points (this is called a grid search). I picked the parameters of the grid roughly by looking at where the best models were in the plot above.</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(
  <span class="dt">a1 =</span> <span class="kw">seq</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">20</span>, <span class="dt">length =</span> <span class="dv">25</span>),
  <span class="dt">a2 =</span> <span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dt">length =</span> <span class="dv">25</span>)
  ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">dist =</span> purrr<span class="op">::</span><span class="kw">map2_dbl</span>(a1, a2, sim1_dist))

grid <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(a1, a2)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> <span class="kw">filter</span>(grid, <span class="kw">rank</span>(dist) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span>), <span class="dt">size =</span> <span class="dv">4</span>, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> <span class="op">-</span>dist)) </code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>When you overlay the best 10 models back on the original data, they all look pretty good:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">colour =</span> <span class="st">&quot;grey30&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_abline</span>(
    <span class="kw">aes</span>(<span class="dt">intercept =</span> a1, <span class="dt">slope =</span> a2, <span class="dt">colour =</span> <span class="op">-</span>dist), 
    <span class="dt">data =</span> <span class="kw">filter</span>(grid, <span class="kw">rank</span>(dist) <span class="op">&lt;=</span><span class="st"> </span><span class="dv">10</span>)
  )</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You could imagine iteratively making the grid finer and finer until you narrowed in on the best model. But there’s a better way to tackle that problem: a numerical minimisation tool called Newton-Raphson search. The intuition of Newton-Raphson is pretty simple: you pick a starting point and look around for the steepest slope. You then ski down that slope a little way, and then repeat again and again, until you can’t go any lower. In R, we can do that with <code>optim()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">best &lt;-<span class="st"> </span><span class="kw">optim</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">0</span>), measure_distance, <span class="dt">data =</span> sim1)
best<span class="op">$</span>par
<span class="co">#&gt; [1] 4.22 2.05</span>

<span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">colour =</span> <span class="st">&quot;grey30&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">intercept =</span> best<span class="op">$</span>par[<span class="dv">1</span>], <span class="dt">slope =</span> best<span class="op">$</span>par[<span class="dv">2</span>])</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Don’t worry too much about the details of how <code>optim()</code> works. It’s the intuition that’s important here. If you have a function that defines the distance between a model and a dataset, an algorithm that can minimise that distance by modifying the parameters of the model, you can find the best model. The neat thing about this approach is that it will work for any family of models that you can write an equation for.</p>
<p>There’s one more approach that we can use for this model, because it’s a special case of a broader family: linear models. A linear model has the general form <code>y = a_1 + a_2 * x_1 + a_3 * x_2 + ... + a_n * x_(n - 1)</code>. So this simple model is equivalent to a general linear model where n is 2 and <code>x_1</code> is <code>x</code>. R has a tool specifically designed for fitting linear models called <code>lm()</code>. <code>lm()</code> has a special way to specify the model family: formulas. Formulas look like <code>y ~ x</code>, which <code>lm()</code> will translate to a function like <code>y = a_1 + a_2 * x</code>. We can fit the model and look at the output:</p>
<pre class="sourceCode r"><code class="sourceCode r">sim1_mod &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> sim1)
<span class="kw">coef</span>(sim1_mod)
<span class="co">#&gt; (Intercept)           x </span>
<span class="co">#&gt;        4.22        2.05</span></code></pre>
<p>These are exactly the same values we got with <code>optim()</code>! Behind the scenes <code>lm()</code> doesn’t use <code>optim()</code> but instead takes advantage of the mathematical structure of linear models. Using some connections between geometry, calculus, and linear algebra, <code>lm()</code> actually finds the closest model in a single step, using a sophisticated algorithm. This approach is both faster, and guarantees that there is a global minimum.</p>
<div id="exercises-60" class="section level3">
<h3><span class="header-section-number">23.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>One downside of the linear model is that it is sensitive to unusual values
because the distance incorporates a squared term. Fit a linear model to
the simulated data below, and visualise the results. Rerun a few times to
generate different simulated datasets. What do you notice about the model?</p>
<pre class="sourceCode r"><code class="sourceCode r">sim1a &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">each =</span> <span class="dv">3</span>),
  <span class="dt">y =</span> x <span class="op">*</span><span class="st"> </span><span class="fl">1.5</span> <span class="op">+</span><span class="st"> </span><span class="dv">6</span> <span class="op">+</span><span class="st"> </span><span class="kw">rt</span>(<span class="kw">length</span>(x), <span class="dt">df =</span> <span class="dv">2</span>)
)</code></pre></li>
<li><p>One way to make linear models more robust is to use a different distance
measure. For example, instead of root-mean-squared distance, you could use
mean-absolute distance:</p>
<pre class="sourceCode r"><code class="sourceCode r">measure_distance &lt;-<span class="st"> </span><span class="cf">function</span>(mod, data) {
  diff &lt;-<span class="st"> </span>data<span class="op">$</span>y <span class="op">-</span><span class="st"> </span><span class="kw">model1</span>(mod, data)
  <span class="kw">mean</span>(<span class="kw">abs</span>(diff))
}</code></pre>
<p>Use <code>optim()</code> to fit this model to the simulated data above and compare it
to the linear model.</p></li>
<li><p>One challenge with performing numerical optimisation is that it’s only
guaranteed to find one local optimum. What’s the problem with optimising
a three parameter model like this?</p>
<pre class="sourceCode r"><code class="sourceCode r">model1 &lt;-<span class="st"> </span><span class="cf">function</span>(a, data) {
  a[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>data<span class="op">$</span>x <span class="op">*</span><span class="st"> </span>a[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>a[<span class="dv">3</span>]
}</code></pre></li>
</ol>
</div>
</div>
<div id="visualising-models" class="section level2">
<h2><span class="header-section-number">23.3</span> Visualising models</h2>
<p>For simple models, like the one above, you can figure out what pattern the model captures by carefully studying the model family and the fitted coefficients. And if you ever take a statistics course on modelling, you’re likely to spend a lot of time doing just that. Here, however, we’re going to take a different tack. We’re going to focus on understanding a model by looking at its predictions. This has a big advantage: every type of predictive model makes predictions (otherwise what use would it be?) so we can use the same set of techniques to understand any type of predictive model.</p>
<p>It’s also useful to see what the model doesn’t capture, the so-called residuals which are left after subtracting the predictions from the data. Residuals are powerful because they allow us to use models to remove striking patterns so we can study the subtler trends that remain.</p>
<div id="predictions" class="section level3">
<h3><span class="header-section-number">23.3.1</span> Predictions</h3>
<p>To visualise the predictions from a model, we start by generating an evenly spaced grid of values that covers the region where our data lies. The easiest way to do that is to use <code>modelr::data_grid()</code>. Its first argument is a data frame, and for each subsequent argument it finds the unique variables and then generates all combinations:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>sim1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(x) 
grid
<span class="co">#&gt; # A tibble: 10 x 1</span>
<span class="co">#&gt;       x</span>
<span class="co">#&gt;   &lt;int&gt;</span>
<span class="co">#&gt; 1     1</span>
<span class="co">#&gt; 2     2</span>
<span class="co">#&gt; 3     3</span>
<span class="co">#&gt; 4     4</span>
<span class="co">#&gt; 5     5</span>
<span class="co">#&gt; 6     6</span>
<span class="co">#&gt; # … with 4 more rows</span></code></pre>
<p>(This will get more interesting when we start to add more variables to our model.)</p>
<p>Next we add predictions. We’ll use <code>modelr::add_predictions()</code> which takes a data frame and a model. It adds the predictions from the model to a new column in the data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>grid <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(sim1_mod) 
grid
<span class="co">#&gt; # A tibble: 10 x 2</span>
<span class="co">#&gt;       x  pred</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1  6.27</span>
<span class="co">#&gt; 2     2  8.32</span>
<span class="co">#&gt; 3     3 10.4 </span>
<span class="co">#&gt; 4     4 12.4 </span>
<span class="co">#&gt; 5     5 14.5 </span>
<span class="co">#&gt; 6     6 16.5 </span>
<span class="co">#&gt; # … with 4 more rows</span></code></pre>
<p>(You can also use this function to add predictions to your original dataset.)</p>
<p>Next, we plot the predictions. You might wonder about all this extra work compared to just using <code>geom_abline()</code>. But the advantage of this approach is that it will work with <em>any</em> model in R, from the simplest to the most complex. You’re only limited by your visualisation skills. For more ideas about how to visualise more complex model types, you might try <a href="http://vita.had.co.nz/papers/model-vis.html" class="uri">http://vita.had.co.nz/papers/model-vis.html</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">y =</span> pred), <span class="dt">data =</span> grid, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">size =</span> <span class="dv">1</span>)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="residuals" class="section level3">
<h3><span class="header-section-number">23.3.2</span> Residuals</h3>
<p>The flip-side of predictions are <strong>residuals</strong>. The predictions tells you the pattern that the model has captured, and the residuals tell you what the model has missed. The residuals are just the distances between the observed and predicted values that we computed above.</p>
<p>We add residuals to the data with <code>add_residuals()</code>, which works much like <code>add_predictions()</code>. Note, however, that we use the original dataset, not a manufactured grid. This is because to compute residuals we need actual y values.</p>
<pre class="sourceCode r"><code class="sourceCode r">sim1 &lt;-<span class="st"> </span>sim1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(sim1_mod)
sim1
<span class="co">#&gt; # A tibble: 30 x 3</span>
<span class="co">#&gt;       x     y  resid</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1  4.20 -2.07 </span>
<span class="co">#&gt; 2     1  7.51  1.24 </span>
<span class="co">#&gt; 3     1  2.13 -4.15 </span>
<span class="co">#&gt; 4     2  8.99  0.665</span>
<span class="co">#&gt; 5     2 10.2   1.92 </span>
<span class="co">#&gt; 6     2 11.3   2.97 </span>
<span class="co">#&gt; # … with 24 more rows</span></code></pre>
<p>There are a few different ways to understand what the residuals tell us about the model. One way is to simply draw a frequency polygon to help us understand the spread of the residuals:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_freqpoly</span>(<span class="dt">binwidth =</span> <span class="fl">0.5</span>)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This helps you calibrate the quality of the model: how far away are the predictions from the observed values? Note that the average of the residual will always be 0.</p>
<p>You’ll often want to recreate plots using the residuals instead of the original predictor. You’ll see a lot of that in the next chapter.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim1, <span class="kw">aes</span>(x, resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_ref_line</span>(<span class="dt">h =</span> <span class="dv">0</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() </code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This looks like random noise, suggesting that our model has done a good job of capturing the patterns in the dataset.</p>
</div>
<div id="exercises-61" class="section level3">
<h3><span class="header-section-number">23.3.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Instead of using <code>lm()</code> to fit a straight line, you can use <code>loess()</code>
to fit a smooth curve. Repeat the process of model fitting,
grid generation, predictions, and visualisation on <code>sim1</code> using
<code>loess()</code> instead of <code>lm()</code>. How does the result compare to
<code>geom_smooth()</code>?</p></li>
<li><p><code>add_predictions()</code> is paired with <code>gather_predictions()</code> and
<code>spread_predictions()</code>. How do these three functions differ?</p></li>
<li><p>What does <code>geom_ref_line()</code> do? What package does it come from?
Why is displaying a reference line in plots showing residuals
useful and important?</p></li>
<li><p>Why might you want to look at a frequency polygon of absolute residuals?
What are the pros and cons compared to looking at the raw residuals?</p></li>
</ol>
</div>
</div>
<div id="formulas-and-model-families" class="section level2">
<h2><span class="header-section-number">23.4</span> Formulas and model families</h2>
<p>You’ve seen formulas before when using <code>facet_wrap()</code> and <code>facet_grid()</code>. In R, formulas provide a general way of getting “special behaviour”. Rather than evaluating the values of the variables right away, they capture them so they can be interpreted by the function.</p>
<p>The majority of modelling functions in R use a standard conversion from formulas to functions. You’ve seen one simple conversion already: <code>y ~ x</code> is translated to <code>y = a_1 + a_2 * x</code>. If you want to see what R actually does, you can use the <code>model_matrix()</code> function. It takes a data frame and a formula and returns a tibble that defines the model equation: each column in the output is associated with one coefficient in the model, the function is always <code>y = a_1 * out1 + a_2 * out_2</code>. For the simplest case of <code>y ~ x1</code> this shows us something interesting:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>y, <span class="op">~</span>x1, <span class="op">~</span>x2,
  <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">5</span>,
  <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">6</span>
)
<span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span>x1)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   `(Intercept)`    x1</span>
<span class="co">#&gt;           &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1     2</span>
<span class="co">#&gt; 2             1     1</span></code></pre>
<p>The way that R adds the intercept to the model is just by having a column that is full of ones. By default, R will always add this column. If you don’t want, you need to explicitly drop it with <code>-1</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span>x1 <span class="op">-</span><span class="st"> </span><span class="dv">1</span>)
<span class="co">#&gt; # A tibble: 2 x 1</span>
<span class="co">#&gt;      x1</span>
<span class="co">#&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1     2</span>
<span class="co">#&gt; 2     1</span></code></pre>
<p>The model matrix grows in an unsurprising way when you add more variables to the the model:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;   `(Intercept)`    x1    x2</span>
<span class="co">#&gt;           &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1     2     5</span>
<span class="co">#&gt; 2             1     1     6</span></code></pre>
<p>This formula notation is sometimes called “Wilkinson-Rogers notation”, and was initially described in <em>Symbolic Description of Factorial Models for Analysis of Variance</em>, by G. N. Wilkinson and C. E. Rogers <a href="https://www.jstor.org/stable/2346786" class="uri">https://www.jstor.org/stable/2346786</a>. It’s worth digging up and reading the original paper if you’d like to understand the full details of the modelling algebra.</p>
<p>The following sections expand on how this formula notation works for categorical variables, interactions, and transformation.</p>
<div id="categorical-variables" class="section level3">
<h3><span class="header-section-number">23.4.1</span> Categorical variables</h3>
<p>Generating a function from a formula is straight forward when the predictor is continuous, but things get a bit more complicated when the predictor is categorical. Imagine you have a formula like <code>y ~ sex</code>, where sex could either be male or female. It doesn’t make sense to convert that to a formula like <code>y = x_0 + x_1 * sex</code> because <code>sex</code> isn’t a number - you can’t multiply it! Instead what R does is convert it to <code>y = x_0 + x_1 * sex_male</code> where <code>sex_male</code> is one if <code>sex</code> is male and zero otherwise:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span><span class="st"> </span>sex, <span class="op">~</span><span class="st"> </span>response,
  <span class="st">&quot;male&quot;</span>, <span class="dv">1</span>,
  <span class="st">&quot;female&quot;</span>, <span class="dv">2</span>,
  <span class="st">&quot;male&quot;</span>, <span class="dv">1</span>
)
<span class="kw">model_matrix</span>(df, response <span class="op">~</span><span class="st"> </span>sex)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   `(Intercept)` sexmale</span>
<span class="co">#&gt;           &lt;dbl&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1       1</span>
<span class="co">#&gt; 2             1       0</span>
<span class="co">#&gt; 3             1       1</span></code></pre>
<p>You might wonder why R also doesn’t create a <code>sexfemale</code> column. The problem is that would create a column that is perfectly predictable based on the other columns (i.e. <code>sexfemale = 1 - sexmale</code>). Unfortunately the exact details of why this is a problem is beyond the scope of this book, but basically it creates a model family that is too flexible, and will have infinitely many models that are equally close to the data.</p>
<p>Fortunately, however, if you focus on visualising predictions you don’t need to worry about the exact parameterisation. Let’s look at some data and models to make that concrete. Here’s the <code>sim2</code> dataset from modelr:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim2) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(x, y))</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-27-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We can fit a model to it, and generate predictions:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> sim2)

grid &lt;-<span class="st"> </span>sim2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod2)
grid
<span class="co">#&gt; # A tibble: 4 x 2</span>
<span class="co">#&gt;   x      pred</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 a      1.15</span>
<span class="co">#&gt; 2 b      8.12</span>
<span class="co">#&gt; 3 c      6.13</span>
<span class="co">#&gt; 4 d      1.91</span></code></pre>
<p>Effectively, a model with a categorical <code>x</code> will predict the mean value for each category. (Why? Because the mean minimises the root-mean-squared distance.) That’s easy to see if we overlay the predictions on top of the original data:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim2, <span class="kw">aes</span>(x)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">y =</span> y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> grid, <span class="kw">aes</span>(<span class="dt">y =</span> pred), <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">size =</span> <span class="dv">4</span>)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-29-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can’t make predictions about levels that you didn’t observe. Sometimes you’ll do this by accident so it’s good to recognise this error message:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="st">&quot;e&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod2)
<span class="co">#&gt; Error in model.frame.default(Terms, newdata, na.action = na.action, xlev = object$xlevels): factor x has new level e</span></code></pre>
</div>
<div id="interactions-continuous-and-categorical" class="section level3">
<h3><span class="header-section-number">23.4.2</span> Interactions (continuous and categorical)</h3>
<p>What happens when you combine a continuous and a categorical variable? <code>sim3</code> contains a categorical predictor and a continuous predictor. We can visualise it with a simple plot:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim3, <span class="kw">aes</span>(x1, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> x2))</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are two possible models you could fit to this data:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2, <span class="dt">data =</span> sim3)
mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x2, <span class="dt">data =</span> sim3)</code></pre>
<p>When you add variables with <code>+</code>, the model will estimate each effect independent of all the others. It’s possible to fit the so-called interaction by using <code>*</code>. For example, <code>y ~ x1 * x2</code> is translated to <code>y = a_0 + a_1 * x1 + a_2 * x2 + a_12 * x1 * x2</code>. Note that whenever you use <code>*</code>, both the interaction and the individual components are included in the model.</p>
<p>To visualise these models we need two new tricks:</p>
<ol style="list-style-type: decimal">
<li><p>We have two predictors, so we need to give <code>data_grid()</code> both variables.
It finds all the unique values of <code>x1</code> and <code>x2</code> and then generates all
combinations.</p></li>
<li><p>To generate predictions from both models simultaneously, we can use
<code>gather_predictions()</code> which adds each prediction as a row. The
complement of <code>gather_predictions()</code> is <code>spread_predictions()</code> which adds
each prediction to a new column.</p></li>
</ol>
<p>Together this gives us:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>sim3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(x1, x2) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather_predictions</span>(mod1, mod2)
grid
<span class="co">#&gt; # A tibble: 80 x 4</span>
<span class="co">#&gt;   model    x1 x2     pred</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;int&gt; &lt;fct&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mod1      1 a      1.67</span>
<span class="co">#&gt; 2 mod1      1 b      4.56</span>
<span class="co">#&gt; 3 mod1      1 c      6.48</span>
<span class="co">#&gt; 4 mod1      1 d      4.03</span>
<span class="co">#&gt; 5 mod1      2 a      1.48</span>
<span class="co">#&gt; 6 mod1      2 b      4.37</span>
<span class="co">#&gt; # … with 74 more rows</span></code></pre>
<p>We can visualise the results for both models on one plot using facetting:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(sim3, <span class="kw">aes</span>(x1, y, <span class="dt">colour =</span> x2)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">data =</span> grid, <span class="kw">aes</span>(<span class="dt">y =</span> pred)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>model)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note that the model that uses <code>+</code> has the same slope for each line, but different intercepts. The model that uses <code>*</code> has a different slope and intercept for each line.</p>
<p>Which model is better for this data? We can take look at the residuals. Here I’ve facetted by both model and <code>x2</code> because it makes it easier to see the pattern within each group.</p>
<pre class="sourceCode r"><code class="sourceCode r">sim3 &lt;-<span class="st"> </span>sim3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather_residuals</span>(mod1, mod2)

<span class="kw">ggplot</span>(sim3, <span class="kw">aes</span>(x1, resid, <span class="dt">colour =</span> x2)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_grid</span>(model <span class="op">~</span><span class="st"> </span>x2)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There is little obvious pattern in the residuals for <code>mod2</code>. The residuals for <code>mod1</code> show that the model has clearly missed some pattern in <code>b</code>, and less so, but still present is pattern in <code>c</code>, and <code>d</code>. You might wonder if there’s a precise way to tell which of <code>mod1</code> or <code>mod2</code> is better. There is, but it requires a lot of mathematical background, and we don’t really care. Here, we’re interested in a qualitative assessment of whether or not the model has captured the pattern that we’re interested in.</p>
</div>
<div id="interactions-two-continuous" class="section level3">
<h3><span class="header-section-number">23.4.3</span> Interactions (two continuous)</h3>
<p>Let’s take a look at the equivalent model for two continuous variables. Initially things proceed almost identically to the previous example:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2, <span class="dt">data =</span> sim4)
mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x2, <span class="dt">data =</span> sim4)

grid &lt;-<span class="st"> </span>sim4 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(
    <span class="dt">x1 =</span> <span class="kw">seq_range</span>(x1, <span class="dv">5</span>), 
    <span class="dt">x2 =</span> <span class="kw">seq_range</span>(x2, <span class="dv">5</span>) 
  ) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather_predictions</span>(mod1, mod2)
grid
<span class="co">#&gt; # A tibble: 50 x 4</span>
<span class="co">#&gt;   model    x1    x2   pred</span>
<span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;</span>
<span class="co">#&gt; 1 mod1   -1    -1    0.996</span>
<span class="co">#&gt; 2 mod1   -1    -0.5 -0.395</span>
<span class="co">#&gt; 3 mod1   -1     0   -1.79 </span>
<span class="co">#&gt; 4 mod1   -1     0.5 -3.18 </span>
<span class="co">#&gt; 5 mod1   -1     1   -4.57 </span>
<span class="co">#&gt; 6 mod1   -0.5  -1    1.91 </span>
<span class="co">#&gt; # … with 44 more rows</span></code></pre>
<p>Note my use of <code>seq_range()</code> inside <code>data_grid()</code>. Instead of using every unique value of <code>x</code>, I’m going to use a regularly spaced grid of five values between the minimum and maximum numbers. It’s probably not super important here, but it’s a useful technique in general. There are two other useful arguments to <code>seq_range()</code>:</p>
<ul>
<li><p><code>pretty = TRUE</code> will generate a “pretty” sequence, i.e. something that looks
nice to the human eye. This is useful if you want to produce tables of
output:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">seq_range</span>(<span class="kw">c</span>(<span class="fl">0.0123</span>, <span class="fl">0.923423</span>), <span class="dt">n =</span> <span class="dv">5</span>)
<span class="co">#&gt; [1] 0.0123 0.2401 0.4679 0.6956 0.9234</span>
<span class="kw">seq_range</span>(<span class="kw">c</span>(<span class="fl">0.0123</span>, <span class="fl">0.923423</span>), <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">pretty =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; [1] 0.0 0.2 0.4 0.6 0.8 1.0</span></code></pre></li>
<li><p><code>trim = 0.1</code> will trim off 10% of the tail values. This is useful if the
variables have a long tailed distribution and you want to focus on generating
values near the center:</p>
<pre class="sourceCode r"><code class="sourceCode r">x1 &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">100</span>)
<span class="kw">seq_range</span>(x1, <span class="dt">n =</span> <span class="dv">5</span>)
<span class="co">#&gt; [1] -115.9  -83.5  -51.2  -18.8   13.5</span>
<span class="kw">seq_range</span>(x1, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">trim =</span> <span class="fl">0.10</span>)
<span class="co">#&gt; [1] -13.84  -8.71  -3.58   1.55   6.68</span>
<span class="kw">seq_range</span>(x1, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">trim =</span> <span class="fl">0.25</span>)
<span class="co">#&gt; [1] -2.1735 -1.0594  0.0547  1.1687  2.2828</span>
<span class="kw">seq_range</span>(x1, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">trim =</span> <span class="fl">0.50</span>)
<span class="co">#&gt; [1] -0.725 -0.268  0.189  0.647  1.104</span></code></pre></li>
<li><p><code>expand = 0.1</code> is in some sense the opposite of <code>trim()</code> it expands the
range by 10%.</p>
<pre class="sourceCode r"><code class="sourceCode r">x2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>)
<span class="kw">seq_range</span>(x2, <span class="dt">n =</span> <span class="dv">5</span>)
<span class="co">#&gt; [1] 0.00 0.25 0.50 0.75 1.00</span>
<span class="kw">seq_range</span>(x2, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">expand =</span> <span class="fl">0.10</span>)
<span class="co">#&gt; [1] -0.050  0.225  0.500  0.775  1.050</span>
<span class="kw">seq_range</span>(x2, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">expand =</span> <span class="fl">0.25</span>)
<span class="co">#&gt; [1] -0.125  0.188  0.500  0.812  1.125</span>
<span class="kw">seq_range</span>(x2, <span class="dt">n =</span> <span class="dv">5</span>, <span class="dt">expand =</span> <span class="fl">0.50</span>)
<span class="co">#&gt; [1] -0.250  0.125  0.500  0.875  1.250</span></code></pre></li>
</ul>
<p>Next let’s try and visualise that model. We have two continuous predictors, so you can imagine the model like a 3d surface. We could display that using <code>geom_tile()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(grid, <span class="kw">aes</span>(x1, x2)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_tile</span>(<span class="kw">aes</span>(<span class="dt">fill =</span> pred)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>model)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>That doesn’t suggest that the models are very different! But that’s partly an illusion: our eyes and brains are not very good at accurately comparing shades of colour. Instead of looking at the surface from the top, we could look at it from either side, showing multiple slices:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(grid, <span class="kw">aes</span>(x1, pred, <span class="dt">colour =</span> x2, <span class="dt">group =</span> x2)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>model)
<span class="kw">ggplot</span>(grid, <span class="kw">aes</span>(x2, pred, <span class="dt">colour =</span> x1, <span class="dt">group =</span> x1)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>model)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" /><img src="model-basics_files/figure-html/unnamed-chunk-41-2.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This shows you that interaction between two continuous variables works basically the same way as for a categorical and continuous variable. An interaction says that there’s not a fixed offset: you need to consider both values of <code>x1</code> and <code>x2</code> simultaneously in order to predict <code>y</code>.</p>
<p>You can see that even with just two continuous variables, coming up with good visualisations are hard. But that’s reasonable: you shouldn’t expect it will be easy to understand how three or more variables simultaneously interact! But again, we’re saved a little because we’re using models for exploration, and you can gradually build up your model over time. The model doesn’t have to be perfect, it just has to help you reveal a little more about your data.</p>
<p>I spent some time looking at the residuals to see if I could figure if <code>mod2</code> did better than <code>mod1</code>. I think it does, but it’s pretty subtle. You’ll have a chance to work on it in the exercises.</p>
</div>
<div id="transformations" class="section level3">
<h3><span class="header-section-number">23.4.4</span> Transformations</h3>
<p>You can also perform transformations inside the model formula. For example, <code>log(y) ~ sqrt(x1) + x2</code> is transformed to <code>log(y) = a_1 + a_2 * sqrt(x1) + a_3 * x2</code>. If your transformation involves <code>+</code>, <code>*</code>, <code>^</code>, or <code>-</code>, you’ll need to wrap it in <code>I()</code> so R doesn’t treat it like part of the model specification. For example, <code>y ~ x + I(x ^ 2)</code> is translated to <code>y = a_1 + a_2 * x + a_3 * x^2</code>. If you forget the <code>I()</code> and specify <code>y ~ x ^ 2 + x</code>, R will compute <code>y ~ x * x + x</code>. <code>x * x</code> means the interaction of <code>x</code> with itself, which is the same as <code>x</code>. R automatically drops redundant variables so <code>x + x</code> become <code>x</code>, meaning that <code>y ~ x ^ 2 + x</code> specifies the function <code>y = a_1 + a_2 * x</code>. That’s probably not what you intended!</p>
<p>Again, if you get confused about what your model is doing, you can always use <code>model_matrix()</code> to see exactly what equation <code>lm()</code> is fitting:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>y, <span class="op">~</span>x,
   <span class="dv">1</span>,  <span class="dv">1</span>,
   <span class="dv">2</span>,  <span class="dv">2</span>, 
   <span class="dv">3</span>,  <span class="dv">3</span>
)
<span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span>x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>x)
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   `(Intercept)`     x</span>
<span class="co">#&gt;           &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1     1</span>
<span class="co">#&gt; 2             1     2</span>
<span class="co">#&gt; 3             1     3</span>
<span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span><span class="kw">I</span>(x<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span>x)
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   `(Intercept)` `I(x^2)`     x</span>
<span class="co">#&gt;           &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1        1     1</span>
<span class="co">#&gt; 2             1        4     2</span>
<span class="co">#&gt; 3             1        9     3</span></code></pre>
<p>Transformations are useful because you can use them to approximate non-linear functions. If you’ve taken a calculus class, you may have heard of Taylor’s theorem which says you can approximate any smooth function with an infinite sum of polynomials. That means you can use a polynomial function to get arbitrarily close to a smooth function by fitting an equation like <code>y = a_1 + a_2 * x + a_3 * x^2 + a_4 * x ^ 3</code>. Typing that sequence by hand is tedious, so R provides a helper function: <code>poly()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span><span class="kw">poly</span>(x, <span class="dv">2</span>))
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   `(Intercept)` `poly(x, 2)1` `poly(x, 2)2`</span>
<span class="co">#&gt;           &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1     -7.07e- 1         0.408</span>
<span class="co">#&gt; 2             1     -7.85e-17        -0.816</span>
<span class="co">#&gt; 3             1      7.07e- 1         0.408</span></code></pre>
<p>However there’s one major problem with using <code>poly()</code>: outside the range of the data, polynomials rapidly shoot off to positive or negative infinity. One safer alternative is to use the natural spline, <code>splines::ns()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(splines)
<span class="kw">model_matrix</span>(df, y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">2</span>))
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   `(Intercept)` `ns(x, 2)1` `ns(x, 2)2`</span>
<span class="co">#&gt;           &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span>
<span class="co">#&gt; 1             1       0           0    </span>
<span class="co">#&gt; 2             1       0.566      -0.211</span>
<span class="co">#&gt; 3             1       0.344       0.771</span></code></pre>
<p>Let’s see what that looks like when we try and approximate a non-linear function:</p>
<pre class="sourceCode r"><code class="sourceCode r">sim5 &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="fl">3.5</span> <span class="op">*</span><span class="st"> </span>pi, <span class="dt">length =</span> <span class="dv">50</span>),
  <span class="dt">y =</span> <span class="dv">4</span> <span class="op">*</span><span class="st"> </span><span class="kw">sin</span>(x) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(x))
)

<span class="kw">ggplot</span>(sim5, <span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-45-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>I’m going to fit five models to this data.</p>
<pre class="sourceCode r"><code class="sourceCode r">mod1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">1</span>), <span class="dt">data =</span> sim5)
mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">2</span>), <span class="dt">data =</span> sim5)
mod3 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">3</span>), <span class="dt">data =</span> sim5)
mod4 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">4</span>), <span class="dt">data =</span> sim5)
mod5 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span><span class="kw">ns</span>(x, <span class="dv">5</span>), <span class="dt">data =</span> sim5)

grid &lt;-<span class="st"> </span>sim5 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(<span class="dt">x =</span> <span class="kw">seq_range</span>(x, <span class="dt">n =</span> <span class="dv">50</span>, <span class="dt">expand =</span> <span class="fl">0.1</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather_predictions</span>(mod1, mod2, mod3, mod4, mod5, <span class="dt">.pred =</span> <span class="st">&quot;y&quot;</span>)

<span class="kw">ggplot</span>(sim5, <span class="kw">aes</span>(x, y)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">data =</span> grid, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>model)</code></pre>
<p><img src="model-basics_files/figure-html/unnamed-chunk-46-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Notice that the extrapolation outside the range of the data is clearly bad. This is the downside to approximating a function with a polynomial. But this is a very real problem with every model: the model can never tell you if the behaviour is true when you start extrapolating outside the range of the data that you have seen. You must rely on theory and science.</p>
</div>
<div id="exercises-62" class="section level3">
<h3><span class="header-section-number">23.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What happens if you repeat the analysis of <code>sim2</code> using a model without
an intercept. What happens to the model equation? What happens to the
predictions?</p></li>
<li><p>Use <code>model_matrix()</code> to explore the equations generated for the models
I fit to <code>sim3</code> and <code>sim4</code>. Why is <code>*</code> a good shorthand for interaction?</p></li>
<li><p>Using the basic principles, convert the formulas in the following two
models into functions. (Hint: start by converting the categorical variable
into 0-1 variables.)</p>
<pre class="sourceCode r"><code class="sourceCode r">mod1 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2, <span class="dt">data =</span> sim3)
mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">*</span><span class="st"> </span>x2, <span class="dt">data =</span> sim3)</code></pre></li>
<li><p>For <code>sim4</code>, which of <code>mod1</code> and <code>mod2</code> is better? I think <code>mod2</code> does a
slightly better job at removing patterns, but it’s pretty subtle. Can you
come up with a plot to support my claim?</p></li>
</ol>
</div>
</div>
<div id="missing-values-5" class="section level2">
<h2><span class="header-section-number">23.5</span> Missing values</h2>
<p>Missing values obviously can not convey any information about the relationship between the variables, so modelling functions will drop any rows that contain missing values. R’s default behaviour is to silently drop them, but <code>options(na.action = na.warn)</code> (run in the prerequisites), makes sure you get a warning.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y,
  <span class="dv">1</span>, <span class="fl">2.2</span>,
  <span class="dv">2</span>, <span class="ot">NA</span>,
  <span class="dv">3</span>, <span class="fl">3.5</span>,
  <span class="dv">4</span>, <span class="fl">8.3</span>,
  <span class="ot">NA</span>, <span class="dv">10</span>
)

mod &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> df)
<span class="co">#&gt; Warning: Dropping 2 rows with missing values</span></code></pre>
<p>To suppress the warning, set <code>na.action = na.exclude</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, <span class="dt">data =</span> df, <span class="dt">na.action =</span> na.exclude)</code></pre>
<p>You can always see exactly how many observations were used with <code>nobs()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nobs</span>(mod)
<span class="co">#&gt; [1] 3</span></code></pre>
</div>
<div id="other-model-families" class="section level2">
<h2><span class="header-section-number">23.6</span> Other model families</h2>
<p>This chapter has focussed exclusively on the class of linear models, which assume a relationship of the form <code>y = a_1 * x1 + a_2 * x2 + ... + a_n * xn</code>. Linear models additionally assume that the residuals have a normal distribution, which we haven’t talked about. There are a large set of model classes that extend the linear model in various interesting ways. Some of them are:</p>
<ul>
<li><p><strong>Generalised linear models</strong>, e.g. <code>stats::glm()</code>. Linear models assume that
the response is continuous and the error has a normal distribution.
Generalised linear models extend linear models to include non-continuous
responses (e.g. binary data or counts). They work by defining a distance
metric based on the statistical idea of likelihood.</p></li>
<li><p><strong>Generalised additive models</strong>, e.g. <code>mgcv::gam()</code>, extend generalised
linear models to incorporate arbitrary smooth functions. That means you can
write a formula like <code>y ~ s(x)</code> which becomes an equation like
<code>y = f(x)</code> and let <code>gam()</code> estimate what that function is (subject to some
smoothness constraints to make the problem tractable).</p></li>
<li><p><strong>Penalised linear models</strong>, e.g. <code>glmnet::glmnet()</code>, add a penalty term to
the distance that penalises complex models (as defined by the distance
between the parameter vector and the origin). This tends to make
models that generalise better to new datasets from the same population.</p></li>
<li><p><strong>Robust linear models</strong>, e.g. <code>MASS:rlm()</code>, tweak the distance to downweight
points that are very far away. This makes them less sensitive to the presence
of outliers, at the cost of being not quite as good when there are no
outliers.</p></li>
<li><p><strong>Trees</strong>, e.g. <code>rpart::rpart()</code>, attack the problem in a completely different
way than linear models. They fit a piece-wise constant model, splitting the
data into progressively smaller and smaller pieces. Trees aren’t terribly
effective by themselves, but they are very powerful when used in aggregate
by models like <strong>random forests</strong> (e.g. <code>randomForest::randomForest()</code>) or
<strong>gradient boosting machines</strong> (e.g. <code>xgboost::xgboost</code>.)</p></li>
</ul>
<p>These models all work similarly from a programming perspective. Once you’ve mastered linear models, you should find it easy to master the mechanics of these other model classes. Being a skilled modeller is a mixture of some good general principles and having a big toolbox of techniques. Now that you’ve learned some general tools and one useful class of models, you can go on and learn more classes from other sources.</p>
<!--chapter:end:model-basics.Rmd-->
</div>
</div>
<div id="model-building" class="section level1">
<h1><span class="header-section-number">24</span> Model building</h1>
<div id="introduction-16" class="section level2">
<h2><span class="header-section-number">24.1</span> Introduction</h2>
<p>In the previous chapter you learned how linear models work, and learned some basic tools for understanding what a model is telling you about your data. The previous chapter focussed on simulated datasets. This chapter will focus on real data, showing you how you can progressively build up a model to aid your understanding of the data.</p>
<p>We will take advantage of the fact that you can think about a model partitioning your data into pattern and residuals. We’ll find patterns with visualisation, then make them concrete and precise with a model. We’ll then repeat the process, but replace the old response variable with the residuals from the model. The goal is to transition from implicit knowledge in the data and your head to explicit knowledge in a quantitative model. This makes it easier to apply to new domains, and easier for others to use.</p>
<p>For very large and complex datasets this will be a lot of work. There are certainly alternative approaches - a more machine learning approach is simply to focus on the predictive ability of the model. These approaches tend to produce black boxes: the model does a really good job at generating predictions, but you don’t know why. This is a totally reasonable approach, but it does make it hard to apply your real world knowledge to the model. That, in turn, makes it difficult to assess whether or not the model will continue to work in the long-term, as fundamentals change. For most real models, I’d expect you to use some combination of this approach and a more classic automated approach.</p>
<p>It’s a challenge to know when to stop. You need to figure out when your model is good enough, and when additional investment is unlikely to pay off. I particularly like this quote from reddit user Broseidon241:</p>
<blockquote>
<p>A long time ago in art class, my teacher told me “An artist needs to know
when a piece is done. You can’t tweak something into perfection - wrap it up.
If you don’t like it, do it over again. Otherwise begin something new”. Later
in life, I heard “A poor seamstress makes many mistakes. A good seamstress
works hard to correct those mistakes. A great seamstress isn’t afraid to
throw out the garment and start over.”</p>
<p>– Broseidon241, <a href="https://www.reddit.com/r/datascience/comments/4irajq" class="uri">https://www.reddit.com/r/datascience/comments/4irajq</a></p>
</blockquote>
<div id="prerequisites-16" class="section level3">
<h3><span class="header-section-number">24.1.1</span> Prerequisites</h3>
<p>We’ll use the same tools as in the previous chapter, but add in some real datasets: <code>diamonds</code> from ggplot2, and <code>flights</code> from nycflights13. We’ll also need lubridate in order to work with the date/times in <code>flights</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(modelr)
<span class="kw">options</span>(<span class="dt">na.action =</span> na.warn)

<span class="kw">library</span>(nycflights13)
<span class="kw">library</span>(lubridate)</code></pre>
</div>
</div>
<div id="diamond-prices" class="section level2">
<h2><span class="header-section-number">24.2</span> Why are low quality diamonds more expensive?</h2>
<p>In previous chapters we’ve seen a surprising relationship between the quality of diamonds and their price: low quality diamonds (poor cuts, bad colours, and inferior clarity) have higher prices.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(cut, price)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()
<span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(color, price)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()
<span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(clarity, price)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" /><img src="model-building_files/figure-html/unnamed-chunk-2-2.png" width="70%" style="display: block; margin: auto;" /><img src="model-building_files/figure-html/unnamed-chunk-2-3.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note that the worst diamond color is J (slightly yellow), and the worst clarity is I1 (inclusions visible to the naked eye).</p>
<div id="price-and-carat" class="section level3">
<h3><span class="header-section-number">24.2.1</span> Price and carat</h3>
<p>It looks like lower quality diamonds have higher prices because there is an important confounding variable: the weight (<code>carat</code>) of the diamond. The weight of the diamond is the single most important factor for determining the price of the diamond, and lower quality diamonds tend to be larger.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(carat, price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">bins =</span> <span class="dv">50</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We can make it easier to see how the other attributes of a diamond affect its relative <code>price</code> by fitting a model to separate out the effect of <code>carat</code>. But first, lets make a couple of tweaks to the diamonds dataset to make it easier to work with:</p>
<ol style="list-style-type: decimal">
<li>Focus on diamonds smaller than 2.5 carats (99.7% of the data)</li>
<li>Log-transform the carat and price variables.</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 &lt;-<span class="st"> </span>diamonds <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(carat <span class="op">&lt;=</span><span class="st"> </span><span class="fl">2.5</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">lprice =</span> <span class="kw">log2</span>(price), <span class="dt">lcarat =</span> <span class="kw">log2</span>(carat))</code></pre>
<p>Together, these changes make it easier to see the relationship between <code>carat</code> and <code>price</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(lcarat, lprice)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">bins =</span> <span class="dv">50</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-5-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The log-transformation is particularly useful here because it makes the pattern linear, and linear patterns are the easiest to work with. Let’s take the next step and remove that strong linear pattern. We first make the pattern explicit by fitting a model:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod_diamond &lt;-<span class="st"> </span><span class="kw">lm</span>(lprice <span class="op">~</span><span class="st"> </span>lcarat, <span class="dt">data =</span> diamonds2)</code></pre>
<p>Then we look at what the model tells us about the data. Note that I back transform the predictions, undoing the log transformation, so I can overlay the predictions on the raw data:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>diamonds2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(<span class="dt">carat =</span> <span class="kw">seq_range</span>(carat, <span class="dv">20</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">lcarat =</span> <span class="kw">log2</span>(carat)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod_diamond, <span class="st">&quot;lprice&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">price =</span> <span class="dv">2</span> <span class="op">^</span><span class="st"> </span>lprice)

<span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(carat, price)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">bins =</span> <span class="dv">50</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">data =</span> grid, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">size =</span> <span class="dv">1</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>That tells us something interesting about our data. If we believe our model, then the large diamonds are much cheaper than expected. This is probably because no diamond in this dataset costs more than $19,000.</p>
<p>Now we can look at the residuals, which verifies that we’ve successfully removed the strong linear pattern:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 &lt;-<span class="st"> </span>diamonds2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(mod_diamond, <span class="st">&quot;lresid&quot;</span>)

<span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(lcarat, lresid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">bins =</span> <span class="dv">50</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Importantly, we can now re-do our motivating plots using those residuals instead of <code>price</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(cut, lresid)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()
<span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(color, lresid)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()
<span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(clarity, lresid)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /><img src="model-building_files/figure-html/unnamed-chunk-9-2.png" width="70%" style="display: block; margin: auto;" /><img src="model-building_files/figure-html/unnamed-chunk-9-3.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Now we see the relationship we expect: as the quality of the diamond increases, so too does its relative price. To interpret the <code>y</code> axis, we need to think about what the residuals are telling us, and what scale they are on. A residual of -1 indicates that <code>lprice</code> was 1 unit lower than a prediction based solely on its weight. <span class="math inline">\(2^{-1}\)</span> is 1/2, points with a value of -1 are half the expected price, and residuals with value 1 are twice the predicted price.</p>
</div>
<div id="a-more-complicated-model" class="section level3">
<h3><span class="header-section-number">24.2.2</span> A more complicated model</h3>
<p>If we wanted to, we could continue to build up our model, moving the effects we’ve observed into the model to make them explicit. For example, we could include <code>color</code>, <code>cut</code>, and <code>clarity</code> into the model so that we also make explicit the effect of these three categorical variables:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod_diamond2 &lt;-<span class="st"> </span><span class="kw">lm</span>(lprice <span class="op">~</span><span class="st"> </span>lcarat <span class="op">+</span><span class="st"> </span>color <span class="op">+</span><span class="st"> </span>cut <span class="op">+</span><span class="st"> </span>clarity, <span class="dt">data =</span> diamonds2)</code></pre>
<p>This model now includes four predictors, so it’s getting harder to visualise. Fortunately, they’re currently all independent which means that we can plot them individually in four plots. To make the process a little easier, we’re going to use the <code>.model</code> argument to <code>data_grid</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>diamonds2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(cut, <span class="dt">.model =</span> mod_diamond2) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod_diamond2)
grid
<span class="co">#&gt; # A tibble: 5 x 5</span>
<span class="co">#&gt;   cut       lcarat color clarity  pred</span>
<span class="co">#&gt;   &lt;ord&gt;      &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Fair      -0.515 G     VS2      11.2</span>
<span class="co">#&gt; 2 Good      -0.515 G     VS2      11.3</span>
<span class="co">#&gt; 3 Very Good -0.515 G     VS2      11.4</span>
<span class="co">#&gt; 4 Premium   -0.515 G     VS2      11.4</span>
<span class="co">#&gt; 5 Ideal     -0.515 G     VS2      11.4</span>

<span class="kw">ggplot</span>(grid, <span class="kw">aes</span>(cut, pred)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If the model needs variables that you haven’t explicitly supplied, <code>data_grid()</code> will automatically fill them in with “typical” value. For continuous variables, it uses the median, and categorical variables it uses the most common value (or values, if there’s a tie).</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 &lt;-<span class="st"> </span>diamonds2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(mod_diamond2, <span class="st">&quot;lresid2&quot;</span>)

<span class="kw">ggplot</span>(diamonds2, <span class="kw">aes</span>(lcarat, lresid2)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hex</span>(<span class="dt">bins =</span> <span class="dv">50</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This plot indicates that there are some diamonds with quite large residuals - remember a residual of 2 indicates that the diamond is 4x the price that we expected. It’s often useful to look at unusual values individually:</p>
<pre class="sourceCode r"><code class="sourceCode r">diamonds2 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">abs</span>(lresid2) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod_diamond2) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pred =</span> <span class="kw">round</span>(<span class="dv">2</span> <span class="op">^</span><span class="st"> </span>pred)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(price, pred, carat<span class="op">:</span>table, x<span class="op">:</span>z) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(price)
<span class="co">#&gt; # A tibble: 16 x 11</span>
<span class="co">#&gt;   price  pred carat cut     color clarity depth table     x     y     z</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt;   &lt;ord&gt; &lt;ord&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1  1013   264  0.25 Fair    F     SI2      54.4    64  4.3   4.23  2.32</span>
<span class="co">#&gt; 2  1186   284  0.25 Premium G     SI2      59      60  5.33  5.28  3.12</span>
<span class="co">#&gt; 3  1186   284  0.25 Premium G     SI2      58.8    60  5.33  5.28  3.12</span>
<span class="co">#&gt; 4  1262  2644  1.03 Fair    E     I1       78.2    54  5.72  5.59  4.42</span>
<span class="co">#&gt; 5  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66</span>
<span class="co">#&gt; 6  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66</span>
<span class="co">#&gt; # … with 10 more rows</span></code></pre>
<p>Nothing really jumps out at me here, but it’s probably worth spending time considering if this indicates a problem with our model, or if there are errors in the data. If there are mistakes in the data, this could be an opportunity to buy diamonds that have been priced low incorrectly.</p>
</div>
<div id="exercises-63" class="section level3">
<h3><span class="header-section-number">24.2.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In the plot of <code>lcarat</code> vs. <code>lprice</code>, there are some bright vertical
strips. What do they represent?</p></li>
<li><p>If <code>log(price) = a_0 + a_1 * log(carat)</code>, what does that say about
the relationship between <code>price</code> and <code>carat</code>?</p></li>
<li><p>Extract the diamonds that have very high and very low residuals.
Is there anything unusual about these diamonds? Are they particularly bad
or good, or do you think these are pricing errors?</p></li>
<li><p>Does the final model, <code>mod_diamond2</code>, do a good job of predicting
diamond prices? Would you trust it to tell you how much to spend
if you were buying a diamond?</p></li>
</ol>
</div>
</div>
<div id="what-affects-the-number-of-daily-flights" class="section level2">
<h2><span class="header-section-number">24.3</span> What affects the number of daily flights?</h2>
<p>Let’s work through a similar process for a dataset that seems even simpler at first glance: the number of flights that leave NYC per day. This is a really small dataset — only 365 rows and 2 columns — and we’re not going to end up with a fully realised model, but as you’ll see, the steps along the way will help us better understand the data. Let’s get started by counting the number of flights per day and visualising it with ggplot2.</p>
<pre class="sourceCode r"><code class="sourceCode r">daily &lt;-<span class="st"> </span>flights <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">date =</span> <span class="kw">make_date</span>(year, month, day)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(date) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">n =</span> <span class="kw">n</span>())
daily
<span class="co">#&gt; # A tibble: 365 x 2</span>
<span class="co">#&gt;   date           n</span>
<span class="co">#&gt;   &lt;date&gt;     &lt;int&gt;</span>
<span class="co">#&gt; 1 2013-01-01   842</span>
<span class="co">#&gt; 2 2013-01-02   943</span>
<span class="co">#&gt; 3 2013-01-03   914</span>
<span class="co">#&gt; 4 2013-01-04   915</span>
<span class="co">#&gt; 5 2013-01-05   720</span>
<span class="co">#&gt; 6 2013-01-06   832</span>
<span class="co">#&gt; # … with 359 more rows</span>

<span class="kw">ggplot</span>(daily, <span class="kw">aes</span>(date, n)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" /></p>
<div id="day-of-week" class="section level3">
<h3><span class="header-section-number">24.3.1</span> Day of week</h3>
<p>Understanding the long-term trend is challenging because there’s a very strong day-of-week effect that dominates the subtler patterns. Let’s start by looking at the distribution of flight numbers by day-of-week:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily &lt;-<span class="st"> </span>daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">wday =</span> <span class="kw">wday</span>(date, <span class="dt">label =</span> <span class="ot">TRUE</span>))
<span class="kw">ggplot</span>(daily, <span class="kw">aes</span>(wday, n)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are fewer flights on weekends because most travel is for business. The effect is particularly pronounced on Saturday: you might sometimes leave on Sunday for a Monday morning meeting, but it’s very rare that you’d leave on Saturday as you’d much rather be at home with your family.</p>
<p>One way to remove this strong pattern is to use a model. First, we fit the model, and display its predictions overlaid on the original data:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod &lt;-<span class="st"> </span><span class="kw">lm</span>(n <span class="op">~</span><span class="st"> </span>wday, <span class="dt">data =</span> daily)

grid &lt;-<span class="st"> </span>daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(wday) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod, <span class="st">&quot;n&quot;</span>)

<span class="kw">ggplot</span>(daily, <span class="kw">aes</span>(wday, n)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> grid, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">size =</span> <span class="dv">4</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Next we compute and visualise the residuals:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily &lt;-<span class="st"> </span>daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(mod)
daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_ref_line</span>(<span class="dt">h =</span> <span class="dv">0</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note the change in the y-axis: now we are seeing the deviation from the expected number of flights, given the day of week. This plot is useful because now that we’ve removed much of the large day-of-week effect, we can see some of the subtler patterns that remain:</p>
<ol style="list-style-type: decimal">
<li><p>Our model seems to fail starting in June: you can still see a strong
regular pattern that our model hasn’t captured. Drawing a plot with one
line for each day of the week makes the cause easier to see:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(daily, <span class="kw">aes</span>(date, resid, <span class="dt">colour =</span> wday)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_ref_line</span>(<span class="dt">h =</span> <span class="dv">0</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Our model fails to accurately predict the number of flights on Saturday:
during summer there are more flights than we expect, and during Fall there
are fewer. We’ll see how we can do better to capture this pattern in the
next section.</p></li>
<li><p>There are some days with far fewer flights than expected:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(resid <span class="op">&lt;</span><span class="st"> </span><span class="dv">-100</span>)
<span class="co">#&gt; # A tibble: 11 x 4</span>
<span class="co">#&gt;   date           n wday  resid</span>
<span class="co">#&gt;   &lt;date&gt;     &lt;int&gt; &lt;ord&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 2013-01-01   842 Tue   -109.</span>
<span class="co">#&gt; 2 2013-01-20   786 Sun   -105.</span>
<span class="co">#&gt; 3 2013-05-26   729 Sun   -162.</span>
<span class="co">#&gt; 4 2013-07-04   737 Thu   -229.</span>
<span class="co">#&gt; 5 2013-07-05   822 Fri   -145.</span>
<span class="co">#&gt; 6 2013-09-01   718 Sun   -173.</span>
<span class="co">#&gt; # … with 5 more rows</span></code></pre>
<p>If you’re familiar with American public holidays, you might spot New Year’s
day, July 4th, Thanksgiving and Christmas. There are some others that don’t
seem to correspond to public holidays. You’ll work on those in one
of the exercises.</p></li>
<li><p>There seems to be some smoother long term trend over the course of a year.
We can highlight that trend with <code>geom_smooth()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_ref_line</span>(<span class="dt">h =</span> <span class="dv">0</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="dt">colour =</span> <span class="st">&quot;grey50&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">span =</span> <span class="fl">0.20</span>)
<span class="co">#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</span></code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>There are fewer flights in January (and December), and more in summer
(May-Sep). We can’t do much with this pattern quantitatively, because we
only have a single year of data. But we can use our domain knowledge to
brainstorm potential explanations.</p></li>
</ol>
</div>
<div id="seasonal-saturday-effect" class="section level3">
<h3><span class="header-section-number">24.3.2</span> Seasonal Saturday effect</h3>
<p>Let’s first tackle our failure to accurately predict the number of flights on Saturday. A good place to start is to go back to the raw numbers, focussing on Saturdays:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(wday <span class="op">==</span><span class="st"> &quot;Sat&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, n)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_x_date</span>(<span class="ot">NULL</span>, <span class="dt">date_breaks =</span> <span class="st">&quot;1 month&quot;</span>, <span class="dt">date_labels =</span> <span class="st">&quot;%b&quot;</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(I’ve used both points and lines to make it more clear what is data and what is interpolation.)</p>
<p>I suspect this pattern is caused by summer holidays: many people go on holiday in the summer, and people don’t mind travelling on Saturdays for vacation. Looking at this plot, we might guess that summer holidays are from early June to late August. That seems to line up fairly well with the state’s school terms<span id="fn26" class="footnote" data-pagedown-footnote-number="26" style="white-space: pre-line;"><a href="http://schools.nyc.gov/Calendar/2013-2014+School+Year+Calendars.htm" class="uri">http://schools.nyc.gov/Calendar/2013-2014+School+Year+Calendars.htm</a></span>: summer break in 2013 was Jun 26–Sep 9.</p>
<p>Why are there more Saturday flights in the Spring than the Fall? I asked some American friends and they suggested that it’s less common to plan family vacations during the Fall because of the big Thanksgiving and Christmas holidays. We don’t have the data to know for sure, but it seems like a plausible working hypothesis.</p>
<p>Lets create a “term” variable that roughly captures the three school terms, and check our work with a plot:</p>
<pre class="sourceCode r"><code class="sourceCode r">term &lt;-<span class="st"> </span><span class="cf">function</span>(date) {
  <span class="kw">cut</span>(date, 
    <span class="dt">breaks =</span> <span class="kw">ymd</span>(<span class="dv">20130101</span>, <span class="dv">20130605</span>, <span class="dv">20130825</span>, <span class="dv">20140101</span>),
    <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;spring&quot;</span>, <span class="st">&quot;summer&quot;</span>, <span class="st">&quot;fall&quot;</span>) 
  )
}

daily &lt;-<span class="st"> </span>daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">term =</span> <span class="kw">term</span>(date)) 

daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(wday <span class="op">==</span><span class="st"> &quot;Sat&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, n, <span class="dt">colour =</span> term)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_date</span>(<span class="ot">NULL</span>, <span class="dt">date_breaks =</span> <span class="st">&quot;1 month&quot;</span>, <span class="dt">date_labels =</span> <span class="st">&quot;%b&quot;</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>(I manually tweaked the dates to get nice breaks in the plot. Using a visualisation to help you understand what your function is doing is a really powerful and general technique.)</p>
<p>It’s useful to see how this new variable affects the other days of the week:</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(wday, n, <span class="dt">colour =</span> term)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_boxplot</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It looks like there is significant variation across the terms, so fitting a separate day of week effect for each term is reasonable. This improves our model, but not as much as we might hope:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod1 &lt;-<span class="st"> </span><span class="kw">lm</span>(n <span class="op">~</span><span class="st"> </span>wday, <span class="dt">data =</span> daily)
mod2 &lt;-<span class="st"> </span><span class="kw">lm</span>(n <span class="op">~</span><span class="st"> </span>wday <span class="op">*</span><span class="st"> </span>term, <span class="dt">data =</span> daily)

daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather_residuals</span>(<span class="dt">without_term =</span> mod1, <span class="dt">with_term =</span> mod2) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, resid, <span class="dt">colour =</span> model)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="dt">alpha =</span> <span class="fl">0.75</span>)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We can see the problem by overlaying the predictions from the model on to the raw data:</p>
<pre class="sourceCode r"><code class="sourceCode r">grid &lt;-<span class="st"> </span>daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(wday, term) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod2, <span class="st">&quot;n&quot;</span>)

<span class="kw">ggplot</span>(daily, <span class="kw">aes</span>(wday, n)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">data =</span> grid, <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">facet_wrap</span>(<span class="op">~</span><span class="st"> </span>term)</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Our model is finding the <em>mean</em> effect, but we have a lot of big outliers, so mean tends to be far away from the typical value. We can alleviate this problem by using a model that is robust to the effect of outliers: <code>MASS::rlm()</code>. This greatly reduces the impact of the outliers on our estimates, and gives a model that does a good job of removing the day of week pattern:</p>
<pre class="sourceCode r"><code class="sourceCode r">mod3 &lt;-<span class="st"> </span>MASS<span class="op">::</span><span class="kw">rlm</span>(n <span class="op">~</span><span class="st"> </span>wday <span class="op">*</span><span class="st"> </span>term, <span class="dt">data =</span> daily)

daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(mod3, <span class="st">&quot;resid&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">size =</span> <span class="dv">2</span>, <span class="dt">colour =</span> <span class="st">&quot;white&quot;</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It’s now much easier to see the long-term trend, and the positive and negative outliers.</p>
</div>
<div id="computed-variables" class="section level3">
<h3><span class="header-section-number">24.3.3</span> Computed variables</h3>
<p>If you’re experimenting with many models and many visualisations, it’s a good idea to bundle the creation of variables up into a function so there’s no chance of accidentally applying a different transformation in different places. For example, we could write:</p>
<pre class="sourceCode r"><code class="sourceCode r">compute_vars &lt;-<span class="st"> </span><span class="cf">function</span>(data) {
  data <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">mutate</span>(
      <span class="dt">term =</span> <span class="kw">term</span>(date), 
      <span class="dt">wday =</span> <span class="kw">wday</span>(date, <span class="dt">label =</span> <span class="ot">TRUE</span>)
    )
}</code></pre>
<p>Another option is to put the transformations directly in the model formula:</p>
<pre class="sourceCode r"><code class="sourceCode r">wday2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">wday</span>(x, <span class="dt">label =</span> <span class="ot">TRUE</span>)
mod3 &lt;-<span class="st"> </span><span class="kw">lm</span>(n <span class="op">~</span><span class="st"> </span><span class="kw">wday2</span>(date) <span class="op">*</span><span class="st"> </span><span class="kw">term</span>(date), <span class="dt">data =</span> daily)</code></pre>
<p>Either approach is reasonable. Making the transformed variable explicit is useful if you want to check your work, or use them in a visualisation. But you can’t easily use transformations (like splines) that return multiple columns. Including the transformations in the model function makes life a little easier when you’re working with many different datasets because the model is self contained.</p>
</div>
<div id="time-of-year-an-alternative-approach" class="section level3">
<h3><span class="header-section-number">24.3.4</span> Time of year: an alternative approach</h3>
<p>In the previous section we used our domain knowledge (how the US school term affects travel) to improve the model. An alternative to using our knowledge explicitly in the model is to give the data more room to speak. We could use a more flexible model and allow that to capture the pattern we’re interested in. A simple linear trend isn’t adequate, so we could try using a natural spline to fit a smooth curve across the year:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(splines)
mod &lt;-<span class="st"> </span>MASS<span class="op">::</span><span class="kw">rlm</span>(n <span class="op">~</span><span class="st"> </span>wday <span class="op">*</span><span class="st"> </span><span class="kw">ns</span>(date, <span class="dv">5</span>), <span class="dt">data =</span> daily)

daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">data_grid</span>(wday, <span class="dt">date =</span> <span class="kw">seq_range</span>(date, <span class="dt">n =</span> <span class="dv">13</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(mod) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(date, pred, <span class="dt">colour =</span> wday)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="model-building_files/figure-html/unnamed-chunk-29-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We see a strong pattern in the numbers of Saturday flights. This is reassuring, because we also saw that pattern in the raw data. It’s a good sign when you get the same signal from different approaches.</p>
</div>
<div id="exercises-64" class="section level3">
<h3><span class="header-section-number">24.3.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Use your Google sleuthing skills to brainstorm why there were fewer than
expected flights on Jan 20, May 26, and Sep 1. (Hint: they all have the
same explanation.) How would these days generalise to another year?</p></li>
<li><p>What do the three days with high positive residuals represent?
How would these days generalise to another year?</p>
<pre class="sourceCode r"><code class="sourceCode r">daily <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">top_n</span>(<span class="dv">3</span>, resid)
<span class="co">#&gt; # A tibble: 3 x 5</span>
<span class="co">#&gt;   date           n wday  resid term </span>
<span class="co">#&gt;   &lt;date&gt;     &lt;int&gt; &lt;ord&gt; &lt;dbl&gt; &lt;fct&gt;</span>
<span class="co">#&gt; 1 2013-11-30   857 Sat   112.  fall </span>
<span class="co">#&gt; 2 2013-12-01   987 Sun    95.5 fall </span>
<span class="co">#&gt; 3 2013-12-28   814 Sat    69.4 fall</span></code></pre></li>
<li><p>Create a new variable that splits the <code>wday</code> variable into terms, but only
for Saturdays, i.e. it should have <code>Thurs</code>, <code>Fri</code>, but <code>Sat-summer</code>,
<code>Sat-spring</code>, <code>Sat-fall</code>. How does this model compare with the model with
every combination of <code>wday</code> and <code>term</code>?</p></li>
<li><p>Create a new <code>wday</code> variable that combines the day of week, term
(for Saturdays), and public holidays. What do the residuals of
that model look like?</p></li>
<li><p>What happens if you fit a day of week effect that varies by month
(i.e. <code>n ~ wday * month</code>)? Why is this not very helpful?</p></li>
<li><p>What would you expect the model <code>n ~ wday + ns(date, 5)</code> to look like?
Knowing what you know about the data, why would you expect it to be
not particularly effective?</p></li>
<li><p>We hypothesised that people leaving on Sundays are more likely to be
business travellers who need to be somewhere on Monday. Explore that
hypothesis by seeing how it breaks down based on distance and time: if
it’s true, you’d expect to see more Sunday evening flights to places that
are far away.</p></li>
<li><p>It’s a little frustrating that Sunday and Saturday are on separate ends
of the plot. Write a small function to set the levels of the
factor so that the week starts on Monday.</p></li>
</ol>
</div>
</div>
<div id="learning-more-about-models" class="section level2">
<h2><span class="header-section-number">24.4</span> Learning more about models</h2>
<p>We have only scratched the absolute surface of modelling, but you have hopefully gained some simple, but general-purpose tools that you can use to improve your own data analyses. It’s OK to start simple! As you’ve seen, even very simple models can make a dramatic difference in your ability to tease out interactions between variables.</p>
<p>These modelling chapters are even more opinionated than the rest of the book. I approach modelling from a somewhat different perspective to most others, and there is relatively little space devoted to it. Modelling really deserves a book on its own, so I’d highly recommend that you read at least one of these three books:</p>
<ul>
<li><p><em>Statistical Modeling: A Fresh Approach</em> by Danny Kaplan,
<a href="http://www.mosaic-web.org/go/StatisticalModeling/" class="uri">http://www.mosaic-web.org/go/StatisticalModeling/</a>. This book provides
a gentle introduction to modelling, where you build your intuition,
mathematical tools, and R skills in parallel. The book replaces a traditional
“introduction to statistics” course, providing a curriculum that is up-to-date
and relevant to data science.</p></li>
<li><p><em>An Introduction to Statistical Learning</em> by Gareth James, Daniela Witten,
Trevor Hastie, and Robert Tibshirani, <a href="http://www-bcf.usc.edu/~gareth/ISL/" class="uri">http://www-bcf.usc.edu/~gareth/ISL/</a>
(available online for free). This book presents a family of modern modelling
techniques collectively known as statistical learning. For an even deeper
understanding of the math behind the models, read the classic
<em>Elements of Statistical Learning</em> by Trevor Hastie, Robert Tibshirani, and
Jerome Friedman, <a href="https://web.stanford.edu/~hastie/Papers/ESLII.pdf" class="uri">https://web.stanford.edu/~hastie/Papers/ESLII.pdf</a> (also
available online for free).</p></li>
<li><p><em>Applied Predictive Modeling</em> by Max Kuhn and Kjell Johnson,
<a href="http://appliedpredictivemodeling.com" class="uri">http://appliedpredictivemodeling.com</a>. This book is a companion to the
<strong>caret</strong> package and provides practical tools for dealing with real-life
predictive modelling challenges.</p></li>
</ul>
<!--chapter:end:model-building.Rmd-->
</div>
</div>
<div id="many-models" class="section level1">
<h1><span class="header-section-number">25</span> Many models</h1>
<div id="introduction-17" class="section level2">
<h2><span class="header-section-number">25.1</span> Introduction</h2>
<p>In this chapter you’re going to learn three powerful ideas that help you to work with large numbers of models with ease:</p>
<ol style="list-style-type: decimal">
<li><p>Using many simple models to better understand complex datasets.</p></li>
<li><p>Using list-columns to store arbitrary data structures in a data frame.
For example, this will allow you to have a column that contains linear
models.</p></li>
<li><p>Using the <strong>broom</strong> package, by David Robinson, to turn models into tidy
data. This is a powerful technique for working with large numbers of models
because once you have tidy data, you can apply all of the techniques that
you’ve learned about earlier in the book.</p></li>
</ol>
<p>We’ll start by diving into a motivating example using data about life expectancy around the world. It’s a small dataset but it illustrates how important modelling can be for improving your visualisations. We’ll use a large number of simple models to partition out some of the strongest signals so we can see the subtler signals that remain. We’ll also see how model summaries can help us pick out outliers and unusual trends.</p>
<p>The following sections will dive into more detail about the individual techniques:</p>
<ol style="list-style-type: decimal">
<li><p>In <a href="#list-columns-1">list-columns</a>, you’ll learn more about the list-column data structure,
and why it’s valid to put lists in data frames.</p></li>
<li><p>In <a href="#creating-list-columns">creating list-columns</a>, you’ll learn the three main ways in which you’ll
create list-columns.</p></li>
<li><p>In <a href="#simplifying-list-columns">simplifying list-columns</a> you’ll learn how to convert list-columns back
to regular atomic vectors (or sets of atomic vectors) so you can work
with them more easily.</p></li>
<li><p>In <a href="#making-tidy-data-with-broom">making tidy data with broom</a>, you’ll learn about the full set of tools
provided by broom, and see how they can be applied to other types of
data structure.</p></li>
</ol>
<p>This chapter is somewhat aspirational: if this book is your first introduction to R, this chapter is likely to be a struggle. It requires you have to deeply internalised ideas about modelling, data structures, and iteration. So don’t worry if you don’t get it — just put this chapter aside for a few months, and come back when you want to stretch your brain.</p>
<div id="prerequisites-17" class="section level3">
<h3><span class="header-section-number">25.1.1</span> Prerequisites</h3>
<p>Working with many models requires many of the packages of the tidyverse (for data exploration, wrangling, and programming) and modelr to facilitate modelling.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(modelr)
<span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="gapminder" class="section level2">
<h2><span class="header-section-number">25.2</span> gapminder</h2>
<p>To motivate the power of many simple models, we’re going to look into the “gapminder” data. This data was popularised by Hans Rosling, a Swedish doctor and statistician. If you’ve never heard of him, stop reading this chapter right now and go watch one of his videos! He is a fantastic data presenter and illustrates how you can use data to present a compelling story. A good place to start is this short video filmed in conjunction with the BBC: <a href="https://www.youtube.com/watch?v=jbkSRLYSojo" class="uri">https://www.youtube.com/watch?v=jbkSRLYSojo</a>.</p>
<p>The gapminder data summarises the progression of countries over time, looking at statistics like life expectancy and GDP. The data is easy to access in R, thanks to Jenny Bryan who created the gapminder package:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gapminder)
gapminder
<span class="co">#&gt; # A tibble: 1,704 x 6</span>
<span class="co">#&gt;   country     continent  year lifeExp      pop gdpPercap</span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Afghanistan Asia       1952    28.8  8425333      779.</span>
<span class="co">#&gt; 2 Afghanistan Asia       1957    30.3  9240934      821.</span>
<span class="co">#&gt; 3 Afghanistan Asia       1962    32.0 10267083      853.</span>
<span class="co">#&gt; 4 Afghanistan Asia       1967    34.0 11537966      836.</span>
<span class="co">#&gt; 5 Afghanistan Asia       1972    36.1 13079460      740.</span>
<span class="co">#&gt; 6 Afghanistan Asia       1977    38.4 14880372      786.</span>
<span class="co">#&gt; # … with 1,698 more rows</span></code></pre>
<p>In this case study, we’re going to focus on just three variables to answer the question “How does life expectancy (<code>lifeExp</code>) change over time (<code>year</code>) for each country (<code>country</code>)?”. A good place to start is with a plot:</p>
<pre class="sourceCode r"><code class="sourceCode r">gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, lifeExp, <span class="dt">group =</span> country)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span>)</code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This is a small dataset: it only has ~1,700 observations and 3 variables. But it’s still hard to see what’s going on! Overall, it looks like life expectancy has been steadily improving. However, if you look closely, you might notice some countries that don’t follow this pattern. How can we make those countries easier to see?</p>
<p>One way is to use the same approach as in the last chapter: there’s a strong signal (overall linear growth) that makes it hard to see subtler trends. We’ll tease these factors apart by fitting a model with a linear trend. The model captures steady growth over time, and the residuals will show what’s left.</p>
<p>You already know how to do that if we had a single country:</p>
<pre class="sourceCode r"><code class="sourceCode r">nz &lt;-<span class="st"> </span><span class="kw">filter</span>(gapminder, country <span class="op">==</span><span class="st"> &quot;New Zealand&quot;</span>)
nz <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, lifeExp)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Full data = &quot;</span>)

nz_mod &lt;-<span class="st"> </span><span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span>year, <span class="dt">data =</span> nz)
nz <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_predictions</span>(nz_mod) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, pred)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Linear trend + &quot;</span>)

nz <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">add_residuals</span>(nz_mod) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">colour =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">size =</span> <span class="dv">3</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Remaining pattern&quot;</span>)</code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-4-1.png" width="33%" /><img src="model-many_files/figure-html/unnamed-chunk-4-2.png" width="33%" /><img src="model-many_files/figure-html/unnamed-chunk-4-3.png" width="33%" /></p>
<p>How can we easily fit that model to every country?</p>
<div id="nested-data" class="section level3">
<h3><span class="header-section-number">25.2.1</span> Nested data</h3>
<p>You could imagine copy and pasting that code multiple times; but you’ve already learned a better way! Extract out the common code with a function and repeat using a map function from purrr. This problem is structured a little differently to what you’ve seen before. Instead of repeating an action for each variable, we want to repeat an action for each country, a subset of rows. To do that, we need a new data structure: the <strong>nested data frame</strong>. To create a nested data frame we start with a grouped data frame, and “nest” it:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country &lt;-<span class="st"> </span>gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(country, continent) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">nest</span>()

by_country
<span class="co">#&gt; # A tibble: 142 x 3</span>
<span class="co">#&gt;   country     continent data             </span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;list&gt;           </span>
<span class="co">#&gt; 1 Afghanistan Asia      &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 2 Albania     Europe    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 3 Algeria     Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 4 Angola      Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 5 Argentina   Americas  &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 6 Australia   Oceania   &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
<p>(I’m cheating a little by grouping on both <code>continent</code> and <code>country</code>. Given <code>country</code>, <code>continent</code> is fixed, so this doesn’t add any more groups, but it’s an easy way to carry an extra variable along for the ride.)</p>
<p>This creates a data frame that has one row per group (per country), and a rather unusual column: <code>data</code>. <code>data</code> is a list of data frames (or tibbles, to be precise). This seems like a crazy idea: we have a data frame with a column that is a list of other data frames! I’ll explain shortly why I think this is a good idea.</p>
<p>The <code>data</code> column is a little tricky to look at because it’s a moderately complicated list, and we’re still working on good tools to explore these objects. Unfortunately using <code>str()</code> is not recommended as it will often produce very long output. But if you pluck out a single element from the <code>data</code> column you’ll see that it contains all the data for that country (in this case, Afghanistan).</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country<span class="op">$</span>data[[<span class="dv">1</span>]]
<span class="co">#&gt; # A tibble: 12 x 4</span>
<span class="co">#&gt;    year lifeExp      pop gdpPercap</span>
<span class="co">#&gt;   &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;</span>
<span class="co">#&gt; 1  1952    28.8  8425333      779.</span>
<span class="co">#&gt; 2  1957    30.3  9240934      821.</span>
<span class="co">#&gt; 3  1962    32.0 10267083      853.</span>
<span class="co">#&gt; 4  1967    34.0 11537966      836.</span>
<span class="co">#&gt; 5  1972    36.1 13079460      740.</span>
<span class="co">#&gt; 6  1977    38.4 14880372      786.</span>
<span class="co">#&gt; # … with 6 more rows</span></code></pre>
<p>Note the difference between a standard grouped data frame and a nested data frame: in a grouped data frame, each row is an observation; in a nested data frame, each row is a group. Another way to think about a nested dataset is we now have a meta-observation: a row that represents the complete time course for a country, rather than a single point in time.</p>
</div>
<div id="list-columns" class="section level3">
<h3><span class="header-section-number">25.2.2</span> List-columns</h3>
<p>Now that we have our nested data frame, we’re in a good position to fit some models. We have a model-fitting function:</p>
<pre class="sourceCode r"><code class="sourceCode r">country_model &lt;-<span class="st"> </span><span class="cf">function</span>(df) {
  <span class="kw">lm</span>(lifeExp <span class="op">~</span><span class="st"> </span>year, <span class="dt">data =</span> df)
}</code></pre>
<p>And we want to apply it to every data frame. The data frames are in a list, so we can use <code>purrr::map()</code> to apply <code>country_model</code> to each element:</p>
<pre class="sourceCode r"><code class="sourceCode r">models &lt;-<span class="st"> </span><span class="kw">map</span>(by_country<span class="op">$</span>data, country_model)</code></pre>
<p>However, rather than leaving the list of models as a free-floating object, I think it’s better to store it as a column in the <code>by_country</code> data frame. Storing related objects in columns is a key part of the value of data frames, and why I think list-columns are such a good idea. In the course of working with these countries, we are going to have lots of lists where we have one element per country. So why not store them all together in one data frame?</p>
<p>In other words, instead of creating a new object in the global environment, we’re going to create a new variable in the <code>by_country</code> data frame. That’s a job for <code>dplyr::mutate()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country &lt;-<span class="st"> </span>by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">model =</span> <span class="kw">map</span>(data, country_model))
by_country
<span class="co">#&gt; # A tibble: 142 x 4</span>
<span class="co">#&gt;   country     continent data              model   </span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;list&gt;            &lt;list&gt;  </span>
<span class="co">#&gt; 1 Afghanistan Asia      &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 2 Albania     Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 3 Algeria     Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 4 Angola      Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 5 Argentina   Americas  &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 6 Australia   Oceania   &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
<p>This has a big advantage: because all the related objects are stored together, you don’t need to manually keep them in sync when you filter or arrange. The semantics of the data frame takes care of that for you:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(continent <span class="op">==</span><span class="st"> &quot;Europe&quot;</span>)
<span class="co">#&gt; # A tibble: 30 x 4</span>
<span class="co">#&gt;   country                continent data              model   </span>
<span class="co">#&gt;   &lt;fct&gt;                  &lt;fct&gt;     &lt;list&gt;            &lt;list&gt;  </span>
<span class="co">#&gt; 1 Albania                Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 2 Austria                Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 3 Belgium                Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 4 Bosnia and Herzegovina Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 5 Bulgaria               Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 6 Croatia                Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; # … with 24 more rows</span>
by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(continent, country)
<span class="co">#&gt; # A tibble: 142 x 4</span>
<span class="co">#&gt;   country      continent data              model   </span>
<span class="co">#&gt;   &lt;fct&gt;        &lt;fct&gt;     &lt;list&gt;            &lt;list&gt;  </span>
<span class="co">#&gt; 1 Algeria      Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 2 Angola       Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 3 Benin        Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 4 Botswana     Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 5 Burkina Faso Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; 6 Burundi      Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
<p>If your list of data frames and list of models were separate objects, you have to remember that whenever you re-order or subset one vector, you need to re-order or subset all the others in order to keep them in sync. If you forget, your code will continue to work, but it will give the wrong answer!</p>
</div>
<div id="unnesting" class="section level3">
<h3><span class="header-section-number">25.2.3</span> Unnesting</h3>
<p>Previously we computed the residuals of a single model with a single dataset. Now we have 142 data frames and 142 models. To compute the residuals, we need to call <code>add_residuals()</code> with each model-data pair:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country &lt;-<span class="st"> </span>by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">resids =</span> <span class="kw">map2</span>(data, model, add_residuals)
  )
by_country
<span class="co">#&gt; # A tibble: 142 x 5</span>
<span class="co">#&gt;   country     continent data              model    resids           </span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;list&gt;            &lt;list&gt;   &lt;list&gt;           </span>
<span class="co">#&gt; 1 Afghanistan Asia      &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; 2 Albania     Europe    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; 3 Algeria     Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; 4 Angola      Africa    &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; 5 Argentina   Americas  &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; 6 Australia   Oceania   &lt;tibble [12 × 4]&gt; &lt;S3: lm&gt; &lt;tibble [12 × 5]&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
<p>But how you can plot a list of data frames? Instead of struggling to answer that question, let’s turn the list of data frames back into a regular data frame. Previously we used <code>nest()</code> to turn a regular data frame into an nested data frame, and now we do the opposite with <code>unnest()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">resids &lt;-<span class="st"> </span><span class="kw">unnest</span>(by_country, resids)
resids
<span class="co">#&gt; # A tibble: 1,704 x 7</span>
<span class="co">#&gt;   country     continent  year lifeExp      pop gdpPercap   resid</span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;   &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Afghanistan Asia       1952    28.8  8425333      779. -1.11  </span>
<span class="co">#&gt; 2 Afghanistan Asia       1957    30.3  9240934      821. -0.952 </span>
<span class="co">#&gt; 3 Afghanistan Asia       1962    32.0 10267083      853. -0.664 </span>
<span class="co">#&gt; 4 Afghanistan Asia       1967    34.0 11537966      836. -0.0172</span>
<span class="co">#&gt; 5 Afghanistan Asia       1972    36.1 13079460      740.  0.674 </span>
<span class="co">#&gt; 6 Afghanistan Asia       1977    38.4 14880372      786.  1.65  </span>
<span class="co">#&gt; # … with 1,698 more rows</span></code></pre>
<p>Note that each regular column is repeated one for each row in the nested column.</p>
<p>Now we have regular data frame, we can plot the residuals:</p>
<pre class="sourceCode r"><code class="sourceCode r">resids <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, resid)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> country), <span class="dt">alpha =</span> <span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</span></code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Facetting by continent is particularly revealing:</p>
<pre class="sourceCode r"><code class="sourceCode r">resids <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, resid, <span class="dt">group =</span> country)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>(<span class="dt">alpha =</span> <span class="dv">1</span> <span class="op">/</span><span class="st"> </span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">facet_wrap</span>(<span class="op">~</span>continent)</code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It looks like we’ve missed some mild patterns. There’s also something interesting going on in Africa: we see some very large residuals which suggests our model isn’t fitting so well there. We’ll explore that more in the next section, attacking it from a slightly different angle.</p>
</div>
<div id="model-quality" class="section level3">
<h3><span class="header-section-number">25.2.4</span> Model quality</h3>
<p>Instead of looking at the residuals from the model, we could look at some general measurements of model quality. You learned how to compute some specific measures in the previous chapter. Here we’ll show a different approach using the broom package. The broom package provides a general set of functions to turn models into tidy data. Here we’ll use <code>broom::glance()</code> to extract some model quality metrics. If we apply it to a model, we get a data frame with a single row:</p>
<pre class="sourceCode r"><code class="sourceCode r">broom<span class="op">::</span><span class="kw">glance</span>(nz_mod)
<span class="co">#&gt; # A tibble: 1 x 11</span>
<span class="co">#&gt;   r.squared adj.r.squared sigma statistic p.value    df logLik   AIC   BIC</span>
<span class="co">#&gt;       &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     0.954         0.949 0.804      205. 5.41e-8     2  -13.3  32.6  34.1</span>
<span class="co">#&gt; # … with 2 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;</span></code></pre>
<p>We can use <code>mutate()</code> and <code>unnest()</code> to create a data frame with a row for each country:</p>
<pre class="sourceCode r"><code class="sourceCode r">by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">glance =</span> <span class="kw">map</span>(model, broom<span class="op">::</span>glance)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>(glance)
<span class="co">#&gt; # A tibble: 142 x 16</span>
<span class="co">#&gt;   country continent data  model resids r.squared adj.r.squared sigma</span>
<span class="co">#&gt;   &lt;fct&gt;   &lt;fct&gt;     &lt;lis&gt; &lt;lis&gt; &lt;list&gt;     &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 Afghan… Asia      &lt;tib… &lt;S3:… &lt;tibb…     0.948         0.942 1.22 </span>
<span class="co">#&gt; 2 Albania Europe    &lt;tib… &lt;S3:… &lt;tibb…     0.911         0.902 1.98 </span>
<span class="co">#&gt; 3 Algeria Africa    &lt;tib… &lt;S3:… &lt;tibb…     0.985         0.984 1.32 </span>
<span class="co">#&gt; 4 Angola  Africa    &lt;tib… &lt;S3:… &lt;tibb…     0.888         0.877 1.41 </span>
<span class="co">#&gt; 5 Argent… Americas  &lt;tib… &lt;S3:… &lt;tibb…     0.996         0.995 0.292</span>
<span class="co">#&gt; 6 Austra… Oceania   &lt;tib… &lt;S3:… &lt;tibb…     0.980         0.978 0.621</span>
<span class="co">#&gt; # … with 136 more rows, and 8 more variables: statistic &lt;dbl&gt;,</span>
<span class="co">#&gt; #   p.value &lt;dbl&gt;, df &lt;int&gt;, logLik &lt;dbl&gt;, AIC &lt;dbl&gt;, BIC &lt;dbl&gt;,</span>
<span class="co">#&gt; #   deviance &lt;dbl&gt;, df.residual &lt;int&gt;</span></code></pre>
<p>This isn’t quite the output we want, because it still includes all the list columns. This is default behaviour when <code>unnest()</code> works on single row data frames. To suppress these columns we use <code>.drop = TRUE</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">glance &lt;-<span class="st"> </span>by_country <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">glance =</span> <span class="kw">map</span>(model, broom<span class="op">::</span>glance)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>(glance, <span class="dt">.drop =</span> <span class="ot">TRUE</span>)
glance
<span class="co">#&gt; # A tibble: 142 x 13</span>
<span class="co">#&gt;   country continent r.squared adj.r.squared sigma statistic  p.value    df</span>
<span class="co">#&gt;   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 Afghan… Asia          0.948         0.942 1.22      181.  9.84e- 8     2</span>
<span class="co">#&gt; 2 Albania Europe        0.911         0.902 1.98      102.  1.46e- 6     2</span>
<span class="co">#&gt; 3 Algeria Africa        0.985         0.984 1.32      662.  1.81e-10     2</span>
<span class="co">#&gt; 4 Angola  Africa        0.888         0.877 1.41       79.1 4.59e- 6     2</span>
<span class="co">#&gt; 5 Argent… Americas      0.996         0.995 0.292    2246.  4.22e-13     2</span>
<span class="co">#&gt; 6 Austra… Oceania       0.980         0.978 0.621     481.  8.67e-10     2</span>
<span class="co">#&gt; # … with 136 more rows, and 5 more variables: logLik &lt;dbl&gt;, AIC &lt;dbl&gt;,</span>
<span class="co">#&gt; #   BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;</span></code></pre>
<p>(Pay attention to the variables that aren’t printed: there’s a lot of useful stuff there.)</p>
<p>With this data frame in hand, we can start to look for models that don’t fit well:</p>
<pre class="sourceCode r"><code class="sourceCode r">glance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(r.squared)
<span class="co">#&gt; # A tibble: 142 x 13</span>
<span class="co">#&gt;   country continent r.squared adj.r.squared sigma statistic p.value    df</span>
<span class="co">#&gt;   &lt;fct&gt;   &lt;fct&gt;         &lt;dbl&gt;         &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;</span>
<span class="co">#&gt; 1 Rwanda  Africa       0.0172      -0.0811   6.56     0.175   0.685     2</span>
<span class="co">#&gt; 2 Botswa… Africa       0.0340      -0.0626   6.11     0.352   0.566     2</span>
<span class="co">#&gt; 3 Zimbab… Africa       0.0562      -0.0381   7.21     0.596   0.458     2</span>
<span class="co">#&gt; 4 Zambia  Africa       0.0598      -0.0342   4.53     0.636   0.444     2</span>
<span class="co">#&gt; 5 Swazil… Africa       0.0682      -0.0250   6.64     0.732   0.412     2</span>
<span class="co">#&gt; 6 Lesotho Africa       0.0849      -0.00666  5.93     0.927   0.358     2</span>
<span class="co">#&gt; # … with 136 more rows, and 5 more variables: logLik &lt;dbl&gt;, AIC &lt;dbl&gt;,</span>
<span class="co">#&gt; #   BIC &lt;dbl&gt;, deviance &lt;dbl&gt;, df.residual &lt;int&gt;</span></code></pre>
<p>The worst models all appear to be in Africa. Let’s double check that with a plot. Here we have a relatively small number of observations and a discrete variable, so <code>geom_jitter()</code> is effective:</p>
<pre class="sourceCode r"><code class="sourceCode r">glance <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(continent, r.squared)) <span class="op">+</span><span class="st"> </span>
<span class="st">    </span><span class="kw">geom_jitter</span>(<span class="dt">width =</span> <span class="fl">0.5</span>)</code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We could pull out the countries with particularly bad <span class="math inline">\(R^2\)</span> and plot the data:</p>
<pre class="sourceCode r"><code class="sourceCode r">bad_fit &lt;-<span class="st"> </span><span class="kw">filter</span>(glance, r.squared <span class="op">&lt;</span><span class="st"> </span><span class="fl">0.25</span>)

gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">semi_join</span>(bad_fit, <span class="dt">by =</span> <span class="st">&quot;country&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, lifeExp, <span class="dt">colour =</span> country)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_line</span>()</code></pre>
<p><img src="model-many_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>We see two main effects here: the tragedies of the HIV/AIDS epidemic and the Rwandan genocide.</p>
</div>
<div id="exercises-65" class="section level3">
<h3><span class="header-section-number">25.2.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>A linear trend seems to be slightly too simple for the overall trend.
Can you do better with a quadratic polynomial? How can you interpret
the coefficients of the quadratic? (Hint you might want to transform
<code>year</code> so that it has mean zero.)</p></li>
<li><p>Explore other methods for visualising the distribution of <span class="math inline">\(R^2\)</span> per
continent. You might want to try the ggbeeswarm package, which provides
similar methods for avoiding overlaps as jitter, but uses deterministic
methods.</p></li>
<li><p>To create the last plot (showing the data for the countries with the
worst model fits), we needed two steps: we created a data frame with
one row per country and then semi-joined it to the original dataset.
It’s possible to avoid this join if we use <code>unnest()</code> instead of
<code>unnest(.drop = TRUE)</code>. How?</p></li>
</ol>
</div>
</div>
<div id="list-columns-1" class="section level2">
<h2><span class="header-section-number">25.3</span> List-columns</h2>
<p>Now that you’ve seen a basic workflow for managing many models, let’s dive back into some of the details. In this section, we’ll explore the list-column data structure in a little more detail. It’s only recently that I’ve really appreciated the idea of the list-column. List-columns are implicit in the definition of the data frame: a data frame is a named list of equal length vectors. A list is a vector, so it’s always been legitimate to use a list as a column of a data frame. However, base R doesn’t make it easy to create list-columns, and <code>data.frame()</code> treats a list as a list of columns:.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data.frame</span>(<span class="dt">x =</span> <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>))
<span class="co">#&gt;   x.1.3 x.3.5</span>
<span class="co">#&gt; 1     1     3</span>
<span class="co">#&gt; 2     2     4</span>
<span class="co">#&gt; 3     3     5</span></code></pre>
<p>You can prevent <code>data.frame()</code> from doing this with <code>I()</code>, but the result doesn’t print particularly well:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data.frame</span>(
  <span class="dt">x =</span> <span class="kw">I</span>(<span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>)), 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;1, 2&quot;</span>, <span class="st">&quot;3, 4, 5&quot;</span>)
)
<span class="co">#&gt;         x       y</span>
<span class="co">#&gt; 1 1, 2, 3    1, 2</span>
<span class="co">#&gt; 2 3, 4, 5 3, 4, 5</span></code></pre>
<p>Tibble alleviates this problem by being lazier (<code>tibble()</code> doesn’t modify its inputs) and by providing a better print method:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>), 
  <span class="dt">y =</span> <span class="kw">c</span>(<span class="st">&quot;1, 2&quot;</span>, <span class="st">&quot;3, 4, 5&quot;</span>)
)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   x         y      </span>
<span class="co">#&gt;   &lt;list&gt;    &lt;chr&gt;  </span>
<span class="co">#&gt; 1 &lt;int [3]&gt; 1, 2   </span>
<span class="co">#&gt; 2 &lt;int [3]&gt; 3, 4, 5</span></code></pre>
<p>It’s even easier with <code>tribble()</code> as it can automatically work out that you need a list:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tribble</span>(
   <span class="op">~</span>x, <span class="op">~</span>y,
  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;1, 2&quot;</span>,
  <span class="dv">3</span><span class="op">:</span><span class="dv">5</span>, <span class="st">&quot;3, 4, 5&quot;</span>
)
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   x         y      </span>
<span class="co">#&gt;   &lt;list&gt;    &lt;chr&gt;  </span>
<span class="co">#&gt; 1 &lt;int [3]&gt; 1, 2   </span>
<span class="co">#&gt; 2 &lt;int [3]&gt; 3, 4, 5</span></code></pre>
<p>List-columns are often most useful as intermediate data structure. They’re hard to work with directly, because most R functions work with atomic vectors or data frames, but the advantage of keeping related items together in a data frame is worth a little hassle.</p>
<p>Generally there are three parts of an effective list-column pipeline:</p>
<ol style="list-style-type: decimal">
<li><p>You create the list-column using one of <code>nest()</code>, <code>summarise()</code> + <code>list()</code>,
or <code>mutate()</code> + a map function, as described in <a href="#creating-list-columns">Creating list-columns</a>.</p></li>
<li><p>You create other intermediate list-columns by transforming existing
list columns with <code>map()</code>, <code>map2()</code> or <code>pmap()</code>. For example,
in the case study above, we created a list-column of models by transforming
a list-column of data frames.</p></li>
<li><p>You simplify the list-column back down to a data frame or atomic vector,
as described in <a href="#simplifying-list-columns">Simplifying list-columns</a>.</p></li>
</ol>
</div>
<div id="creating-list-columns" class="section level2">
<h2><span class="header-section-number">25.4</span> Creating list-columns</h2>
<p>Typically, you won’t create list-columns with <code>tibble()</code>. Instead, you’ll create them from regular columns, using one of three methods:</p>
<ol style="list-style-type: decimal">
<li><p>With <code>tidyr::nest()</code> to convert a grouped data frame into a nested data
frame where you have list-column of data frames.</p></li>
<li><p>With <code>mutate()</code> and vectorised functions that return a list.</p></li>
<li><p>With <code>summarise()</code> and summary functions that return multiple results.</p></li>
</ol>
<p>Alternatively, you might create them from a named list, using <code>tibble::enframe()</code>.</p>
<p>Generally, when creating list-columns, you should make sure they’re homogeneous: each element should contain the same type of thing. There are no checks to make sure this is true, but if you use purrr and remember what you’ve learned about type-stable functions, you should find it happens naturally.</p>
<div id="with-nesting" class="section level3">
<h3><span class="header-section-number">25.4.1</span> With nesting</h3>
<p><code>nest()</code> creates a nested data frame, which is a data frame with a list-column of data frames. In a nested data frame each row is a meta-observation: the other columns give variables that define the observation (like country and continent above), and the list-column of data frames gives the individual observations that make up the meta-observation.</p>
<p>There are two ways to use <code>nest()</code>. So far you’ve seen how to use it with a grouped data frame. When applied to a grouped data frame, <code>nest()</code> keeps the grouping columns as is, and bundles everything else into the list-column:</p>
<pre class="sourceCode r"><code class="sourceCode r">gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(country, continent) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">nest</span>()
<span class="co">#&gt; # A tibble: 142 x 3</span>
<span class="co">#&gt;   country     continent data             </span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;list&gt;           </span>
<span class="co">#&gt; 1 Afghanistan Asia      &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 2 Albania     Europe    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 3 Algeria     Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 4 Angola      Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 5 Argentina   Americas  &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 6 Australia   Oceania   &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
<p>You can also use it on an ungrouped data frame, specifying which columns you want to nest:</p>
<pre class="sourceCode r"><code class="sourceCode r">gapminder <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">nest</span>(year<span class="op">:</span>gdpPercap)
<span class="co">#&gt; # A tibble: 142 x 3</span>
<span class="co">#&gt;   country     continent data             </span>
<span class="co">#&gt;   &lt;fct&gt;       &lt;fct&gt;     &lt;list&gt;           </span>
<span class="co">#&gt; 1 Afghanistan Asia      &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 2 Albania     Europe    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 3 Algeria     Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 4 Angola      Africa    &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 5 Argentina   Americas  &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; 6 Australia   Oceania   &lt;tibble [12 × 4]&gt;</span>
<span class="co">#&gt; # … with 136 more rows</span></code></pre>
</div>
<div id="from-vectorised-functions" class="section level3">
<h3><span class="header-section-number">25.4.2</span> From vectorised functions</h3>
<p>Some useful functions take an atomic vector and return a list. For example, in <a href="#strings">strings</a> you learned about <code>stringr::str_split()</code> which takes a character vector and returns a list of character vectors. If you use that inside mutate, you’ll get a list-column:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x1,
  <span class="st">&quot;a,b,c&quot;</span>, 
  <span class="st">&quot;d,e,f,g&quot;</span>
) 

df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">x2 =</span> stringr<span class="op">::</span><span class="kw">str_split</span>(x1, <span class="st">&quot;,&quot;</span>))
<span class="co">#&gt; # A tibble: 2 x 2</span>
<span class="co">#&gt;   x1      x2       </span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;list&gt;   </span>
<span class="co">#&gt; 1 a,b,c   &lt;chr [3]&gt;</span>
<span class="co">#&gt; 2 d,e,f,g &lt;chr [4]&gt;</span></code></pre>
<p><code>unnest()</code> knows how to handle these lists of vectors:</p>
<pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">x2 =</span> stringr<span class="op">::</span><span class="kw">str_split</span>(x1, <span class="st">&quot;,&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>()
<span class="co">#&gt; # A tibble: 7 x 2</span>
<span class="co">#&gt;   x1      x2   </span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;</span>
<span class="co">#&gt; 1 a,b,c   a    </span>
<span class="co">#&gt; 2 a,b,c   b    </span>
<span class="co">#&gt; 3 a,b,c   c    </span>
<span class="co">#&gt; 4 d,e,f,g d    </span>
<span class="co">#&gt; 5 d,e,f,g e    </span>
<span class="co">#&gt; 6 d,e,f,g f    </span>
<span class="co">#&gt; # … with 1 more row</span></code></pre>
<p>(If you find yourself using this pattern a lot, make sure to check out <code>tidyr::separate_rows()</code> which is a wrapper around this common pattern).</p>
<p>Another example of this pattern is using the <code>map()</code>, <code>map2()</code>, <code>pmap()</code> from purrr. For example, we could take the final example from <a href="#invoking-different-functions">Invoking different functions</a> and rewrite it to use <code>mutate()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">sim &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>f,      <span class="op">~</span>params,
  <span class="st">&quot;runif&quot;</span>, <span class="kw">list</span>(<span class="dt">min =</span> <span class="dv">-1</span>, <span class="dt">max =</span> <span class="dv">1</span>),
  <span class="st">&quot;rnorm&quot;</span>, <span class="kw">list</span>(<span class="dt">sd =</span> <span class="dv">5</span>),
  <span class="st">&quot;rpois&quot;</span>, <span class="kw">list</span>(<span class="dt">lambda =</span> <span class="dv">10</span>)
)

sim <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sims =</span> <span class="kw">invoke_map</span>(f, params, <span class="dt">n =</span> <span class="dv">10</span>))
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   f     params     sims      </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;list&gt;     &lt;list&gt;    </span>
<span class="co">#&gt; 1 runif &lt;list [2]&gt; &lt;dbl [10]&gt;</span>
<span class="co">#&gt; 2 rnorm &lt;list [1]&gt; &lt;dbl [10]&gt;</span>
<span class="co">#&gt; 3 rpois &lt;list [1]&gt; &lt;int [10]&gt;</span></code></pre>
<p>Note that technically <code>sim</code> isn’t homogeneous because it contains both double and integer vectors. However, this is unlikely to cause many problems since integers and doubles are both numeric vectors.</p>
</div>
<div id="from-multivalued-summaries" class="section level3">
<h3><span class="header-section-number">25.4.3</span> From multivalued summaries</h3>
<p>One restriction of <code>summarise()</code> is that it only works with summary functions that return a single value. That means that you can’t use it with functions like <code>quantile()</code> that return a vector of arbitrary length:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">q =</span> <span class="kw">quantile</span>(mpg))
<span class="co">#&gt; Error in summarise_impl(.data, dots): Column `q` must be length 1 (a summary value), not 5</span></code></pre>
<p>You can however, wrap the result in a list! This obeys the contract of <code>summarise()</code>, because each summary is now a list (a vector) of length 1.</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">q =</span> <span class="kw">list</span>(<span class="kw">quantile</span>(mpg)))
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;     cyl q        </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;list&gt;   </span>
<span class="co">#&gt; 1     4 &lt;dbl [5]&gt;</span>
<span class="co">#&gt; 2     6 &lt;dbl [5]&gt;</span>
<span class="co">#&gt; 3     8 &lt;dbl [5]&gt;</span></code></pre>
<p>To make useful results with unnest, you’ll also need to capture the probabilities:</p>
<pre class="sourceCode r"><code class="sourceCode r">probs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.5</span>, <span class="fl">0.75</span>, <span class="fl">0.99</span>)
mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">p =</span> <span class="kw">list</span>(probs), <span class="dt">q =</span> <span class="kw">list</span>(<span class="kw">quantile</span>(mpg, probs))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>()
<span class="co">#&gt; # A tibble: 15 x 3</span>
<span class="co">#&gt;     cyl     p     q</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     4  0.01  21.4</span>
<span class="co">#&gt; 2     4  0.25  22.8</span>
<span class="co">#&gt; 3     4  0.5   26  </span>
<span class="co">#&gt; 4     4  0.75  30.4</span>
<span class="co">#&gt; 5     4  0.99  33.8</span>
<span class="co">#&gt; 6     6  0.01  17.8</span>
<span class="co">#&gt; # … with 9 more rows</span></code></pre>
</div>
<div id="from-a-named-list" class="section level3">
<h3><span class="header-section-number">25.4.4</span> From a named list</h3>
<p>Data frames with list-columns provide a solution to a common problem: what do you do if you want to iterate over both the contents of a list and its elements? Instead of trying to jam everything into one object, it’s often easier to make a data frame: one column can contain the elements, and one column can contain the list. An easy way to create such a data frame from a list is <code>tibble::enframe()</code>.</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="dt">a =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,
  <span class="dt">b =</span> <span class="dv">3</span><span class="op">:</span><span class="dv">4</span>, 
  <span class="dt">c =</span> <span class="dv">5</span><span class="op">:</span><span class="dv">6</span>
) 

df &lt;-<span class="st"> </span><span class="kw">enframe</span>(x)
df
<span class="co">#&gt; # A tibble: 3 x 2</span>
<span class="co">#&gt;   name  value    </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;list&gt;   </span>
<span class="co">#&gt; 1 a     &lt;int [5]&gt;</span>
<span class="co">#&gt; 2 b     &lt;int [2]&gt;</span>
<span class="co">#&gt; 3 c     &lt;int [2]&gt;</span></code></pre>
<p>The advantage of this structure is that it generalises in a straightforward way - names are useful if you have character vector of metadata, but don’t help if you have other types of data, or multiple vectors.</p>
<p>Now if you want to iterate over names and values in parallel, you can use <code>map2()</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">smry =</span> <span class="kw">map2_chr</span>(name, value, <span class="op">~</span><span class="st"> </span>stringr<span class="op">::</span><span class="kw">str_c</span>(.x, <span class="st">&quot;: &quot;</span>, .y[<span class="dv">1</span>]))
  )
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   name  value     smry </span>
<span class="co">#&gt;   &lt;chr&gt; &lt;list&gt;    &lt;chr&gt;</span>
<span class="co">#&gt; 1 a     &lt;int [5]&gt; a: 1 </span>
<span class="co">#&gt; 2 b     &lt;int [2]&gt; b: 3 </span>
<span class="co">#&gt; 3 c     &lt;int [2]&gt; c: 5</span></code></pre>
</div>
<div id="exercises-66" class="section level3">
<h3><span class="header-section-number">25.4.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>List all the functions that you can think of that take a atomic vector and
return a list.</p></li>
<li><p>Brainstorm useful summary functions that, like <code>quantile()</code>, return
multiple values.</p></li>
<li><p>What’s missing in the following data frame? How does <code>quantile()</code> return
that missing piece? Why isn’t that helpful here?</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">q =</span> <span class="kw">list</span>(<span class="kw">quantile</span>(mpg))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>()
<span class="co">#&gt; # A tibble: 15 x 2</span>
<span class="co">#&gt;     cyl     q</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     4  21.4</span>
<span class="co">#&gt; 2     4  22.8</span>
<span class="co">#&gt; 3     4  26  </span>
<span class="co">#&gt; 4     4  30.4</span>
<span class="co">#&gt; 5     4  33.9</span>
<span class="co">#&gt; 6     6  17.8</span>
<span class="co">#&gt; # … with 9 more rows</span></code></pre></li>
<li><p>What does this code do? Why might might it be useful?</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(cyl) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarise_each</span>(<span class="kw">funs</span>(list))</code></pre></li>
</ol>
</div>
</div>
<div id="simplifying-list-columns" class="section level2">
<h2><span class="header-section-number">25.5</span> Simplifying list-columns</h2>
<p>To apply the techniques of data manipulation and visualisation you’ve learned in this book, you’ll need to simplify the list-column back to a regular column (an atomic vector), or set of columns. The technique you’ll use to collapse back down to a simpler structure depends on whether you want a single value per element, or multiple values:</p>
<ol style="list-style-type: decimal">
<li><p>If you want a single value, use <code>mutate()</code> with <code>map_lgl()</code>,
<code>map_int()</code>, <code>map_dbl()</code>, and <code>map_chr()</code> to create an atomic vector.</p></li>
<li><p>If you want many values, use <code>unnest()</code> to convert list-columns back
to regular columns, repeating the rows as many times as necessary.</p></li>
</ol>
<p>These are described in more detail below.</p>
<div id="list-to-vector" class="section level3">
<h3><span class="header-section-number">25.5.1</span> List to vector</h3>
<p>If you can reduce your list column to an atomic vector then it will be a regular column. For example, you can always summarise an object with its type and length, so this code will work regardless of what sort of list-column you have:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x,
  letters[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>],
  <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
  <span class="kw">runif</span>(<span class="dv">5</span>)
)
  
df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(
  <span class="dt">type =</span> <span class="kw">map_chr</span>(x, typeof),
  <span class="dt">length =</span> <span class="kw">map_int</span>(x, length)
)
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;   x         type      length</span>
<span class="co">#&gt;   &lt;list&gt;    &lt;chr&gt;      &lt;int&gt;</span>
<span class="co">#&gt; 1 &lt;chr [5]&gt; character      5</span>
<span class="co">#&gt; 2 &lt;int [3]&gt; integer        3</span>
<span class="co">#&gt; 3 &lt;dbl [5]&gt; double         5</span></code></pre>
<p>This is the same basic information that you get from the default tbl print method, but now you can use it for filtering. This is a useful technique if you have a heterogeneous list, and want to filter out the parts aren’t working for you.</p>
<p>Don’t forget about the <code>map_*()</code> shortcuts - you can use <code>map_chr(x, &quot;apple&quot;)</code> to extract the string stored in <code>apple</code> for each element of <code>x</code>. This is useful for pulling apart nested lists into regular columns. Use the <code>.null</code> argument to provide a value to use if the element is missing (instead of returning <code>NULL</code>):</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x,
  <span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="dv">2</span>),
  <span class="kw">list</span>(<span class="dt">a =</span> <span class="dv">2</span>, <span class="dt">c =</span> <span class="dv">4</span>)
)
df <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">mutate</span>(
  <span class="dt">a =</span> <span class="kw">map_dbl</span>(x, <span class="st">&quot;a&quot;</span>),
  <span class="dt">b =</span> <span class="kw">map_dbl</span>(x, <span class="st">&quot;b&quot;</span>, <span class="dt">.null =</span> <span class="ot">NA_real_</span>)
)
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;   x              a     b</span>
<span class="co">#&gt;   &lt;list&gt;     &lt;dbl&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1 &lt;list [2]&gt;     1     2</span>
<span class="co">#&gt; 2 &lt;list [2]&gt;     2    NA</span></code></pre>
</div>
<div id="unnesting-1" class="section level3">
<h3><span class="header-section-number">25.5.2</span> Unnesting</h3>
<p><code>unnest()</code> works by repeating the regular columns once for each element of the list-column. For example, in the following very simple example we repeat the first row 4 times (because there the first element of <code>y</code> has length four), and the second row once:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tibble</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">y =</span> <span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unnest</span>(y)
<span class="co">#&gt; # A tibble: 5 x 2</span>
<span class="co">#&gt;       x     y</span>
<span class="co">#&gt;   &lt;int&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1     1</span>
<span class="co">#&gt; 2     1     2</span>
<span class="co">#&gt; 3     1     3</span>
<span class="co">#&gt; 4     1     4</span>
<span class="co">#&gt; 5     2     1</span></code></pre>
<p>This means that you can’t simultaneously unnest two columns that contain different number of elements:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Ok, because y and z have the same number of elements in</span>
<span class="co"># every row</span>
df1 &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y,           <span class="op">~</span>z,
   <span class="dv">1</span>, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,
   <span class="dv">2</span>, <span class="st">&quot;c&quot;</span>,           <span class="dv">3</span>
)
df1
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;       x y         z        </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;list&gt;    &lt;list&gt;   </span>
<span class="co">#&gt; 1     1 &lt;chr [2]&gt; &lt;int [2]&gt;</span>
<span class="co">#&gt; 2     2 &lt;chr [1]&gt; &lt;dbl [1]&gt;</span>
df1 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unnest</span>(y, z)
<span class="co">#&gt; # A tibble: 3 x 3</span>
<span class="co">#&gt;       x y         z</span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;</span>
<span class="co">#&gt; 1     1 a         1</span>
<span class="co">#&gt; 2     1 b         2</span>
<span class="co">#&gt; 3     2 c         3</span>

<span class="co"># Doesn&#39;t work because y and z have different number of elements</span>
df2 &lt;-<span class="st"> </span><span class="kw">tribble</span>(
  <span class="op">~</span>x, <span class="op">~</span>y,           <span class="op">~</span>z,
   <span class="dv">1</span>, <span class="st">&quot;a&quot;</span>,         <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>,  
   <span class="dv">2</span>, <span class="kw">c</span>(<span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>),   <span class="dv">3</span>
)
df2
<span class="co">#&gt; # A tibble: 2 x 3</span>
<span class="co">#&gt;       x y         z        </span>
<span class="co">#&gt;   &lt;dbl&gt; &lt;list&gt;    &lt;list&gt;   </span>
<span class="co">#&gt; 1     1 &lt;chr [1]&gt; &lt;int [2]&gt;</span>
<span class="co">#&gt; 2     2 &lt;chr [2]&gt; &lt;dbl [1]&gt;</span>
df2 <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unnest</span>(y, z)
<span class="co">#&gt; Error: All nested columns must have the same number of elements.</span></code></pre>
<p>The same principle applies when unnesting list-columns of data frames. You can unnest multiple list-cols as long as all the data frames in each row have the same number of rows.</p>
</div>
<div id="exercises-67" class="section level3">
<h3><span class="header-section-number">25.5.3</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why might the <code>lengths()</code> function be useful for creating atomic
vector columns from list-columns?</p></li>
<li><p>List the most common types of vector found in a data frame. What makes
lists different?</p></li>
</ol>
</div>
</div>
<div id="making-tidy-data-with-broom" class="section level2">
<h2><span class="header-section-number">25.6</span> Making tidy data with broom</h2>
<p>The broom package provides three general tools for turning models into tidy data frames:</p>
<ol style="list-style-type: decimal">
<li><p><code>broom::glance(model)</code> returns a row for each model. Each column gives a
model summary: either a measure of model quality, or complexity, or a
combination of the two.</p></li>
<li><p><code>broom::tidy(model)</code> returns a row for each coefficient in the model. Each
column gives information about the estimate or its variability.</p></li>
<li><p><code>broom::augment(model, data)</code> returns a row for each row in <code>data</code>, adding
extra values like residuals, and influence statistics.</p></li>
</ol>
<!--chapter:end:model-many.Rmd-->
</div>
</div>
<div id="part-communicate" class="section level1 unnumbered">
<h1><span class="header-section-number">V</span> Communicate</h1>
</div>
<div id="communicate-intro" class="section level1">
<h1><span class="header-section-number">26</span> Introduction</h1>
<p>So far, you’ve learned the tools to get your data into R, tidy it into a form convenient for analysis, and then understand your data through transformation, visualisation and modelling. However, it doesn’t matter how great your analysis is unless you can explain it to others: you need to <strong>communicate</strong> your results.</p>
<p><img src="diagrams/data-science-communicate.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Communication is the theme of the following four chapters:</p>
<ul>
<li><p>In <a href="#r-markdown">R Markdown</a>, you will learn about R Markdown, a tool for integrating
prose, code, and results. You can use R Markdown in notebook mode for
analyst-to-analyst communication, and in report mode for
analyst-to-decision-maker communication. Thanks to the power of R Markdown
formats, you can even use the same document for both purposes.</p></li>
<li><p>In <a href="#graphics-for-communication">Graphics for communication</a>, you will learn how to take your exploratory
graphics and turn them into expository graphics, graphics that help the
newcomer to your analysis understand what’s going on as quickly and
easily as possible.</p></li>
<li><p>In <a href="#r-markdown-formats">R Markdown formats</a>, you’ll learn a little about the many other varieties
of outputs you can produce using R Markdown, including dashboards, websites,
and books.</p></li>
<li><p>We’ll finish up with <a href="#r-markdown-workflow">R Markdown workflow</a>, where you’ll learn about the
“analysis notebook” and how to systematically record your successes and
failures so that you can learn from them.</p></li>
</ul>
<p>Unfortunately, these chapters focus mostly on the technical mechanics of communication, not the really hard problems of communicating your thoughts to other humans. However, there are lot of other great books about communication, which we’ll point you to at the end of each chapter.</p>
<!--chapter:end:communicate.Rmd-->
</div>
<div id="r-markdown" class="section level1">
<h1><span class="header-section-number">27</span> R Markdown</h1>
<div id="introduction-18" class="section level2">
<h2><span class="header-section-number">27.1</span> Introduction</h2>
<p>R Markdown provides an unified authoring framework for data science, combining your code, its results, and your prose commentary. R Markdown documents are fully reproducible and support dozens of output formats, like PDFs, Word files, slideshows, and more.</p>
<p>R Markdown files are designed to be used in three ways:</p>
<ol style="list-style-type: decimal">
<li><p>For communicating to decision makers, who want to focus on the conclusions,
not the code behind the analysis.</p></li>
<li><p>For collaborating with other data scientists (including future you!), who
are interested in both your conclusions, and how you reached them (
i.e. the code).</p></li>
<li><p>As an environment in which to <em>do</em> data science, as a modern day lab
notebook where you can capture not only what you did, but also what you
were thinking.</p></li>
</ol>
<p>R Markdown integrates a number of R packages and external tools. This means that help is, by-and-large, not available through <code>?</code>. Instead, as you work through this chapter, and use R Markdown in the future, keep these resources close to hand:</p>
<ul>
<li><p>R Markdown Cheat Sheet: <em>Help &gt; Cheatsheets &gt; R Markdown Cheat Sheet</em>,</p></li>
<li><p>R Markdown Reference Guide: <em>Help &gt; Cheatsheets &gt; R Markdown Reference
Guide</em>.</p></li>
</ul>
<p>Both cheatsheets are also available at <a href="http://rstudio.com/cheatsheets" class="uri">http://rstudio.com/cheatsheets</a>.</p>
<div id="prerequisites-18" class="section level3">
<h3><span class="header-section-number">27.1.1</span> Prerequisites</h3>
<p>You need the <strong>rmarkdown</strong> package, but you don’t need to explicitly install it or load it, as RStudio automatically does both when needed.</p>
</div>
</div>
<div id="r-markdown-basics" class="section level2">
<h2><span class="header-section-number">27.2</span> R Markdown basics</h2>
<p>This is an R Markdown file, a plain text file that has the extension <code>.Rmd</code>:</p>
<pre><code>---
title: &quot;Diamond sizes&quot;
date: 2016-08-25
output: html_document
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)

smaller &lt;- diamonds %&gt;% 
  filter(carat &lt;= 2.5)
```

We have data about `r nrow(diamonds)` diamonds. Only 
`r nrow(diamonds) - nrow(smaller)` are larger than
2.5 carats. The distribution of the remainder is shown
below:

```{r, echo = FALSE}
smaller %&gt;% 
  ggplot(aes(carat)) + 
  geom_freqpoly(binwidth = 0.01)
```</code></pre>
<p>It contains three important types of content:</p>
<ol style="list-style-type: decimal">
<li>An (optional) <strong>YAML header</strong> surrounded by <code>---</code>s.</li>
<li><strong>Chunks</strong> of R code surrounded by <code>```</code>.</li>
<li>Text mixed with simple text formatting like <code># heading</code> and <code>_italics_</code>.</li>
</ol>
<p>When you open an <code>.Rmd</code>, you get a notebook interface where code and output are interleaved. You can run each code chunk by clicking the Run icon (it looks like a play button at the top of the chunk), or by pressing Cmd/Ctrl + Shift + Enter. RStudio executes the code and displays the results inline with the code:</p>
<p><img src="rmarkdown/diamond-sizes-notebook.png" width="75%" style="display: block; margin: auto;" /></p>
<p>To produce a complete report containing all text, code, and results, click “Knit” or press Cmd/Ctrl + Shift + K. You can also do this programmatically with <code>rmarkdown::render(&quot;1-example.Rmd&quot;)</code>. This will display the report in the viewer pane, and create a self-contained HTML file that you can share with others.</p>
<p><img src="rmarkdown/diamond-sizes-report.png" width="75%" style="display: block; margin: auto;" /></p>
<p>When you <strong>knit</strong> the document, R Markdown sends the .Rmd file to <strong>knitr</strong>, <a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>, which executes all of the code chunks and creates a new markdown (.md) document which includes the code and its output. The markdown file generated by knitr is then processed by <strong>pandoc</strong>, <a href="http://pandoc.org/" class="uri">http://pandoc.org/</a>, which is responsible for creating the finished file. The advantage of this two step workflow is that you can create a very wide range of output formats, as you’ll learn about in <a href="#r-markdown-formats">R markdown formats</a>.</p>
<p><img src="images/RMarkdownFlow.png" width="75%" style="display: block; margin: auto;" /></p>
<p>To get started with your own <code>.Rmd</code> file, select <em>File &gt; New File &gt; R Markdown…</em> in the menubar. RStudio will launch a wizard that you can use to pre-populate your file with useful content that reminds you how the key features of R Markdown work.</p>
<p>The following sections dive into the three components of an R Markdown document in more details: the markdown text, the code chunks, and the YAML header.</p>
<div id="exercises-68" class="section level3">
<h3><span class="header-section-number">27.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Create a new notebook using <em>File &gt; New File &gt; R Notebook</em>. Read the
instructions. Practice running the chunks. Verify that you can modify
the code, re-run it, and see modified output.</p></li>
<li><p>Create a new R Markdown document with <em>File &gt; New File &gt; R Markdown…</em>
Knit it by clicking the appropriate button. Knit it by using the
appropriate keyboard short cut. Verify that you can modify the
input and see the output update.</p></li>
<li><p>Compare and contrast the R notebook and R markdown files you created
above. How are the outputs similar? How are they different? How are
the inputs similar? How are they different? What happens if you
copy the YAML header from one to the other?</p></li>
<li><p>Create one new R Markdown document for each of the three built-in
formats: HTML, PDF and Word. Knit each of the three documents.
How does the output differ? How does the input differ? (You may need
to install LaTeX in order to build the PDF output — RStudio will
prompt you if this is necessary.)</p></li>
</ol>
</div>
</div>
<div id="text-formatting-with-markdown" class="section level2">
<h2><span class="header-section-number">27.3</span> Text formatting with Markdown</h2>
<p>Prose in <code>.Rmd</code> files is written in Markdown, a lightweight set of conventions for formatting plain text files. Markdown is designed to be easy to read and easy to write. It is also very easy to learn. The guide below shows how to use Pandoc’s Markdown, a slightly extended version of Markdown that R Markdown understands.</p>
<pre><code>Text formatting 
------------------------------------------------------------

*italic*  or _italic_
**bold**   __bold__
`code`
superscript^2^ and subscript~2~

Headings
------------------------------------------------------------

# 1st Level Header

## 2nd Level Header

### 3rd Level Header

Lists
------------------------------------------------------------

*   Bulleted list item 1

*   Item 2

    * Item 2a

    * Item 2b

1.  Numbered list item 1

1.  Item 2. The numbers are incremented automatically in the output.

Links and images
------------------------------------------------------------

&lt;http://example.com&gt;

[linked phrase](http://example.com)

![optional caption text](path/to/img.png)

Tables 
------------------------------------------------------------

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell</code></pre>
<p>The best way to learn these is simply to try them out. It will take a few days, but soon they will become second nature, and you won’t need to think about them. If you forget, you can get to a handy reference sheet with <em>Help &gt; Markdown Quick Reference</em>.</p>
<div id="exercises-69" class="section level3">
<h3><span class="header-section-number">27.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Practice what you’ve learned by creating a brief CV. The title should be
your name, and you should include headings for (at least) education or
employment. Each of the sections should include a bulleted list of
jobs/degrees. Highlight the year in bold.</p></li>
<li><p>Using the R Markdown quick reference, figure out how to:</p>
<ol style="list-style-type: decimal">
<li>Add a footnote.</li>
<li>Add a horizontal rule.</li>
<li>Add a block quote.</li>
</ol></li>
<li><p>Copy and paste the contents of <code>diamond-sizes.Rmd</code> from
<a href="https://github.com/hadley/r4ds/tree/master/rmarkdown" class="uri">https://github.com/hadley/r4ds/tree/master/rmarkdown</a> in to a local
R markdown document. Check that you can run it, then add text after the
frequency polygon that describes its most striking features.</p></li>
</ol>
</div>
</div>
<div id="code-chunks" class="section level2">
<h2><span class="header-section-number">27.4</span> Code chunks</h2>
<p>To run code inside an R Markdown document, you need to insert a chunk. There are three ways to do so:</p>
<ol style="list-style-type: decimal">
<li><p>The keyboard shortcut Cmd/Ctrl + Alt + I</p></li>
<li><p>The “Insert” button icon in the editor toolbar.</p></li>
<li><p>By manually typing the chunk delimiters <code>```{r}</code> and <code>```</code>.</p></li>
</ol>
<p>Obviously, I’d recommend you learn the keyboard shortcut. It will save you a lot of time in the long run!</p>
<p>You can continue to run the code using the keyboard shortcut that by now (I hope!) you know and love: Cmd/Ctrl + Enter. However, chunks get a new keyboard shortcut: Cmd/Ctrl + Shift + Enter, which runs all the code in the chunk. Think of a chunk like a function. A chunk should be relatively self-contained, and focussed around a single task.</p>
<p>The following sections describe the chunk header which consists of <code>```{r</code>, followed by an optional chunk name, followed by comma separated options, followed by <code>}</code>. Next comes your R code and the chunk end is indicated by a final <code>```</code>.</p>
<div id="chunk-name" class="section level3">
<h3><span class="header-section-number">27.4.1</span> Chunk name</h3>
<p>Chunks can be given an optional name: <code>```{r by-name}</code>. This has three advantages:</p>
<ol style="list-style-type: decimal">
<li><p>You can more easily navigate to specific chunks using the drop-down
code navigator in the bottom-left of the script editor:</p>
<p><img src="screenshots/rmarkdown-chunk-nav.png" width="30%" style="display: block; margin: auto;" /></p></li>
<li><p>Graphics produced by the chunks will have useful names that make
them easier to use elsewhere. More on that in <a href="#other-important-options">other important options</a>.</p></li>
<li><p>You can set up networks of cached chunks to avoid re-performing expensive
computations on every run. More on that below.</p></li>
</ol>
<p>There is one chunk name that imbues special behaviour: <code>setup</code>. When you’re in a notebook mode, the chunk named setup will be run automatically once, before any other code is run.</p>
</div>
<div id="chunk-options" class="section level3">
<h3><span class="header-section-number">27.4.2</span> Chunk options</h3>
<p>Chunk output can be customised with <strong>options</strong>, arguments supplied to chunk header. Knitr provides almost 60 options that you can use to customize your code chunks. Here we’ll cover the most important chunk options that you’ll use frequently. You can see the full list at <a href="http://yihui.name/knitr/options/" class="uri">http://yihui.name/knitr/options/</a>.</p>
<p>The most important set of options controls if your code block is executed and what results are inserted in the finished report:</p>
<ul>
<li><p><code>eval = FALSE</code> prevents code from being evaluated. (And obviously if the
code is not run, no results will be generated). This is useful for
displaying example code, or for disabling a large block of code without
commenting each line.</p></li>
<li><p><code>include = FALSE</code> runs the code, but doesn’t show the code or results
in the final document. Use this for setup code that you don’t want
cluttering your report.</p></li>
<li><p><code>echo = FALSE</code> prevents code, but not the results from appearing in the
finished file. Use this when writing reports aimed at people who don’t
want to see the underlying R code.</p></li>
<li><p><code>message = FALSE</code> or <code>warning = FALSE</code> prevents messages or warnings
from appearing in the finished file.</p></li>
<li><p><code>results = 'hide'</code> hides printed output; <code>fig.show = 'hide'</code> hides
plots.</p></li>
<li><p><code>error = TRUE</code> causes the render to continue even if code returns an error.
This is rarely something you’ll want to include in the final version
of your report, but can be very useful if you need to debug exactly
what is going on inside your <code>.Rmd</code>. It’s also useful if you’re teaching R
and want to deliberately include an error. The default, <code>error = FALSE</code> causes
knitting to fail if there is a single error in the document.</p></li>
</ul>
<p>The following table summarises which types of output each option supressess:</p>
<table>
<thead>
<tr class="header">
<th>Option</th>
<th>Run code</th>
<th>Show code</th>
<th>Output</th>
<th>Plots</th>
<th>Messages</th>
<th>Warnings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>eval = FALSE</code></td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td><code>include = FALSE</code></td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td><code>echo = FALSE</code></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>results = &quot;hide&quot;</code></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>fig.show = &quot;hide&quot;</code></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>message = FALSE</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td><code>warning = FALSE</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<div id="table" class="section level3">
<h3><span class="header-section-number">27.4.3</span> Table</h3>
<p>By default, R Markdown prints data frames and matrices as you’d see them in the console:</p>
<pre class="sourceCode r"><code class="sourceCode r">mtcars[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, ]
<span class="co">#&gt;                    mpg cyl disp  hp drat   wt qsec vs am gear carb</span>
<span class="co">#&gt; Mazda RX4         21.0   6  160 110 3.90 2.62 16.5  0  1    4    4</span>
<span class="co">#&gt; Mazda RX4 Wag     21.0   6  160 110 3.90 2.88 17.0  0  1    4    4</span>
<span class="co">#&gt; Datsun 710        22.8   4  108  93 3.85 2.32 18.6  1  1    4    1</span>
<span class="co">#&gt; Hornet 4 Drive    21.4   6  258 110 3.08 3.21 19.4  1  0    3    1</span>
<span class="co">#&gt; Hornet Sportabout 18.7   8  360 175 3.15 3.44 17.0  0  0    3    2</span></code></pre>
<p>If you prefer that data be displayed with additional formatting you can use the <code>knitr::kable</code> function. The code below generates Table <a href="#tab:kable">27.1</a>.</p>
<pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span><span class="kw">kable</span>(
  mtcars[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, ], 
  <span class="dt">caption =</span> <span class="st">&quot;A knitr kable.&quot;</span>
)</code></pre>
<table>
<caption><span id="tab:kable">Table 27.1: </span>A knitr kable.</caption>
<thead>
<tr class="header">
<th></th>
<th align="right">mpg</th>
<th align="right">cyl</th>
<th align="right">disp</th>
<th align="right">hp</th>
<th align="right">drat</th>
<th align="right">wt</th>
<th align="right">qsec</th>
<th align="right">vs</th>
<th align="right">am</th>
<th align="right">gear</th>
<th align="right">carb</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mazda RX4</td>
<td align="right">21.0</td>
<td align="right">6</td>
<td align="right">160</td>
<td align="right">110</td>
<td align="right">3.90</td>
<td align="right">2.62</td>
<td align="right">16.5</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td>Mazda RX4 Wag</td>
<td align="right">21.0</td>
<td align="right">6</td>
<td align="right">160</td>
<td align="right">110</td>
<td align="right">3.90</td>
<td align="right">2.88</td>
<td align="right">17.0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td>Datsun 710</td>
<td align="right">22.8</td>
<td align="right">4</td>
<td align="right">108</td>
<td align="right">93</td>
<td align="right">3.85</td>
<td align="right">2.32</td>
<td align="right">18.6</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>Hornet 4 Drive</td>
<td align="right">21.4</td>
<td align="right">6</td>
<td align="right">258</td>
<td align="right">110</td>
<td align="right">3.08</td>
<td align="right">3.21</td>
<td align="right">19.4</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td>Hornet Sportabout</td>
<td align="right">18.7</td>
<td align="right">8</td>
<td align="right">360</td>
<td align="right">175</td>
<td align="right">3.15</td>
<td align="right">3.44</td>
<td align="right">17.0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>Read the documentation for <code>?knitr::kable</code> to see the other ways in which you can customise the table. For even deeper customisation, consider the <strong>xtable</strong>, <strong>stargazer</strong>, <strong>pander</strong>, <strong>tables</strong>, and <strong>ascii</strong> packages. Each provides a set of tools for returning formatted tables from R code.</p>
<p>There is also a rich set of options for controlling how figures are embedded. You’ll learn about these in <a href="#saving-your-plots">saving your plots</a>.</p>
</div>
<div id="caching" class="section level3">
<h3><span class="header-section-number">27.4.4</span> Caching</h3>
<p>Normally, each knit of a document starts from a completely clean slate. This is great for reproducibility, because it ensures that you’ve captured every important computation in code. However, it can be painful if you have some computations that take a long time. The solution is <code>cache = TRUE</code>. When set, this will save the output of the chunk to a specially named file on disk. On subsequent runs, knitr will check to see if the code has changed, and if it hasn’t, it will reuse the cached results.</p>
<p>The caching system must be used with care, because by default it is based on the code only, not its dependencies. For example, here the <code>processed_data</code> chunk depends on the <code>raw_data</code> chunk:</p>
<pre><code>```{r raw_data}
rawdata &lt;- readr::read_csv(&quot;a_very_large_file.csv&quot;)
```

```{r processed_data, cache = TRUE}
processed_data &lt;- rawdata %&gt;% 
  filter(!is.na(import_var)) %&gt;% 
  mutate(new_variable = complicated_transformation(x, y, z))
```</code></pre>
<p>Caching the <code>processed_data</code> chunk means that it will get re-run if the dplyr pipeline is changed, but it won’t get rerun if the <code>read_csv()</code> call changes. You can avoid that problem with the <code>dependson</code> chunk option:</p>
<pre><code>```{r processed_data, cache = TRUE, dependson = &quot;raw_data&quot;}
processed_data &lt;- rawdata %&gt;% 
  filter(!is.na(import_var)) %&gt;% 
  mutate(new_variable = complicated_transformation(x, y, z))
```</code></pre>
<p><code>dependson</code> should contain a character vector of <em>every</em> chunk that the cached chunk depends on. Knitr will update the results for the cached chunk whenever it detects that one of its dependencies have changed.</p>
<p>Note that the chunks won’t update if <code>a_very_large_file.csv</code> changes, because knitr caching only tracks changes within the <code>.Rmd</code> file. If you want to also track changes to that file you can use the <code>cache.extra</code> option. This is an arbitrary R expression that will invalidate the cache whenever it changes. A good function to use is <code>file.info()</code>: it returns a bunch of information about the file including when it was last modified. Then you can write:</p>
<pre><code>```{r raw_data, cache.extra = file.info(&quot;a_very_large_file.csv&quot;)}
rawdata &lt;- readr::read_csv(&quot;a_very_large_file.csv&quot;)
```</code></pre>
<p>As your caching strategies get progressively more complicated, it’s a good idea to regularly clear out all your caches with <code>knitr::clean_cache()</code>.</p>
<p>I’ve used the advice of David Robinson<span id="fn27" class="footnote" data-pagedown-footnote-number="27" style="white-space: pre-line;"><a href="https://twitter.com/drob/status/738786604731490304" class="uri">https://twitter.com/drob/status/738786604731490304</a></span> to name these chunks: each chunk is named after the primary object that it creates. This makes it easier to understand the <code>dependson</code> specification.</p>
</div>
<div id="global-options" class="section level3">
<h3><span class="header-section-number">27.4.5</span> Global options</h3>
<p>As you work more with knitr, you will discover that some of the default chunk options don’t fit your needs and you want to change them. You can do this by calling <code>knitr::opts_chunk$set()</code> in a code chunk. For example, when writing books and tutorials I set:</p>
<pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span>opts_chunk<span class="op">$</span><span class="kw">set</span>(
  <span class="dt">comment =</span> <span class="st">&quot;#&gt;&quot;</span>,
  <span class="dt">collapse =</span> <span class="ot">TRUE</span>
)</code></pre>
<p>This uses my preferred comment formatting, and ensures that the code and output are kept closely entwined. On the other hand, if you were preparing a report, you might set:</p>
<pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span>opts_chunk<span class="op">$</span><span class="kw">set</span>(
  <span class="dt">echo =</span> <span class="ot">FALSE</span>
)</code></pre>
<p>That will hide the code by default, so only showing the chunks you deliberately choose to show (with <code>echo = TRUE</code>). You might consider setting <code>message = FALSE</code> and <code>warning = FALSE</code>, but that would make it harder to debug problems because you wouldn’t see any messages in the final document.</p>
</div>
<div id="inline-code" class="section level3">
<h3><span class="header-section-number">27.4.6</span> Inline code</h3>
<p>There is one other way to embed R code into an R Markdown document: directly into the text, with: <code>`r `</code>. This can be very useful if you mention properties of your data in the text. For example, in the example document I used at the start of the chapter I had:</p>
<blockquote>
<p>We have data about <code>`r nrow(diamonds)`</code> diamonds.
Only <code>`r nrow(diamonds) - nrow(smaller)`</code> are larger
than 2.5 carats. The distribution of the remainder is shown below:</p>
</blockquote>
<p>When the report is knit, the results of these computations are inserted into the text:</p>
<blockquote>
<p>We have data about 53940 diamonds. Only 126 are larger than
2.5 carats. The distribution of the remainder is shown below:</p>
</blockquote>
<p>When inserting numbers into text, <code>format()</code> is your friend. It allows you to set the number of <code>digits</code> so you don’t print to a ridiculous degree of accuracy, and a <code>big.mark</code> to make numbers easier to read. I’ll often combine these into a helper function:</p>
<pre class="sourceCode r"><code class="sourceCode r">comma &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">format</span>(x, <span class="dt">digits =</span> <span class="dv">2</span>, <span class="dt">big.mark =</span> <span class="st">&quot;,&quot;</span>)
<span class="kw">comma</span>(<span class="dv">3452345</span>)
<span class="co">#&gt; [1] &quot;3,452,345&quot;</span>
<span class="kw">comma</span>(.<span class="dv">12358124331</span>)
<span class="co">#&gt; [1] &quot;0.12&quot;</span></code></pre>
</div>
<div id="exercises-70" class="section level3">
<h3><span class="header-section-number">27.4.7</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Add a section that explores how diamond sizes vary by cut, colour,
and clarity. Assume you’re writing a report for someone who doesn’t know
R, and instead of setting <code>echo = FALSE</code> on each chunk, set a global
option.</p></li>
<li><p>Download <code>diamond-sizes.Rmd</code> from
<a href="https://github.com/hadley/r4ds/tree/master/rmarkdown" class="uri">https://github.com/hadley/r4ds/tree/master/rmarkdown</a>. Add a section
that describes the largest 20 diamonds, including a table that displays
their most important attributes.</p></li>
<li><p>Modify <code>diamonds-sizes.Rmd</code> to use <code>comma()</code> to produce nicely
formatted output. Also include the percentage of diamonds that are
larger than 2.5 carats.</p></li>
<li><p>Set up a network of chunks where <code>d</code> depends on <code>c</code> and <code>b</code>, and
both <code>b</code> and <code>c</code> depend on <code>a</code>. Have each chunk print <code>lubridate::now()</code>,
set <code>cache = TRUE</code>, then verify your understanding of caching.</p></li>
</ol>
</div>
</div>
<div id="troubleshooting" class="section level2">
<h2><span class="header-section-number">27.5</span> Troubleshooting</h2>
<p>Troubleshooting R Markdown documents can be challenging because you are no longer in an interactive R environment, and you will need to learn some new tricks. The first thing you should always try is to recreate the problem in an interactive session. Restart R, then “Run all chunks” (either from Code menu, under Run region), or with the keyboard shortcut Ctrl + Alt + R. If you’re lucky, that will recreate the problem, and you can figure out what’s going on interactively.</p>
<p>If that doesn’t help, there must be something different between your interactive environment and the R markdown environment. You’re going to need to systematically explore the options. The most common difference is the working directory: the working directory of an R Markdown is the directory in which it lives. Check the working directory is what you expect by including <code>getwd()</code> in a chunk.</p>
<p>Next, brainstorm all the things that might cause the bug. You’ll need to systematically check that they’re the same in your R session and your R markdown session. The easiest way to do that is to set <code>error = TRUE</code> on the chunk causing the problem, then use <code>print()</code> and <code>str()</code> to check that settings are as you expect.</p>
</div>
<div id="yaml-header" class="section level2">
<h2><span class="header-section-number">27.6</span> YAML header</h2>
<p>You can control many other “whole document” settings by tweaking the parameters of the YAML header. You might wonder what YAML stands for: it’s “yet another markup language”, which is designed for representing hierarchical data in a way that’s easy for humans to read and write. R Markdown uses it to control many details of the output. Here we’ll discuss two: document parameters and bibliographies.</p>
<div id="parameters" class="section level3">
<h3><span class="header-section-number">27.6.1</span> Parameters</h3>
<p>R Markdown documents can include one or more parameters whose values can be set when you render the report. Parameters are useful when you want to re-render the same report with distinct values for various key inputs. For example, you might be producing sales reports per branch, exam results by student, or demographic summaries by country. To declare one or more parameters, use the <code>params</code> field.</p>
<p>This example uses a <code>my_class</code> parameter to determine which class of cars to display:</p>
<pre><code>---
output: html_document
params:
  my_class: &quot;suv&quot;
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)

class &lt;- mpg %&gt;% filter(class == params$my_class)
```

# Fuel economy for `r params$my_class`s

```{r, message = FALSE}
ggplot(class, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```</code></pre>
<p>As you can see, parameters are available within the code chunks as a read-only list named <code>params</code>.</p>
<p>You can write atomic vectors directly into the YAML header. You can also run arbitrary R expressions by prefacing the parameter value with <code>!r</code>. This is a good way to specify date/time parameters.</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">params:</span>
  <span class="fu">start:</span><span class="at"> !r lubridate::ymd(&quot;2015-01-01&quot;)</span>
  <span class="fu">snapshot:</span><span class="at"> !r lubridate::ymd_hms(&quot;2015-01-01 12:30:00&quot;)</span></code></pre>
<p>In RStudio, you can click the “Knit with Parameters” option in the Knit dropdown menu to set parameters, render, and preview the report in a single user friendly step. You can customise the dialog by setting other options in the header. See <a href="http://rmarkdown.rstudio.com/developer_parameterized_reports.html#parameter_user_interfaces" class="uri">http://rmarkdown.rstudio.com/developer_parameterized_reports.html#parameter_user_interfaces</a> for more details.</p>
<p>Alternatively, if you need to produce many such paramterised reports, you can call <code>rmarkdown::render()</code> with a list of <code>params</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">rmarkdown<span class="op">::</span><span class="kw">render</span>(<span class="st">&quot;fuel-economy.Rmd&quot;</span>, <span class="dt">params =</span> <span class="kw">list</span>(<span class="dt">my_class =</span> <span class="st">&quot;suv&quot;</span>))</code></pre>
<p>This is particularly powerful in conjunction with <code>purrr:pwalk()</code>. The following example creates a report for each value of <code>class</code> found in <code>mpg</code>. First we create a data frame that has one row for each class, giving the <code>filename</code> of the report and the <code>params</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">reports &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">class =</span> <span class="kw">unique</span>(mpg<span class="op">$</span>class),
  <span class="dt">filename =</span> stringr<span class="op">::</span><span class="kw">str_c</span>(<span class="st">&quot;fuel-economy-&quot;</span>, class, <span class="st">&quot;.html&quot;</span>),
  <span class="dt">params =</span> purrr<span class="op">::</span><span class="kw">map</span>(class, <span class="op">~</span><span class="st"> </span><span class="kw">list</span>(<span class="dt">my_class =</span> .))
)
reports
<span class="co">#&gt; # A tibble: 7 x 3</span>
<span class="co">#&gt;   class   filename                  params    </span>
<span class="co">#&gt;   &lt;chr&gt;   &lt;chr&gt;                     &lt;list&gt;    </span>
<span class="co">#&gt; 1 compact fuel-economy-compact.html &lt;list [1]&gt;</span>
<span class="co">#&gt; 2 midsize fuel-economy-midsize.html &lt;list [1]&gt;</span>
<span class="co">#&gt; 3 suv     fuel-economy-suv.html     &lt;list [1]&gt;</span>
<span class="co">#&gt; 4 2seater fuel-economy-2seater.html &lt;list [1]&gt;</span>
<span class="co">#&gt; 5 minivan fuel-economy-minivan.html &lt;list [1]&gt;</span>
<span class="co">#&gt; 6 pickup  fuel-economy-pickup.html  &lt;list [1]&gt;</span>
<span class="co">#&gt; # … with 1 more row</span></code></pre>
<p>Then we match the column names to the argument names of <code>render()</code>, and use purrr’s <strong>parallel</strong> walk to call <code>render()</code> once for each row:</p>
<pre class="sourceCode r"><code class="sourceCode r">reports <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="dt">output_file =</span> filename, params) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>purrr<span class="op">::</span><span class="kw">pwalk</span>(rmarkdown<span class="op">::</span>render, <span class="dt">input =</span> <span class="st">&quot;fuel-economy.Rmd&quot;</span>)</code></pre>
</div>
<div id="bibliographies-and-citations" class="section level3">
<h3><span class="header-section-number">27.6.2</span> Bibliographies and Citations</h3>
<p>Pandoc can automatically generate citations and a bibliography in a number of styles. To use this feature, specify a bibliography file using the <code>bibliography</code> field in your file’s header. The field should contain a path from the directory that contains your .Rmd file to the file that contains the bibliography file:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">bibliography:</span><span class="at"> rmarkdown.bib</span></code></pre>
<p>You can use many common bibliography formats including BibLaTeX, BibTeX, endnote, medline.</p>
<p>To create a citation within your .Rmd file, use a key composed of ‘@’ + the citation identifier from the bibliography file. Then place the citation in square brackets. Here are some examples:</p>
<pre class="sourceCode markdown"><code class="sourceCode markdown">Separate multiple citations with a <span class="bn">`;`</span>: Blah blah [@smith04; @doe99].

You can add arbitrary comments inside the square brackets: 
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Remove the square brackets to create an in-text citation: @smith04 
says blah, or @smith04 [p. 33] says blah.

Add a <span class="bn">`-`</span> before the citation to suppress the author&#39;s name: 
Smith says blah [-@smith04].</code></pre>
<p>When R Markdown renders your file, it will build and append a bibliography to the end of your document. The bibliography will contain each of the cited references from your bibliography file, but it will not contain a section heading. As a result it is common practice to end your file with a section header for the bibliography, such as <code># References</code> or <code># Bibliography</code>.</p>
<p>You can change the style of your citations and bibliography by referencing a CSL (citation style language) file in the <code>csl</code> field:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">bibliography:</span><span class="at"> rmarkdown.bib</span>
<span class="fu">csl:</span><span class="at"> apa.csl</span></code></pre>
<p>As with the bibliography field, your csl file should contain a path to the file. Here I assume that the csl file is in the same directory as the .Rmd file. A good place to find CSL style files for common bibliography styles is <a href="http://github.com/citation-style-language/styles" class="uri">http://github.com/citation-style-language/styles</a>.</p>
</div>
</div>
<div id="learning-more-3" class="section level2">
<h2><span class="header-section-number">27.7</span> Learning more</h2>
<p>R Markdown is still relatively young, and is still growing rapidly. The best place to stay on top of innovations is the official R Markdown website: <a href="http://rmarkdown.rstudio.com" class="uri">http://rmarkdown.rstudio.com</a>.</p>
<p>There are two important topics that we haven’t covered here: collaboration, and the details of accurately communicating your ideas to other humans. Collaboration is a vital part of modern data science, and you can make your life much easier by using version control tools, like Git and GitHub. We recommend two free resources that will teach you about Git:</p>
<ol style="list-style-type: decimal">
<li><p>“Happy Git with R”: a user friendly introduction to Git and GitHub from
R users, by Jenny Bryan. The book is freely available online:
<a href="http://happygitwithr.com" class="uri">http://happygitwithr.com</a></p></li>
<li><p>The “Git and GitHub” chapter of <em>R Packages</em>, by Hadley. You can also
read it for free online: <a href="http://r-pkgs.had.co.nz/git.html" class="uri">http://r-pkgs.had.co.nz/git.html</a>.</p></li>
</ol>
<p>I have also not touched on what you should actually write in order to clearly communicate the results of your analysis. To improve your writing, I highly recommend reading either <em>Style: Lessons in Clarity and Grace</em><span id="fn28" class="footnote" data-pagedown-footnote-number="28" style="white-space: pre-line;"><a href="https://amzn.com/0134080416" class="uri">https://amzn.com/0134080416</a></span> by Joseph M. Williams &amp; Joseph Bizup, or <em>The Sense of Structure: Writing from the Reader’s Perspective</em><span id="fn29" class="footnote" data-pagedown-footnote-number="29" style="white-space: pre-line;"><a href="https://amzn.com/0205296327" class="uri">https://amzn.com/0205296327</a></span> by George Gopen. Both books will help you understand the structure of sentences and paragraphs, and give you the tools to make your writing more clear. (These books are rather expensive if purchased new, but they’re used by many English classes so there are plenty of cheap second-hand copies). George Gopen also has a number of short articles on writing at <a href="https://www.georgegopen.com/the-litigation-articles.html" class="uri">https://www.georgegopen.com/the-litigation-articles.html</a>. They are aimed at lawyers, but almost everything applies to data scientists too.</p>
<!--chapter:end:rmarkdown.Rmd-->
</div>
</div>
<div id="graphics-for-communication" class="section level1">
<h1><span class="header-section-number">28</span> Graphics for communication</h1>
<div id="introduction-19" class="section level2">
<h2><span class="header-section-number">28.1</span> Introduction</h2>
<p>In <a href="#exploratory-data-analysis">exploratory data analysis</a>, you learned how to use plots as tools for <em>exploration</em>. When you make exploratory plots, you know—even before looking—which variables the plot will display. You made each plot for a purpose, could quickly look at it, and then move on to the next plot. In the course of most analyses, you’ll produce tens or hundreds of plots, most of which are immediately thrown away.</p>
<p>Now that you understand your data, you need to <em>communicate</em> your understanding to others. Your audience will likely not share your background knowledge and will not be deeply invested in the data. To help others quickly build up a good mental model of the data, you will need to invest considerable effort in making your plots as self-explanatory as possible. In this chapter, you’ll learn some of the tools that ggplot2 provides to do so.</p>
<p>This chapter focuses on the tools you need to create good graphics. I assume that you know what you want, and just need to know how to do it. For that reason, I highly recommend pairing this chapter with a good general visualisation book. I particularly like <em>The Truthful Art</em><span id="fn30" class="footnote" data-pagedown-footnote-number="30" style="white-space: pre-line;"><a href="https://amzn.com/0321934075" class="uri">https://amzn.com/0321934075</a></span>, by Albert Cairo. It doesn’t teach the mechanics of creating visualisations, but instead focuses on what you need to think about in order to create effective graphics.</p>
<div id="prerequisites-19" class="section level3">
<h3><span class="header-section-number">28.1.1</span> Prerequisites</h3>
<p>In this chapter, we’ll focus once again on ggplot2. We’ll also use a little dplyr for data manipulation, and a few ggplot2 extension packages, including <strong>ggrepel</strong> and <strong>viridis</strong>. Rather than loading those extensions here, we’ll refer to their functions explicitly, using the <code>::</code> notation. This will help make it clear which functions are built into ggplot2, and which come from other packages. Don’t forget you’ll need to install those packages with <code>install.packages()</code> if you don’t already have them.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)</code></pre>
</div>
</div>
<div id="label" class="section level2">
<h2><span class="header-section-number">28.2</span> Label</h2>
<p>The easiest place to start when turning an exploratory graphic into an expository graphic is with good labels. You add labels with the <code>labs()</code> function. This example adds a plot title:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Fuel efficiency generally decreases with engine size&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The purpose of a plot title is to summarise the main finding. Avoid titles that just describe what the plot is, e.g. “A scatterplot of engine displacement vs. fuel economy”.</p>
<p>If you need to add more text, there are two other useful labels that you can use in ggplot2 2.2.0 and above (which should be available by the time you’re reading this book):</p>
<ul>
<li><p><code>subtitle</code> adds additional detail in a smaller font beneath the title.</p></li>
<li><p><code>caption</code> adds text at the bottom right of the plot, often used to describe
the source of the data.</p></li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(
    <span class="dt">title =</span> <span class="st">&quot;Fuel efficiency generally decreases with engine size&quot;</span>,
    <span class="dt">subtitle =</span> <span class="st">&quot;Two seaters (sports cars) are an exception because of their light weight&quot;</span>,
    <span class="dt">caption =</span> <span class="st">&quot;Data from fueleconomy.gov&quot;</span>
  )</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can also use <code>labs()</code> to replace the axis and legend titles. It’s usually a good idea to replace short variable names with more detailed descriptions, and to include the units.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(
    <span class="dt">x =</span> <span class="st">&quot;Engine displacement (L)&quot;</span>,
    <span class="dt">y =</span> <span class="st">&quot;Highway fuel economy (mpg)&quot;</span>,
    <span class="dt">colour =</span> <span class="st">&quot;Car type&quot;</span>
  )</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-5-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>It’s possible to use mathematical equations instead of text strings. Just switch <code>&quot;&quot;</code> out for <code>quote()</code> and read about the available options in <code>?plotmath</code>:</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">runif</span>(<span class="dv">10</span>),
  <span class="dt">y =</span> <span class="kw">runif</span>(<span class="dv">10</span>)
)
<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(
    <span class="dt">x =</span> <span class="kw">quote</span>(<span class="kw">sum</span>(x[i] <span class="op">^</span><span class="st"> </span><span class="dv">2</span>, i <span class="op">==</span><span class="st"> </span><span class="dv">1</span>, n)),
    <span class="dt">y =</span> <span class="kw">quote</span>(alpha <span class="op">+</span><span class="st"> </span>beta <span class="op">+</span><span class="st"> </span><span class="kw">frac</span>(delta, theta))
  )</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-6-1.png" width="50%" style="display: block; margin: auto;" /></p>
<div id="exercises-71" class="section level3">
<h3><span class="header-section-number">28.2.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Create one plot on the fuel economy data with customised <code>title</code>,
<code>subtitle</code>, <code>caption</code>, <code>x</code>, <code>y</code>, and <code>colour</code> labels.</p></li>
<li><p>The <code>geom_smooth()</code> is somewhat misleading because the <code>hwy</code> for
large engines is skewed upwards due to the inclusion of lightweight
sports cars with big engines. Use your modelling tools to fit and display
a better model.</p></li>
<li><p>Take an exploratory graphic that you’ve created in the last month, and add
informative titles to make it easier for others to understand.</p></li>
</ol>
</div>
</div>
<div id="annotations" class="section level2">
<h2><span class="header-section-number">28.3</span> Annotations</h2>
<p>In addition to labelling major components of your plot, it’s often useful to label individual observations or groups of observations. The first tool you have at your disposal is <code>geom_text()</code>. <code>geom_text()</code> is similar to <code>geom_point()</code>, but it has an additional aesthetic: <code>label</code>. This makes it possible to add textual labels to your plots.</p>
<p>There are two possible sources of labels. First, you might have a tibble that provides labels. The plot below isn’t terribly useful, but it illustrates a useful approach: pull out the most efficient car in each class with dplyr, and then label it on the plot:</p>
<pre class="sourceCode r"><code class="sourceCode r">best_in_class &lt;-<span class="st"> </span>mpg <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(class) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">row_number</span>(<span class="kw">desc</span>(hwy)) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>)

<span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> model), <span class="dt">data =</span> best_in_class)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>This is hard to read because the labels overlap with each other, and with the points. We can make things a little better by switching to <code>geom_label()</code> which draws a rectangle behind the text. We also use the <code>nudge_y</code> parameter to move the labels slightly above the corresponding points:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_label</span>(<span class="kw">aes</span>(<span class="dt">label =</span> model), <span class="dt">data =</span> best_in_class, <span class="dt">nudge_y =</span> <span class="dv">2</span>, <span class="dt">alpha =</span> <span class="fl">0.5</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>That helps a bit, but if you look closely in the top-left hand corner, you’ll notice that there are two labels practically on top of each other. This happens because the highway mileage and displacement for the best cars in the compact and subcompact categories are exactly the same. There’s no way that we can fix these by applying the same transformation for every label. Instead, we can use the <strong>ggrepel</strong> package by Kamil Slowikowski. This useful package will automatically adjust labels so that they don’t overlap:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>, <span class="dt">shape =</span> <span class="dv">1</span>, <span class="dt">data =</span> best_in_class) <span class="op">+</span>
<span class="st">  </span>ggrepel<span class="op">::</span><span class="kw">geom_label_repel</span>(<span class="kw">aes</span>(<span class="dt">label =</span> model), <span class="dt">data =</span> best_in_class)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note another handy technique used here: I added a second layer of large, hollow points to highlight the points that I’ve labelled.</p>
<p>You can sometimes use the same idea to replace the legend with labels placed directly on the plot. It’s not wonderful for this plot, but it isn’t too bad. (<code>theme(legend.position = &quot;none&quot;</code>) turns the legend off — we’ll talk about it more shortly.)</p>
<pre class="sourceCode r"><code class="sourceCode r">class_avg &lt;-<span class="st"> </span>mpg <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(class) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">displ =</span> <span class="kw">median</span>(displ),
    <span class="dt">hwy =</span> <span class="kw">median</span>(hwy)
  )

<span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy, <span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span>ggrepel<span class="op">::</span><span class="kw">geom_label_repel</span>(<span class="kw">aes</span>(<span class="dt">label =</span> class),
    <span class="dt">data =</span> class_avg,
    <span class="dt">size =</span> <span class="dv">6</span>,
    <span class="dt">label.size =</span> <span class="dv">0</span>,
    <span class="dt">segment.color =</span> <span class="ot">NA</span>
  ) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;none&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Alternatively, you might just want to add a single label to the plot, but you’ll still need to create a data frame. Often, you want the label in the corner of the plot, so it’s convenient to create a new data frame using <code>summarise()</code> to compute the maximum values of x and y.</p>
<pre class="sourceCode r"><code class="sourceCode r">label &lt;-<span class="st"> </span>mpg <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarise</span>(
    <span class="dt">displ =</span> <span class="kw">max</span>(displ),
    <span class="dt">hwy =</span> <span class="kw">max</span>(hwy),
    <span class="dt">label =</span> <span class="st">&quot;Increasing engine size is </span><span class="ch">\n</span><span class="st">related to decreasing fuel economy.&quot;</span>
  )

<span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> label), <span class="dt">data =</span> label, <span class="dt">vjust =</span> <span class="st">&quot;top&quot;</span>, <span class="dt">hjust =</span> <span class="st">&quot;right&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you want to place the text exactly on the borders of the plot, you can use <code>+Inf</code> and <code>-Inf</code>. Since we’re no longer computing the positions from <code>mpg</code>, we can use <code>tibble()</code> to create the data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r">label &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">displ =</span> <span class="ot">Inf</span>,
  <span class="dt">hwy =</span> <span class="ot">Inf</span>,
  <span class="dt">label =</span> <span class="st">&quot;Increasing engine size is </span><span class="ch">\n</span><span class="st">related to decreasing fuel economy.&quot;</span>
)

<span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_text</span>(<span class="kw">aes</span>(<span class="dt">label =</span> label), <span class="dt">data =</span> label, <span class="dt">vjust =</span> <span class="st">&quot;top&quot;</span>, <span class="dt">hjust =</span> <span class="st">&quot;right&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>In these examples, I manually broke the label up into lines using <code>&quot;\n&quot;</code>. Another approach is to use <code>stringr::str_wrap()</code> to automatically add line breaks, given the number of characters you want per line:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;Increasing engine size is related to decreasing fuel economy.&quot;</span> <span class="op">%&gt;%</span>
<span class="st">  </span>stringr<span class="op">::</span><span class="kw">str_wrap</span>(<span class="dt">width =</span> <span class="dv">40</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">writeLines</span>()
<span class="co">#&gt; Increasing engine size is related to</span>
<span class="co">#&gt; decreasing fuel economy.</span></code></pre>
<p>Note the use of <code>hjust</code> and <code>vjust</code> to control the alignment of the label. Figure <a href="#fig:just">28.1</a> shows all nine possible combinations.</p>
<div class="figure" style="text-align: center"><span id="fig:just"></span>
<img src="communicate-plots_files/figure-html/just-1.png" alt="All nine combinations of `hjust` and `vjust`." width="60%" />
<p class="caption">
Figure 28.1: All nine combinations of <code>hjust</code> and <code>vjust</code>.
</p>
</div>
<p>Remember, in addition to <code>geom_text()</code>, you have many other geoms in ggplot2 available to help annotate your plot. A few ideas:</p>
<ul>
<li><p>Use <code>geom_hline()</code> and <code>geom_vline()</code> to add reference lines. I often make
them thick (<code>size = 2</code>) and white (<code>colour = white</code>), and draw them
underneath the primary data layer. That makes them easy to see, without
drawing attention away from the data.</p></li>
<li><p>Use <code>geom_rect()</code> to draw a rectangle around points of interest. The
boundaries of the rectangle are defined by aesthetics <code>xmin</code>, <code>xmax</code>,
<code>ymin</code>, <code>ymax</code>.</p></li>
<li><p>Use <code>geom_segment()</code> with the <code>arrow</code> argument to draw attention
to a point with an arrow. Use aesthetics <code>x</code> and <code>y</code> to define the
starting location, and <code>xend</code> and <code>yend</code> to define the end location.</p></li>
</ul>
<p>The only limit is your imagination (and your patience with positioning annotations to be aesthetically pleasing)!</p>
<div id="exercises-72" class="section level3">
<h3><span class="header-section-number">28.3.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Use <code>geom_text()</code> with infinite positions to place text at the
four corners of the plot.</p></li>
<li><p>Read the documentation for <code>annotate()</code>. How can you use it to add a text
label to a plot without having to create a tibble?</p></li>
<li><p>How do labels with <code>geom_text()</code> interact with faceting? How can you
add a label to a single facet? How can you put a different label in
each facet? (Hint: think about the underlying data.)</p></li>
<li><p>What arguments to <code>geom_label()</code> control the appearance of the background
box?</p></li>
<li><p>What are the four arguments to <code>arrow()</code>? How do they work? Create a series
of plots that demonstrate the most important options.</p></li>
</ol>
</div>
</div>
<div id="scales" class="section level2">
<h2><span class="header-section-number">28.4</span> Scales</h2>
<p>The third way you can make your plot better for communication is to adjust the scales. Scales control the mapping from data values to things that you can perceive. Normally, ggplot2 automatically adds scales for you. For example, when you type:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class))</code></pre>
<p>ggplot2 automatically adds default scales behind the scenes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_continuous</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_y_continuous</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_discrete</span>()</code></pre>
<p>Note the naming scheme for scales: <code>scale_</code> followed by the name of the aesthetic, then <code>_</code>, then the name of the scale. The default scales are named according to the type of variable they align with: continuous, discrete, datetime, or date. There are lots of non-default scales which you’ll learn about below.</p>
<p>The default scales have been carefully chosen to do a good job for a wide range of inputs. Nevertheless, you might want to override the defaults for two reasons:</p>
<ul>
<li><p>You might want to tweak some of the parameters of the default scale.
This allows you to do things like change the breaks on the axes, or the
key labels on the legend.</p></li>
<li><p>You might want to replace the scale altogether, and use a completely
different algorithm. Often you can do better than the default because
you know more about the data.</p></li>
</ul>
<div id="axis-ticks-and-legend-keys" class="section level3">
<h3><span class="header-section-number">28.4.1</span> Axis ticks and legend keys</h3>
<p>There are two primary arguments that affect the appearance of the ticks on the axes and the keys on the legend: <code>breaks</code> and <code>labels</code>. Breaks controls the position of the ticks, or the values associated with the keys. Labels controls the text label associated with each tick/key. The most common use of <code>breaks</code> is to override the default choice:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">breaks =</span> <span class="kw">seq</span>(<span class="dv">15</span>, <span class="dv">40</span>, <span class="dt">by =</span> <span class="dv">5</span>))</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can use <code>labels</code> in the same way (a character vector the same length as <code>breaks</code>), but you can also set it to <code>NULL</code> to suppress the labels altogether. This is useful for maps, or for publishing plots where you can’t share the absolute numbers.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_continuous</span>(<span class="dt">labels =</span> <span class="ot">NULL</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">labels =</span> <span class="ot">NULL</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>You can also use <code>breaks</code> and <code>labels</code> to control the appearance of legends. Collectively axes and legends are called <strong>guides</strong>. Axes are used for x and y aesthetics; legends are used for everything else.</p>
<p>Another use of <code>breaks</code> is when you have relatively few data points and want to highlight exactly where the observations occur. For example, take this plot that shows when each US president started and ended their term.</p>
<pre class="sourceCode r"><code class="sourceCode r">presidential <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">id =</span> <span class="dv">33</span> <span class="op">+</span><span class="st"> </span><span class="kw">row_number</span>()) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(start, id)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_segment</span>(<span class="kw">aes</span>(<span class="dt">xend =</span> end, <span class="dt">yend =</span> id)) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_x_date</span>(<span class="ot">NULL</span>, <span class="dt">breaks =</span> presidential<span class="op">$</span>start, <span class="dt">date_labels =</span> <span class="st">&quot;&#39;%y&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Note that the specification of breaks and labels for date and datetime scales is a little different:</p>
<ul>
<li><p><code>date_labels</code> takes a format specification, in the same form as
<code>parse_datetime()</code>.</p></li>
<li><p><code>date_breaks</code> (not shown here), takes a string like “2 days” or “1 month”.</p></li>
</ul>
</div>
<div id="legend-layout" class="section level3">
<h3><span class="header-section-number">28.4.2</span> Legend layout</h3>
<p>You will most often use <code>breaks</code> and <code>labels</code> to tweak the axes. While they both also work for legends, there are a few other techniques you are more likely to use.</p>
<p>To control the overall position of the legend, you need to use a <code>theme()</code> setting. We’ll come back to themes at the end of the chapter, but in brief, they control the non-data parts of the plot. The theme setting <code>legend.position</code> controls where the legend is drawn:</p>
<pre class="sourceCode r"><code class="sourceCode r">base &lt;-<span class="st"> </span><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class))

base <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;left&quot;</span>)
base <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;top&quot;</span>)
base <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)
base <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;right&quot;</span>) <span class="co"># the default</span></code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-18-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-18-2.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-18-3.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-18-4.png" width="50%" /></p>
<p>You can also use <code>legend.position = &quot;none&quot;</code> to suppress the display of the legend altogether.</p>
<p>To control the display of individual legends, use <code>guides()</code> along with <code>guide_legend()</code> or <code>guide_colourbar()</code>. The following example shows two important settings: controlling the number of rows the legend uses with <code>nrow</code>, and overriding one of the aesthetics to make the points bigger. This is particularly useful if you have used a low <code>alpha</code> to display many points on a plot.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">guides</span>(<span class="dt">colour =</span> <span class="kw">guide_legend</span>(<span class="dt">nrow =</span> <span class="dv">1</span>, <span class="dt">override.aes =</span> <span class="kw">list</span>(<span class="dt">size =</span> <span class="dv">4</span>)))
<span class="co">#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</span></code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" /></p>
</div>
<div id="replacing-a-scale" class="section level3">
<h3><span class="header-section-number">28.4.3</span> Replacing a scale</h3>
<p>Instead of just tweaking the details a little, you can instead replace the scale altogether. There are two types of scales you’re mostly likely to want to switch out: continuous position scales and colour scales. Fortunately, the same principles apply to all the other aesthetics, so once you’ve mastered position and colour, you’ll be able to quickly pick up other scale replacements.</p>
<p>It’s very useful to plot transformations of your variable. For example, as we’ve seen in <a href="diamond-prices">diamond prices</a> it’s easier to see the precise relationship between <code>carat</code> and <code>price</code> if we log transform them:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(carat, price)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bin2d</span>()

<span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(<span class="kw">log10</span>(carat), <span class="kw">log10</span>(price))) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bin2d</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-20-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-20-2.png" width="50%" /></p>
<p>However, the disadvantage of this transformation is that the axes are now labelled with the transformed values, making it hard to interpret the plot. Instead of doing the transformation in the aesthetic mapping, we can instead do it with the scale. This is visually identical, except the axes are labelled on the original data scale.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(carat, price)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bin2d</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_y_log10</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>Another scale that is frequently customised is colour. The default categorical scale picks colours that are evenly spaced around the colour wheel. Useful alternatives are the ColorBrewer scales which have been hand tuned to work better for people with common types of colour blindness. The two plots below look similar, but there is enough difference in the shades of red and green that the dots on the right can be distinguished even by people with red-green colour blindness.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> drv))

<span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-22-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-22-2.png" width="50%" /></p>
<p>Don’t forget simpler techniques. If there are just a few colours, you can add a redundant shape mapping. This will also help ensure your plot is interpretable in black and white.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> drv, <span class="dt">shape =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_brewer</span>(<span class="dt">palette =</span> <span class="st">&quot;Set1&quot;</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>The ColorBrewer scales are documented online at <a href="http://colorbrewer2.org/" class="uri">http://colorbrewer2.org/</a> and made available in R via the <strong>RColorBrewer</strong> package, by Erich Neuwirth. Figure <a href="#fig:brewer">28.2</a> shows the complete list of all palettes. The sequential (top) and diverging (bottom) palettes are particularly useful if your categorical values are ordered, or have a “middle”. This often arises if you’ve used <code>cut()</code> to make a continuous variable into a categorical variable.</p>
<div class="figure" style="text-align: center"><span id="fig:brewer"></span>
<img src="communicate-plots_files/figure-html/brewer-1.png" alt="All ColourBrewer scales." width="70%" />
<p class="caption">
Figure 28.2: All ColourBrewer scales.
</p>
</div>
<p>When you have a predefined mapping between values and colours, use <code>scale_colour_manual()</code>. For example, if we map presidential party to colour, we want to use the standard mapping of red for Republicans and blue for Democrats:</p>
<pre class="sourceCode r"><code class="sourceCode r">presidential <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">id =</span> <span class="dv">33</span> <span class="op">+</span><span class="st"> </span><span class="kw">row_number</span>()) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(start, id, <span class="dt">colour =</span> party)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_segment</span>(<span class="kw">aes</span>(<span class="dt">xend =</span> end, <span class="dt">yend =</span> id)) <span class="op">+</span>
<span class="st">    </span><span class="kw">scale_colour_manual</span>(<span class="dt">values =</span> <span class="kw">c</span>(<span class="dt">Republican =</span> <span class="st">&quot;red&quot;</span>, <span class="dt">Democratic =</span> <span class="st">&quot;blue&quot;</span>))</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>For continuous colour, you can use the built-in <code>scale_colour_gradient()</code> or <code>scale_fill_gradient()</code>. If you have a diverging scale, you can use <code>scale_colour_gradient2()</code>. That allows you to give, for example, positive and negative values different colours. That’s sometimes also useful if you want to distinguish points above or below the mean.</p>
<p>Another option is <code>scale_colour_viridis()</code> provided by the <strong>viridis</strong> package. It’s a continuous analog of the categorical ColorBrewer scales. The designers, Nathaniel Smith and Stéfan van der Walt, carefully tailored a continuous colour scheme that has good perceptual properties. Here’s an example from the viridis vignette.</p>
<pre class="sourceCode r"><code class="sourceCode r">df &lt;-<span class="st"> </span><span class="kw">tibble</span>(
  <span class="dt">x =</span> <span class="kw">rnorm</span>(<span class="dv">10000</span>),
  <span class="dt">y =</span> <span class="kw">rnorm</span>(<span class="dv">10000</span>)
)
<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hex</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_fixed</span>()

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hex</span>() <span class="op">+</span>
<span class="st">  </span>viridis<span class="op">::</span><span class="kw">scale_fill_viridis</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_fixed</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-25-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-25-2.png" width="50%" /></p>
<p>Note that all colour scales come in two variety: <code>scale_colour_x()</code> and <code>scale_fill_x()</code> for the <code>colour</code> and <code>fill</code> aesthetics respectively (the colour scales are available in both UK and US spellings).</p>
</div>
<div id="exercises-73" class="section level3">
<h3><span class="header-section-number">28.4.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Why doesn’t the following code override the default scale?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(df, <span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hex</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_colour_gradient</span>(<span class="dt">low =</span> <span class="st">&quot;white&quot;</span>, <span class="dt">high =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_fixed</span>()</code></pre></li>
<li><p>What is the first argument to every scale? How does it compare to <code>labs()</code>?</p></li>
<li><p>Change the display of the presidential terms by:</p>
<ol style="list-style-type: decimal">
<li>Combining the two variants shown above.</li>
<li>Improving the display of the y axis.</li>
<li>Labelling each term with the name of the president.</li>
<li>Adding informative plot labels.</li>
<li>Placing breaks every 4 years (this is trickier than it seems!).</li>
</ol></li>
<li><p>Use <code>override.aes</code> to make the legend on the following plot easier to see.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(diamonds, <span class="kw">aes</span>(carat, price)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">colour =</span> cut), <span class="dt">alpha =</span> <span class="dv">1</span><span class="op">/</span><span class="dv">20</span>)</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-27-1.png" width="50%" style="display: block; margin: auto;" /></p></li>
</ol>
</div>
</div>
<div id="zooming" class="section level2">
<h2><span class="header-section-number">28.5</span> Zooming</h2>
<p>There are three ways to control the plot limits:</p>
<ol style="list-style-type: decimal">
<li>Adjusting what data are plotted</li>
<li>Setting the limits in each scale</li>
<li>Setting <code>xlim</code> and <code>ylim</code> in <code>coord_cartesian()</code></li>
</ol>
<p>To zoom in on a region of the plot, it’s generally best to use <code>coord_cartesian()</code>. Compare the following two plots:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="dt">mapping =</span> <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">coord_cartesian</span>(<span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">7</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">10</span>, <span class="dv">30</span>))

mpg <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(displ <span class="op">&gt;=</span><span class="st"> </span><span class="dv">5</span>, displ <span class="op">&lt;=</span><span class="st"> </span><span class="dv">7</span>, hwy <span class="op">&gt;=</span><span class="st"> </span><span class="dv">10</span>, hwy <span class="op">&lt;=</span><span class="st"> </span><span class="dv">30</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-28-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-28-2.png" width="50%" /></p>
<p>You can also set the <code>limits</code> on individual scales. Reducing the limits is basically equivalent to subsetting the data. It is generally more useful if you want <em>expand</em> the limits, for example, to match scales across different plots. For example, if we extract two classes of cars and plot them separately, it’s difficult to compare the plots because all three scales (the x-axis, the y-axis, and the colour aesthetic) have different ranges.</p>
<pre class="sourceCode r"><code class="sourceCode r">suv &lt;-<span class="st"> </span>mpg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(class <span class="op">==</span><span class="st"> &quot;suv&quot;</span>)
compact &lt;-<span class="st"> </span>mpg <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(class <span class="op">==</span><span class="st"> &quot;compact&quot;</span>)

<span class="kw">ggplot</span>(suv, <span class="kw">aes</span>(displ, hwy, <span class="dt">colour =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()

<span class="kw">ggplot</span>(compact, <span class="kw">aes</span>(displ, hwy, <span class="dt">colour =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-29-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-29-2.png" width="50%" /></p>
<p>One way to overcome this problem is to share scales across multiple plots, training the scales with the <code>limits</code> of the full data.</p>
<pre class="sourceCode r"><code class="sourceCode r">x_scale &lt;-<span class="st"> </span><span class="kw">scale_x_continuous</span>(<span class="dt">limits =</span> <span class="kw">range</span>(mpg<span class="op">$</span>displ))
y_scale &lt;-<span class="st"> </span><span class="kw">scale_y_continuous</span>(<span class="dt">limits =</span> <span class="kw">range</span>(mpg<span class="op">$</span>hwy))
col_scale &lt;-<span class="st"> </span><span class="kw">scale_colour_discrete</span>(<span class="dt">limits =</span> <span class="kw">unique</span>(mpg<span class="op">$</span>drv))

<span class="kw">ggplot</span>(suv, <span class="kw">aes</span>(displ, hwy, <span class="dt">colour =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span>x_scale <span class="op">+</span>
<span class="st">  </span>y_scale <span class="op">+</span>
<span class="st">  </span>col_scale

<span class="kw">ggplot</span>(compact, <span class="kw">aes</span>(displ, hwy, <span class="dt">colour =</span> drv)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span>x_scale <span class="op">+</span>
<span class="st">  </span>y_scale <span class="op">+</span>
<span class="st">  </span>col_scale</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-30-1.png" width="50%" /><img src="communicate-plots_files/figure-html/unnamed-chunk-30-2.png" width="50%" /></p>
<p>In this particular case, you could have simply used faceting, but this technique is useful more generally, if for instance, you want spread plots over multiple pages of a report.</p>
</div>
<div id="themes" class="section level2">
<h2><span class="header-section-number">28.6</span> Themes</h2>
<p>Finally, you can customise the non-data elements of your plot with a theme:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">color =</span> class)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>ggplot2 includes eight themes by default, as shown in Figure <a href="#fig:themes">28.3</a>. Many more are included in add-on packages like <strong>ggthemes</strong> (<a href="https://github.com/jrnold/ggthemes" class="uri">https://github.com/jrnold/ggthemes</a>), by Jeffrey Arnold.</p>
<div class="figure" style="text-align: center"><span id="fig:themes"></span>
<img src="images/visualization-themes.png" alt="The eight themes built-in to ggplot2." width="70%" />
<p class="caption">
Figure 28.3: The eight themes built-in to ggplot2.
</p>
</div>
<p>Many people wonder why the default theme has a grey background. This was a deliberate choice because it puts the data forward while still making the grid lines visible. The white grid lines are visible (which is important because they significantly aid position judgements), but they have little visual impact and we can easily tune them out. The grey background gives the plot a similar typographic colour to the text, ensuring that the graphics fit in with the flow of a document without jumping out with a bright white background. Finally, the grey background creates a continuous field of colour which ensures that the plot is perceived as a single visual entity.</p>
<p>It’s also possible to control individual components of each theme, like the size and colour of the font used for the y axis. Unfortunately, this level of detail is outside the scope of this book, so you’ll need to read the ggplot2 book<span id="fn31" class="footnote" data-pagedown-footnote-number="31" style="white-space: pre-line;"><a href="https://amzn.com/331924275X" class="uri">https://amzn.com/331924275X</a></span> for the full details. You can also create your own themes, if you are trying to match a particular corporate or journal style.</p>
</div>
<div id="saving-your-plots" class="section level2">
<h2><span class="header-section-number">28.7</span> Saving your plots</h2>
<p>There are two main ways to get your plots out of R and into your final write-up: <code>ggsave()</code> and knitr. <code>ggsave()</code> will save the most recent plot to disk:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggplot</span>(mpg, <span class="kw">aes</span>(displ, hwy)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>()</code></pre>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-32-1.png" width="70%" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">ggsave</span>(<span class="st">&quot;my-plot.pdf&quot;</span>)
<span class="co">#&gt; Saving 6 x 3.7 in image</span></code></pre>
<p>If you don’t specify the <code>width</code> and <code>height</code> they will be taken from the dimensions of the current plotting device. For reproducible code, you’ll want to specify them.</p>
<p>Generally, however, I think you should be assembling your final reports using R Markdown, so I want to focus on the important code chunk options that you should know about for graphics. You can learn more about <code>ggsave()</code> in the documentation.</p>
<div id="figure-sizing" class="section level3">
<h3><span class="header-section-number">28.7.1</span> Figure sizing</h3>
<p>The biggest challenge of graphics in R Markdown is getting your figures the right size and shape. There are five main options that control figure sizing: <code>fig.width</code>, <code>fig.height</code>, <code>fig.asp</code>, <code>out.width</code> and <code>out.height</code>. Image sizing is challenging because there are two sizes (the size of the figure created by R and the size at which it is inserted in the output document), and multiple ways of specifying the size (i.e., height, width, and aspect ratio: pick two of three).</p>
<p>I only ever use three of the five options:</p>
<ul>
<li><p>I find it most aesthetically pleasing for plots to have a consistent
width. To enforce this, I set <code>fig.width = 6</code> (6&quot;) and <code>fig.asp = 0.618</code>
(the golden ratio) in the defaults. Then in individual chunks, I only
adjust <code>fig.asp</code>.</p></li>
<li><p>I control the output size with <code>out.width</code> and set it to a percentage
of the line width. I default to <code>out.width = &quot;70%&quot;</code>
and <code>fig.align = &quot;center&quot;</code>. That give plots room to breathe, without taking
up too much space.</p></li>
<li><p>To put multiple plots in a single row I set the <code>out.width</code> to
<code>50%</code> for two plots, <code>33%</code> for 3 plots, or <code>25%</code> to 4 plots, and set
<code>fig.align = &quot;default&quot;</code>. Depending on what I’m trying to illustrate (
e.g. show data or show plot variations), I’ll also tweak <code>fig.width</code>, as
discussed below.</p></li>
</ul>
<p>If you find that you’re having to squint to read the text in your plot, you need to tweak <code>fig.width</code>. If <code>fig.width</code> is larger than the size the figure is rendered in the final doc, the text will be too small; if <code>fig.width</code> is smaller, the text will be too big. You’ll often need to do a little experimentation to figure out the right ratio between the <code>fig.width</code> and the eventual width in your document. To illustrate the principle, the following three plots have <code>fig.width</code> of 4, 6, and 8 respectively:</p>
<p><img src="communicate-plots_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" />
<img src="communicate-plots_files/figure-html/unnamed-chunk-36-1.png" width="70%" style="display: block; margin: auto;" />
<img src="communicate-plots_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" /></p>
<p>If you want to make sure the font size is consistent across all your figures, whenever you set <code>out.width</code>, you’ll also need to adjust <code>fig.width</code> to maintain the same ratio with your default <code>out.width</code>. For example, if your default <code>fig.width</code> is 6 and <code>out.width</code> is 0.7, when you set <code>out.width = &quot;50%&quot;</code> you’ll need to set <code>fig.width</code> to 4.3 (6 * 0.5 / 0.7).</p>
</div>
<div id="other-important-options" class="section level3">
<h3><span class="header-section-number">28.7.2</span> Other important options</h3>
<p>When mingling code and text, like I do in this book, I recommend setting <code>fig.show = &quot;hold&quot;</code> so that plots are shown after the code. This has the pleasant side effect of forcing you to break up large blocks of code with their explanations.</p>
<p>To add a caption to the plot, use <code>fig.cap</code>. In R Markdown this will change the figure from inline to “floating”.</p>
<p>If you’re producing PDF output, the default graphics type is PDF. This is a good default because PDFs are high quality vector graphics. However, they can produce very large and slow plots if you are displaying thousands of points. In that case, set <code>dev = &quot;png&quot;</code> to force the use of PNGs. They are slightly lower quality, but will be much more compact.</p>
<p>It’s a good idea to name code chunks that produce figures, even if you don’t routinely label other chunks. The chunk label is used to generate the file name of the graphic on disk, so naming your chunks makes it much easier to pick out plots and reuse in other circumstances (i.e. if you want to quickly drop a single plot into an email or a tweet).</p>
</div>
</div>
<div id="learning-more-4" class="section level2">
<h2><span class="header-section-number">28.8</span> Learning more</h2>
<p>The absolute best place to learn more is the ggplot2 book: <em>ggplot2: Elegant graphics for data analysis</em><span id="fn32" class="footnote" data-pagedown-footnote-number="32" style="white-space: pre-line;"><a href="https://amzn.com/331924275X" class="uri">https://amzn.com/331924275X</a></span>. It goes into much more depth about the underlying theory, and has many more examples of how to combine the individual pieces to solve practical problems. Unfortunately, the book is not available online for free, although you can find the source code at <a href="https://github.com/hadley/ggplot2-book" class="uri">https://github.com/hadley/ggplot2-book</a>.</p>
<p>Another great resource is the ggplot2 extensions guide <a href="http://www.ggplot2-exts.org/" class="uri">http://www.ggplot2-exts.org/</a>. This site lists many of the packages that extend ggplot2 with new geoms and scales. It’s a great place to start if you’re trying to do something that seems hard with ggplot2.</p>
<!--chapter:end:communicate-plots.Rmd-->
</div>
</div>
<div id="r-markdown-formats" class="section level1">
<h1><span class="header-section-number">29</span> R Markdown formats</h1>
<div id="introduction-20" class="section level2">
<h2><span class="header-section-number">29.1</span> Introduction</h2>
<p>So far you’ve seen R Markdown used to produce HTML documents. This chapter gives a brief overview of some of the many other types of output you can produce with R Markdown. There are two ways to set the output of a document:</p>
<ol style="list-style-type: decimal">
<li><p>Permanently, by modifying the YAML header:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">title:</span><span class="at"> </span><span class="st">&quot;Viridis Demo&quot;</span>
<span class="fu">output:</span><span class="at"> html_document</span></code></pre></li>
<li><p>Transiently, by calling <code>rmarkdown::render()</code> by hand:</p>
<pre class="sourceCode r"><code class="sourceCode r">rmarkdown<span class="op">::</span><span class="kw">render</span>(<span class="st">&quot;diamond-sizes.Rmd&quot;</span>, <span class="dt">output_format =</span> <span class="st">&quot;word_document&quot;</span>)</code></pre>
<p>This is useful if you want to programmatically produce multiple types of
output.</p></li>
</ol>
<p>RStudio’s knit button renders a file to the first format listed in its <code>output</code> field. You can render to additional formats by clicking the dropdown menu beside the knit button.</p>
<p><img src="screenshots/rmarkdown-knit.png" width="206" style="display: block; margin: auto;" /></p>
</div>
<div id="output-options" class="section level2">
<h2><span class="header-section-number">29.2</span> Output options</h2>
<p>Each output format is associated with an R function. You can either write <code>foo</code> or <code>pkg::foo</code>. If you omit <code>pkg</code>, the default is assumed to be rmarkdown. It’s important to know the name of the function that makes the output because that’s where you get help. For example, to figure out what parameters you can set with <code>html_document</code>, look at <code>?rmarkdown::html_document</code>.</p>
<p>To override the default parameter values, you need to use an expanded <code>output</code> field. For example, if you wanted to render an <code>html_document</code> with a floating table of contents, you’d use:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">output:</span>
  <span class="fu">html_document:</span>
    <span class="fu">toc:</span><span class="at"> true</span>
    <span class="fu">toc_float:</span><span class="at"> true</span></code></pre>
<p>You can even render to multiple outputs by supplying a list of formats:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">output:</span>
  <span class="fu">html_document:</span>
    <span class="fu">toc:</span><span class="at"> true</span>
    <span class="fu">toc_float:</span><span class="at"> true</span>
  <span class="fu">pdf_document:</span><span class="at"> default</span></code></pre>
<p>Note the special syntax if you don’t want to override any of the default options.</p>
</div>
<div id="documents" class="section level2">
<h2><span class="header-section-number">29.3</span> Documents</h2>
<p>The previous chapter focused on the default <code>html_document</code> output. There are a number of basic variations on that theme, generating different types of documents:</p>
<ul>
<li><p><code>pdf_document</code> makes a PDF with LaTeX (an open source document layout
system), which you’ll need to install. RStudio will prompt you if you
don’t already have it.</p></li>
<li><p><code>word_document</code> for Microsoft Word documents (<code>.docx</code>).</p></li>
<li><p><code>odt_document</code> for OpenDocument Text documents (<code>.odt</code>).</p></li>
<li><p><code>rtf_document</code> for Rich Text Format (<code>.rtf</code>) documents.</p></li>
<li><p><code>md_document</code> for a Markdown document. This isn’t typically useful by
itself, but you might use it if, for example, your corporate CMS or
lab wiki uses markdown.</p></li>
<li><p><code>github_document</code>: this is a tailored version of <code>md_document</code>
designed for sharing on GitHub.</p></li>
</ul>
<p>Remember, when generating a document to share with decision makers, you can turn off the default display of code by setting global options in the setup chunk:</p>
<pre class="sourceCode r"><code class="sourceCode r">knitr<span class="op">::</span>opts_chunk<span class="op">$</span><span class="kw">set</span>(<span class="dt">echo =</span> <span class="ot">FALSE</span>)</code></pre>
<p>For <code>html_document</code>s another option is to make the code chunks hidden by default, but visible with a click:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">output:</span>
  <span class="fu">html_document:</span>
    <span class="fu">code_folding:</span><span class="at"> hide</span></code></pre>
</div>
<div id="notebooks" class="section level2">
<h2><span class="header-section-number">29.4</span> Notebooks</h2>
<p>A notebook, <code>html_notebook</code>, is a variation on a <code>html_document</code>. The rendered outputs are very similar, but the purpose is different. A <code>html_document</code> is focused on communicating with decision makers, while a notebook is focused on collaborating with other data scientists. These different purposes lead to using the HTML output in different ways. Both HTML outputs will contain the fully rendered output, but the notebook also contains the full source code. That means you can use the <code>.nb.html</code> generated by the notebook in two ways:</p>
<ol style="list-style-type: decimal">
<li><p>You can view it in a web browser, and see the rendered output. Unlike
<code>html_document</code>, this rendering always includes an embedded copy of
the source code that generated it.</p></li>
<li><p>You can edit it in RStudio. When you open an <code>.nb.html</code> file, RStudio will
automatically recreate the <code>.Rmd</code> file that generated it. In the future, you
will also be able to include supporting files (e.g. <code>.csv</code> data files), which
will be automatically extracted when needed.</p></li>
</ol>
<p>Emailing <code>.nb.html</code> files is a simple way to share analyses with your colleagues. But things will get painful as soon as they want to make changes. If this starts to happen, it’s a good time to learn Git and GitHub. Learning Git and GitHub is definitely painful at first, but the collaboration payoff is huge. As mentioned earlier, Git and GitHub are outside the scope of the book, but there’s one tip that’s useful if you’re already using them: use both <code>html_notebook</code> and <code>github_document</code> outputs:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">output:</span>
  <span class="fu">html_notebook:</span><span class="at"> default</span>
  <span class="fu">github_document:</span><span class="at"> default</span></code></pre>
<p><code>html_notebook</code> gives you a local preview, and a file that you can share via email. <code>github_document</code> creates a minimal md file that you can check into git. You can easily see how the results of your analysis (not just the code) change over time, and GitHub will render it for you nicely online.</p>
</div>
<div id="presentations" class="section level2">
<h2><span class="header-section-number">29.5</span> Presentations</h2>
<p>You can also use R Markdown to produce presentations. You get less visual control than with a tool like Keynote or PowerPoint, but automatically inserting the results of your R code into a presentation can save a huge amount of time. Presentations work by dividing your content into slides, with a new slide beginning at each first (<code>#</code>) or second (<code>##</code>) level header. You can also insert a horizontal rule (<code>***</code>) to create a new slide without a header.</p>
<p>R Markdown comes with three presentation formats built-in:</p>
<ol style="list-style-type: decimal">
<li><p><code>ioslides_presentation</code> - HTML presentation with ioslides</p></li>
<li><p><code>slidy_presentation</code> - HTML presentation with W3C Slidy</p></li>
<li><p><code>beamer_presentation</code> - PDF presentation with LaTeX Beamer.</p></li>
</ol>
<p>Two other popular formats are provided by packages:</p>
<ol style="list-style-type: decimal">
<li><p><code>revealjs::revealjs_presentation</code> - HTML presentation with reveal.js.
Requires the <strong>revealjs</strong> package.</p></li>
<li><p><strong>rmdshower</strong>, <a href="https://github.com/MangoTheCat/rmdshower" class="uri">https://github.com/MangoTheCat/rmdshower</a>, provides a
wrapper around the <strong>shower</strong>, <a href="https://github.com/shower/shower" class="uri">https://github.com/shower/shower</a>,
presentation engine</p></li>
</ol>
</div>
<div id="dashboards" class="section level2">
<h2><span class="header-section-number">29.6</span> Dashboards</h2>
<p>Dashboards are a useful way to communicate large amounts of information visually and quickly. Flexdashboard makes it particularly easy to create dashboards using R Markdown and a convention for how the headers affect the layout:</p>
<ul>
<li>Each level 1 header (<code>#</code>) begins a new page in the dashboard.</li>
<li>Each level 2 header (<code>##</code>) begins a new column.</li>
<li>Each level 3 header (<code>###</code>) begins a new row.</li>
</ul>
<p>For example, you can produce this dashboard:</p>
<p><img src="screenshots/rmarkdown-flexdashboard.png" width="75%" style="display: block; margin: auto;" /></p>
<p>Using this code:</p>
<pre><code>---
title: &quot;Diamonds distribution dashboard&quot;
output: flexdashboard::flex_dashboard
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
knitr::opts_chunk$set(fig.width = 5, fig.asp = 1/3)
```

## Column 1

### Carat

```{r}
ggplot(diamonds, aes(carat)) + geom_histogram(binwidth = 0.1)
```

### Cut

```{r}
ggplot(diamonds, aes(cut)) + geom_bar()
```

### Colour

```{r}
ggplot(diamonds, aes(color)) + geom_bar()
```

## Column 2

### The largest diamonds

```{r}
diamonds %&gt;% 
  arrange(desc(carat)) %&gt;% 
  head(100) %&gt;% 
  select(carat, cut, color, price) %&gt;% 
  DT::datatable()
```</code></pre>
<p>Flexdashboard also provides simple tools for creating sidebars, tabsets, value boxes, and gauges. To learn more about flexdashboard visit <a href="http://rmarkdown.rstudio.com/flexdashboard/" class="uri">http://rmarkdown.rstudio.com/flexdashboard/</a>.</p>
</div>
<div id="interactivity" class="section level2">
<h2><span class="header-section-number">29.7</span> Interactivity</h2>
<p>Any HTML format (document, notebook, presentation, or dashboard) can contain interactive components.</p>
<div id="htmlwidgets" class="section level3">
<h3><span class="header-section-number">29.7.1</span> htmlwidgets</h3>
<p>HTML is an interactive format, and you can take advantage of that interactivity with <strong>htmlwidgets</strong>, R functions that produce interactive HTML visualisations. For example, take the <strong>leaflet</strong> map below. If you’re viewing this page on the web, you can drag the map around, zoom in and out, etc. You obviously can’t do that in a book, so rmarkdown automatically inserts a static screenshot for you.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(leaflet)
<span class="kw">leaflet</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">setView</span>(<span class="fl">174.764</span>, <span class="fl">-36.877</span>, <span class="dt">zoom =</span> <span class="dv">16</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">addTiles</span>() <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">addMarkers</span>(<span class="fl">174.764</span>, <span class="fl">-36.877</span>, <span class="dt">popup =</span> <span class="st">&quot;Maungawhau&quot;</span>) </code></pre>
<div id="htmlwidget-14d5992801777f4abbc5" style="width:70%;height:355.968px;" class="leaflet html-widget"></div>
<script type="application/json" data-for="htmlwidget-14d5992801777f4abbc5">{"x":{"options":{"crs":{"crsClass":"L.CRS.EPSG3857","code":null,"proj4def":null,"projectedBounds":null,"options":{}}},"setView":[[-36.877,174.764],16,[]],"calls":[{"method":"addTiles","args":["//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",null,null,{"minZoom":0,"maxZoom":18,"tileSize":256,"subdomains":"abc","errorTileUrl":"","tms":false,"noWrap":false,"zoomOffset":0,"zoomReverse":false,"opacity":1,"zIndex":1,"detectRetina":false,"attribution":"&copy; <a href=\"http://openstreetmap.org\">OpenStreetMap<\/a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA<\/a>"}]},{"method":"addMarkers","args":[-36.877,174.764,null,null,null,{"interactive":true,"draggable":false,"keyboard":true,"title":"","alt":"","zIndexOffset":0,"opacity":1,"riseOnHover":false,"riseOffset":250},"Maungawhau",null,null,null,null,{"interactive":false,"permanent":false,"direction":"auto","opacity":1,"offset":[0,0],"textsize":"10px","textOnly":false,"className":"","sticky":true},null]}],"limits":{"lat":[-36.877,-36.877],"lng":[174.764,174.764]}},"evals":[],"jsHooks":[]}</script>
<p>The great thing about htmlwidgets is that you don’t need to know anything about HTML or JavaScript to use them. All the details are wrapped inside the package, so you don’t need to worry about it.</p>
<p>There are many packages that provide htmlwidgets, including:</p>
<ul>
<li><p><strong>dygraphs</strong>, <a href="http://rstudio.github.io/dygraphs/" class="uri">http://rstudio.github.io/dygraphs/</a>, for interactive time
series visualisations.</p></li>
<li><p><strong>DT</strong>, <a href="http://rstudio.github.io/DT/" class="uri">http://rstudio.github.io/DT/</a>, for interactive tables.</p></li>
<li><p><strong>threejs</strong>, <a href="https://github.com/bwlewis/rthreejs" class="uri">https://github.com/bwlewis/rthreejs</a> for interactive 3d plots.</p></li>
<li><p><strong>DiagrammeR</strong>, <a href="http://rich-iannone.github.io/DiagrammeR/" class="uri">http://rich-iannone.github.io/DiagrammeR/</a> for diagrams
(like flow charts and simple node-link diagrams).</p></li>
</ul>
<p>To learn more about htmlwidgets and see a more complete list of packages that provide them visit <a href="http://www.htmlwidgets.org/" class="uri">http://www.htmlwidgets.org/</a>.</p>
</div>
<div id="shiny" class="section level3">
<h3><span class="header-section-number">29.7.2</span> Shiny</h3>
<p>htmlwidgets provide <strong>client-side</strong> interactivity — all the interactivity happens in the browser, independently of R. On one hand, that’s great because you can distribute the HTML file without any connection to R. However, that fundamentally limits what you can do to things that have been implemented in HTML and JavaScript. An alternative approach is to use <strong>shiny</strong>, a package that allows you to create interactivity using R code, not JavaScript.</p>
<p>To call Shiny code from an R Markdown document, add <code>runtime: shiny</code> to the header:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">title:</span><span class="at"> </span><span class="st">&quot;Shiny Web App&quot;</span>
<span class="fu">output:</span><span class="at"> html_document</span>
<span class="fu">runtime:</span><span class="at"> shiny</span></code></pre>
<p>Then you can use the “input” functions to add interactive components to the document:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(shiny)

<span class="kw">textInput</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;What is your name?&quot;</span>)
<span class="kw">numericInput</span>(<span class="st">&quot;age&quot;</span>, <span class="st">&quot;How old are you?&quot;</span>, <span class="ot">NA</span>, <span class="dt">min =</span> <span class="dv">0</span>, <span class="dt">max =</span> <span class="dv">150</span>)</code></pre>
<p><img src="screenshots/rmarkdown-shiny.png" width="357" style="display: block; margin: auto;" />
You can then refer to the values with <code>input$name</code> and <code>input$age</code>, and the code that uses them will be automatically re-run whenever they change.</p>
<p>I can’t show you a live shiny app here because shiny interactions occur on the <strong>server-side</strong>. This means that you can write interactive apps without knowing JavaScript, but you need a server to run them on. This introduces a logistical issue: Shiny apps need a Shiny server to be run online. When you run shiny apps on your own computer, shiny automatically sets up a shiny server for you, but you need a public facing shiny server if you want to publish this sort of interactivity online. That’s the fundamental trade-off of shiny: you can do anything in a shiny document that you can do in R, but it requires someone to be running R.</p>
<p>Learn more about Shiny at <a href="http://shiny.rstudio.com/" class="uri">http://shiny.rstudio.com/</a>.</p>
</div>
</div>
<div id="websites" class="section level2">
<h2><span class="header-section-number">29.8</span> Websites</h2>
<p>With a little additional infrastructure you can use R Markdown to generate a complete website:</p>
<ul>
<li><p>Put your <code>.Rmd</code> files in a single directory. <code>index.Rmd</code> will become
the home page.</p></li>
<li><p>Add a YAML file named <code>_site.yml</code> provides the navigation for the site.
For example:</p>
<pre><code>name: &quot;my-website&quot;
navbar:
  title: &quot;My Website&quot;
  left:
    - text: &quot;Home&quot;
      href: index.html
    - text: &quot;Viridis Colors&quot;
      href: 1-example.html
    - text: &quot;Terrain Colors&quot;
      href: 3-inline.html</code></pre></li>
</ul>
<p>Execute <code>rmarkdown::render_site()</code> to build <code>_site</code>, a directory of files ready to deploy as a standalone static website, or if you use an RStudio Project for your website directory. RStudio will add a Build tab to the IDE that you can use to build and preview your site.</p>
<p>Read more at <a href="http://rmarkdown.rstudio.com/rmarkdown_websites.html" class="uri">http://rmarkdown.rstudio.com/rmarkdown_websites.html</a>.</p>
</div>
<div id="other-formats" class="section level2">
<h2><span class="header-section-number">29.9</span> Other formats</h2>
<p>Other packages provide even more output formats:</p>
<ul>
<li><p>The <strong>bookdown</strong> package, <a href="https://github.com/rstudio/bookdown" class="uri">https://github.com/rstudio/bookdown</a>,
makes it easy to write books, like this one. To learn more, read
<em>Authoring Books with R Markdown</em><span id="fn33" class="footnote" data-pagedown-footnote-number="33" style="white-space: pre-line;"><a href="https://bookdown.org/yihui/bookdown/" class="uri">https://bookdown.org/yihui/bookdown/</a></span>,
by Yihui Xie, which is, of course, written in bookdown. Visit
<a href="http://www.bookdown.org" class="uri">http://www.bookdown.org</a> to see other bookdown books written by the
wider R community.</p></li>
<li><p>The <strong>prettydoc</strong> package, <a href="https://github.com/yixuan/prettydoc/" class="uri">https://github.com/yixuan/prettydoc/</a>,
provides lightweight document formats with a range of attractive
themes.</p></li>
<li><p>The <strong>rticles</strong> package, <a href="https://github.com/rstudio/rticles" class="uri">https://github.com/rstudio/rticles</a>, compiles a
selection of formats tailored for specific scientific journals.</p></li>
</ul>
<p>See <a href="http://rmarkdown.rstudio.com/formats.html" class="uri">http://rmarkdown.rstudio.com/formats.html</a> for a list of even more formats. You can also create your own by following the instructions at <a href="http://rmarkdown.rstudio.com/developer_custom_formats.html" class="uri">http://rmarkdown.rstudio.com/developer_custom_formats.html</a>.</p>
</div>
<div id="learning-more-5" class="section level2">
<h2><span class="header-section-number">29.10</span> Learning more</h2>
<p>To learn more about effective communication in these different formats I recommend the following resources:</p>
<ul>
<li><p>To improve your presentation skills, I recommend
<em>Presentation Patterns</em><span id="fn34" class="footnote" data-pagedown-footnote-number="34" style="white-space: pre-line;"><a href="https://amzn.com/0321820800" class="uri">https://amzn.com/0321820800</a></span>, by Neal Ford,
Matthew McCollough, and Nathaniel Schutta. It provides a set of effective
patterns (both low- and high-level) that you can apply to improve your
presentations.</p></li>
<li><p>If you give academic talks, I recommend reading the <em>Leek group guide
to giving talks</em><span id="fn35" class="footnote" data-pagedown-footnote-number="35" style="white-space: pre-line;"><a href="https://github.com/jtleek/talkguide" class="uri">https://github.com/jtleek/talkguide</a></span>.</p></li>
<li><p>I haven’t taken it myself, but I’ve heard good things about Matt
McGarrity’s online course on public speaking:
<a href="https://www.coursera.org/learn/public-speaking" class="uri">https://www.coursera.org/learn/public-speaking</a>.</p></li>
<li><p>If you are creating a lot of dashboards, make sure to read Stephen Few’s
Information Dashboard Design: The Effective Visual Communication
of Data<span id="fn36" class="footnote" data-pagedown-footnote-number="36" style="white-space: pre-line;"><a href="https://amzn.com/0596100167" class="uri">https://amzn.com/0596100167</a></span>. It will help you create dashboards
that are truly useful, not just pretty to look at.</p></li>
<li><p>Effectively communicating your ideas often benefits from some
knowledge of graphic design. <em>The Non-Designer’s Design
Book</em><span id="fn37" class="footnote" data-pagedown-footnote-number="37" style="white-space: pre-line;"><a href="http://amzn.com/0133966151" class="uri">http://amzn.com/0133966151</a></span> is a great place to start.</p></li>
</ul>
<!--chapter:end:rmarkdown-formats.Rmd-->
</div>
</div>
<div id="r-markdown-workflow" class="section level1">
<h1><span class="header-section-number">30</span> R Markdown workflow</h1>
<p>Earlier, we discussed a basic workflow for capturing your R code where you work interactively in the <em>console</em>, then capture what works in the <em>script editor</em>. R Markdown brings together the console and the script editor, blurring the lines between interactive exploration and long-term code capture. You can rapidly iterate within a chunk, editing and re-executing with Cmd/Ctrl + Shift + Enter. When you’re happy, you move on and start a new chunk.</p>
<p>R Markdown is also important because it so tightly integrates prose and code. This makes it a great <strong>analysis notebook</strong> because it lets you develop code and record your thoughts. An analysis notebook shares many of the same goals as a classic lab notebook in the physical sciences. It:</p>
<ul>
<li><p>Records what you did and why you did it. Regardless of how great your
memory is, if you don’t record what you do, there will come a time when
you have forgotten important details. Write them down so you don’t forget!</p></li>
<li><p>Supports rigorous thinking. You are more likely to come up with a strong
analysis if you record your thoughts as you go, and continue to reflect
on them. This also saves you time when you eventually write up your
analysis to share with others.</p></li>
<li><p>Helps others understand your work. It is rare to do data analysis by
yourself, and you’ll often be working as part of a team. A lab notebook
helps you share not only what you’ve done, but why you did it with your
colleagues or lab mates.</p></li>
</ul>
<p>Much of the good advice about using lab notebooks effectively can also be translated to analysis notebooks. I’ve drawn on my own experiences and Colin Purrington’s advice on lab notebooks (<a href="http://colinpurrington.com/tips/lab-notebooks" class="uri">http://colinpurrington.com/tips/lab-notebooks</a>) to come up with the following tips:</p>
<ul>
<li><p>Ensure each notebook has a descriptive title, an evocative filename, and a
first paragraph that briefly describes the aims of the analysis.</p></li>
<li><p>Use the YAML header date field to record the date you started working on the
notebook:</p>
<pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">date:</span><span class="at"> 2016-08-23</span></code></pre>
<p>Use ISO8601 YYYY-MM-DD format so that’s there no ambiguity. Use it
even if you don’t normally write dates that way!</p></li>
<li><p>If you spend a lot of time on an analysis idea and it turns out to be a
dead end, don’t delete it! Write up a brief note about why it failed and
leave it in the notebook. That will help you avoid going down the same
dead end when you come back to the analysis in the future.</p></li>
<li><p>Generally, you’re better off doing data entry outside of R. But if you
do need to record a small snippet of data, clearly lay it out using
<code>tibble::tribble()</code>.</p></li>
<li><p>If you discover an error in a data file, never modify it directly, but
instead write code to correct the value. Explain why you made the fix.</p></li>
<li><p>Before you finish for the day, make sure you can knit the notebook
(if you’re using caching, make sure to clear the caches). That will
let you fix any problems while the code is still fresh in your mind.</p></li>
<li><p>If you want your code to be reproducible in the long-run (i.e. so you can
come back to run it next month or next year), you’ll need to track the
versions of the packages that your code uses. A rigorous approach is to use
<strong>packrat</strong>, <a href="http://rstudio.github.io/packrat/" class="uri">http://rstudio.github.io/packrat/</a>, which stores packages
in your project directory, or <strong>checkpoint</strong>,
<a href="https://github.com/RevolutionAnalytics/checkpoint" class="uri">https://github.com/RevolutionAnalytics/checkpoint</a>, which will reinstall
packages available on a specified date. A quick and dirty hack is to include
a chunk that runs <code>sessionInfo()</code> — that won’t let you easily recreate
your packages as they are today, but at least you’ll know what they were.</p></li>
<li><p>You are going to create many, many, many analysis notebooks over the course
of your career. How are you going to organise them so you can find them
again in the future? I recommend storing them in individual projects,
and coming up with a good naming scheme.</p></li>
</ul>
<!--chapter:end:rmarkdown-workflow.Rmd-->
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
